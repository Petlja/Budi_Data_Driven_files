# Колико Земаља трошимо?
У овом одељку бавићемо се екологијом, тачније утицајем човека на природну средину. Истраживања показују да људи готово дупло брже троше биокапацитете планете Земље него што она успева да их обнови. Укупна потреба људи, заједнице, активности или државе за природним ресурсима за производњу хране и апсорбцију произведеног отпада често се назива *еколошким отиском* (енгл. *ecological footprint*). Еколошки отисак се изражава у *глобалним хектарима* (gha) по становнику, тј. површином плодне земље, шума и воде потребном за задовољење потреба. Ако знамо да је биокапацитет планете Земље тренутно око 1.7 gha по становнику (и да константно опада), можемо да израчунамо __[колико планета "троши" свака држава](https://www.overshootday.org/how-many-earths-or-countries-do-we-need/)__. Тако би нам, на пример, било потребно чак пет Земаља када бисмо сви живели као грађани САД. Интензитет трошења природних ресурса може да се изрази и у потребним државама, па је тако Јапан земља која има највећи несклад између еколошких потреба и могућности јер је њеним грађанима, уз садашњу потрошњу биокапацитета, заправо потребно готово осам Јапана. 

## Пример података о еколошком отиску
У овој вежби ће бити употребљен скуп бесплатних отворених података о еколошком отиску __[**National Footprint and Biocapacity Accounts 2021 Public Data Package**](https://www.footprintnetwork.org/licenses/public-data-package-free/)__ *think tank* институције *Global Footprint Network*. *Think tank* организације су независне институције које се баве истраживањем политика и политичког деловања и имају за циљ да образују или посаветују креаторе политика и јавност кроз разноврсне канале комуникације.

Као што је уобичајено, најпре ћемо увести табелу са подацима и приказати основне информације о њеном садржају.

import pandas as pd

otisak = pd.read_csv('podaci/NFA 2021.csv') 
otisak.info()

Табела се састоји од 184 реда и 25 колона. Већина варијабли садржи податке типа `float64`, односно децималне бројеве са тзв. *пливајућим зарезом*, тј. произвољним бројем децималних места. Информација о типу података нам је веома битна да бисмо знали које анализе можемо да применимо на некој варијабли. У том смислу треба обратити пажњу да чак пет варијабли у табели има тип података `object` што највероватније указује на то да садрже вредности које су комбинација слова и бројевa. То је посебно сумњиво у случају варијабле *GDP per cap* која би требало да садржи бројчану вредност бруто друштвеног производа (БДП) по становнику. Стога ћемо проверити како би билиотека `pandas` третирала податке из ове колоне. Приказаћемо тип податка (функција `type()`) за први запис у колони (индекс `[0]`).

print('Подаци у колони GDP per cap су типа', type(otisak['Income Group'][0]))

Као што се види, подаци у колони *GDP per cap* су заправо текстуалног типа, тј. дефинисани су као класа `str` (стринг). То значи да би било која алгебарска операција над њима довела до грешке. Приказаћемо првих 5 редова (записа) табеле за све колоне коју садрже податке типа `object` да бисмо лакше установили о чему је реч.

otisak.select_dtypes(include=object).head(5)

Варијабле *Country* и *Region* су очекивано стрингови, а колона *Data Quality* је интерна ознака истраживачке институције која показује каквог су квалитета прикупљени подаци, односно колико су поуздани. Међутим, преостале две колоне би у анализама требало да се посматрају као нумеричке. Вредности варијабле *GDP per cap* нису учитане као нумеричке због ознака `$` и `,`. Пре него што обавимо потребне корекције података приказаћемо јединствене вредности свих варијабли типа `object`. Искључићемо варијаблу `Country` која има превелик број нивоа, тј. јединствених вредности. 

# Правимо нови скуп само од колона типаobject
koloneObj = otisak.select_dtypes(include=object)

# Петљом пролазимо кроз све елемете скупа
for kolona in koloneObj:
    # Креирамо низ од јединствених вредности у колони
    brVred = otisak[kolona].unique()
    # Приказујемо низ ако има мање од 10 елемената
    if len(brVred) < 10: 
        print(otisak[kolona].name, ":", otisak[kolona].unique())

Видимо да постоје три ознаке квалитета података које би евентуално могле да послуже као основа за ограничавање анализе на најпоузданије податке (3A). Варијабла *Region* нам омогућава да државе поделимо у осам група, односно региона. На крају, вредности у колони *Income Group* биле би много употребљивије да су означене цифрама од 1 до 4 јер је у питању ранг држава према просечним приходима њених грађана, од најнижег до највишег: *low income (LI)*, *lower medium (LM)*, *upper medium (UM)* и *high (HI)*. Текстуалне ознаке могу да послуже само као основ за категоризацију, док би рангирање ипак пружило могућност за закључиванје о разликама у изражености неког својства међу државама.  

>Америчи психолог *Стенли Смит Стивенс* препоручио је поделу варијабли на основу тзв. *нивоа мерења*. Варијабле се на основу њихове "квантитативне моћи" деле на номиналне, ординалне, интервалне и размерне. *Номиналне варијабле*, као што је регион, омогућавају нам само да разликујемо ентитете међу собом. *Ординалне* или *ранг варијабле* омогућавају да кажемо који ентитет има више изражено неко својство, али не и за колико више. Таква варијабла је поменута категорија прихода. *Интервалне варијабле* омогућавају и да одговоримо за колико је неки ентитет бољи. На крају, *размерне варијабле* пружају могућност да одговоримо и на питање колико пута је неко својство више или мање изражено јер скале тих варијабли поседују апсолутну нулу. При томе виши нивои мерења омогућавају примену напреднијих статистичких поступака. Разлику између последња два типа варијабли није тако лако направити. На пример, висина је размерна варијабла јер би 0 заиста значила одсуство висине, али температура у Целзијусима је само интервална јер је 0 арбитрарно одеђена као тачка на којој се вода претвара у лед и не значи "одсуство" температуре. За основно разумевање статистичких анализа довољно је да корисник уме да разликује прва три нивоа.

У колони *GDP per cap* најпре ћемо уклонити знаке `$` и `,` а потом конвертовати варијаблу из типа `object` у тип `float`. Да бисмо ефикасније обавили измену употребићемо тзв. *регуларне изразе* (енгл. __[*regular expressions*](https://docs.python.org/3/library/re.html)__) па је стога аргумент `regex` функције `replace` постављен на `True`. У угластим заградама смо навели све ознаке (`[$,]`) које желимо да заменимо празном ниском (`''`). Иако се користе специјални карактери, регуларни изрази су у суштини текстуалне ниске, па их морамо стављати под наводнике.

otisak['GDP per cap'] = otisak['GDP per cap'].replace('[$,]','', regex=True)
otisak['GDP per cap'] = otisak['GDP per cap'].astype(float, errors = 'raise')

Након тога ћемо заменити вредности варијабле `Income Group` и записати их у нову варијаблу `Income Group R`.

otisak['Income Group R'] = otisak['Income Group'].replace({ 'LI' : 1, 'LM' : 2, 'UM' : 3, 'HI' : 4 })

>За маниипулацију подацима често ћемо користи Пајтон објекат `dictionary` или *речник*. Овај објекат ћете препознати као низ парова вредности одвојених двотачкама и обухваћених витичастим заградама. Објекат овог типа има општи облик `objekat = {<кључ>: <вредност>, <кључ>: <вредност>}`, па се тако нпр. може направити речник главних градова држава: `gradovi = {'Србија': 'Београд', 'Немачка': 'Берлин', 'Француска': 'Париз'}`.

Коначно, приказаћемо дистрибуцију вредности БДП уз помоћ хистограма, а дистрибуцију категорија прихода по становнику стубичастим дијаграмом. Претходно ћемо сортирати вредности ове друге варијабле по колони `Income Group R` како би се на графикону на првом месту појавио стубић који означава ниске приходе (LI), а на последњем високе (HI).

import matplotlib.pyplot as plt

# Правимо објекат figure који ће садржати два (под)графикона
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15,5))

# Искључујемо државе које имају БДП 0 јер је у питању очигледна грешка и приказујемо хистограм
otisak[otisak['GDP per cap'] > 0]['GDP per cap'].plot(kind='hist', edgecolor='white', color='#019573', ax=ax1)

# Постављамо наслов левог графикона и називе x- и y-осе
ax1.set_title("Расподела држава по вредностима БДП", fontsize=12) 
ax1.set_xlabel("БДП по становнику", labelpad=10, fontsize=11) 
ax1.set_ylabel('Број држава', fontsize=11)  

# Пребројавамо државе у свакој категорији и наводимо редослед категорија који желимо
otisak.sort_values(by='Income Group R')['Income Group'].value_counts()[['LI','LM','UM','HI']].plot(kind='bar', width=0.90, edgecolor='white', color='#019573', ax=ax2)

# Постављамо наслов десног графикона и називе x- и y-осе
ax2.set_title("Расподела држава по категоријама висине прихода", fontsize=12) 
ax2.set_xlabel("Категорија прихода по становнику", labelpad=10, fontsize=11) 
ax2.set_xticklabels(labels=['ниски','нижи\nсредњи','виши\nсредњи','високи'], rotation=0) 

plt.show()

Горњи графикони илуструју важност прецизне дефиниције и одабира варијабли којима се исказује израженост неког феномена. Подела на категорије приказана на десном графикону очигледно прикрива изузетну искошеност расподеле богатства међу земљама. Критеријуми Светске банке за сврставање у категорију земаља са високих приходима је око 12.000 долара, али тек на основу левог графикона видимо да је то уједно и категорија у којој постоји највећа варијабилност. Горња граница ovog распона, односно десни крај издуженог "репа" дистрибуције приказане на левом графикону, готово десет пута је већа од доње. Десни графикон сугерише да има највише држава са вишим и високим просечним приходима, али на основу левог видимо да је највеће богатство заправо сконцентрисано у релативно малој групи држава.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Промените параметар <b>otisak['GDP per cap'] > 0</b> у горњем коду тако да на левом графикону буду приказане само земље које имају просечан БДП мањи од 12.000 долара по становнику. Да ли је дистрибуција и даље толико искошена?</div> 

На крају, погледајмо колико планета је потребно појединачним државама, тј. колико ресурса би било потребно када бисмо сви на планети живели као грађани тих држава. Приказаћемо дистрибуцију варијабле *Number of Earths required* и означићемо границу на подеоку 1 што је вредност која показује да држава троши онолико природних ресурса колико их и има на располагању. За исцртавање овог графикона употребићемо библиотеку `seaborn`.

import seaborn as sbrn

# Поставићемо сиву позадину графикона
sbrn.set_theme(style='darkgrid')

# Дегинишемо величину графикона
fig = plt.figure(figsize=(12,6))

# Исцртавамо хисторграм заједно са кривом која приказује контуре дистрибуције (kde=True)
sbrn.histplot(otisak['Number of Earths required'], kde=True, bins=20, alpha=0.2, color='#019573')

# Подешавамо наслов графикона и називе оса
plt.title('Расподела потребних планета по државама', fontsize=14)
plt.xlabel('Број потребних планета', fontsize=13)
plt.ylabel('Број држава', fontsize=13)

# Подешавамо распон подеока на x-оси
plt.xticks(range(0, 11))

# Исцртавамо референтне линије изнад вредности 1 и 2
plt.axvline(1, linestyle='--', color='green', lw=1)
plt.axvline(2, linestyle='--', color='red', lw=1)

# Приказујемо графикон
plt.show()

Очигледно је да већина држава има веома високе вредности еколошког отиска што значи да би нам требало и до 9 Земаља када бисмо сви живели као грађани ових држава. Додуше, држава са вредностима изнад 6 има релативно мало и веома су удаљене од осталих. Овакве вредности називамо *аберантиним* или, популарније, *аутлајерима*. Да бисмо лакше повезали површине графикона, односно површине испод приказане криве дистрибуције података, направићемо табелу учесталости различитих категорије држава и приказати њихов удео у укупном броју држава. Обратите пажњу да смо уз стубиће приказали и тзв. *криву густине вероватноћа* која нам омогућава да лакше проценимо колики је удео вредности у неком интервалу или изнад и испод неке тачке. Прецизније, ова крива нам омогућава да проценимо вероватноћу неког исхода на основу емпиријских података које смо прикупили. Хистограм приказује расподеле учесталости (вероватноћа) на практичнији и интуитивнији начин, док је крива густине вероватноће нешто сложенији математички и теоријски концепт.

Употребићемо функцију `select` библиотеке `numpy` којом ћемо направити нову варијаблу са ознакама категорија на основу броја потребних земаља. Уочите да смо једну дугу линију кода преломили уз помоћ обрнуте косе црте `\` (енгл. *backslash*. У резултирајућој табели учесталости смо направили колону са пропорцијама чије су вредности израчунате као однос броја држава у категорији и укупног броја држава израчунатог помоћу функције `sum()`. Вредност је заокружена на две децимале уз помоћ функције `round(2)`.

import numpy as np

# Формираћемо интервале веријабле (< 1, 1, 1-2 и >=2)
granice = [ otisak['Number of Earths required'] < 1, 
            otisak['Number of Earths required'] == 1, 
            otisak['Number of Earths required'].between(1, 2, inclusive='neither'),
            otisak['Number of Earths required'] >=2
          ]

# Интервалима (категоријама) ћемо доделити једноставне називе због лакшег сортирања
kategorije = ['a', 'b', 'c', 'd']

# Сортирамо табелу по колони Number of Earths required
otisak.sort_values('Number of Earths required')

# Формирамо нову варијабли на основу дефинисаних распона и назива категорија
otisak['NER_Kat'] = np.select(granice, kategorije, default=np.nan)

# Правимо табелу учесталости (код преламамо оператором \ због превелике дужине)
# Мењамо називе колона функцијом rename_axis()
tabFrek = otisak['NER_Kat'].value_counts(sort=False). \
  rename_axis('Број потребних планета').reset_index(name='Број држава'). \
  replace(['a', 'b', 'c', 'd'], ['мање од једне', 'једна', 'између једне и две', 'више од две'])

# Додајемо колону п у којој су учесталости претворене у пропорције дељењем нјховом сумом
tabFrek['p'] = (tabFrek['Број држава'] / tabFrek['Број држава'].sum()).round(2) 

# Приказујемо табелу
tabFrek

Из приказане табеле јасније се види да више од 70% држава троши више природних ресурса него што их имамо на располагању. Проценат држава које се налазе између зелене и црвене граничне линије на графикону је 30%, али такође видимо да око 26% држава има релативно низак еколошки отисак и да разумно троши биокапацитете Земље.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Линију расподеле густине вероватноћа на последњем графикону изменили смо помоћу функцијe <b>get_lines()</b>. Претражите  објекта <a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.lines.Line2D.html"><b>Line2D</b></a> и покушајте самостално да измените боју и изглед линије.</div> 

На крају, пошто ћемо исте податке користити и у наредним анализама, смнимићемо их у нову csv датотеку да не бисмо поново морали да правимо измене које смо начинили у овој лекцији. Датотеку ћемо назвати *NFA 2021 v2*.

otisak.to_csv('podaci/NFA 2021 v2.csv', index=False)
#  Да ли богатији троше више ресурса?
У претходној лекцији смо прегледали податке који су достпуни у оквиру скупа __[**National Footprint and Biocapacity Accounts 2021 Public Data Package**](https://www.footprintnetwork.org/licenses/public-data-package-free/)__. На подацима смо направили одређене измене које смо сачували у новој табели *NFA 2021 v2*. Ову табелу ћемо користити у наредним анализама. 

import pandas as pd

otisak = pd.read_csv('podaci/NFA 2021 v2.csv')

Већ је речено да се помоћу варијабле *Number of Earths required* може исказати у којој мери нека држава троши своје, али и глобалне биокапацитете. Сада ћемо трошење природних ресурса приказати директније, као однос укупних биокапацитета сваке државе и њеног укупног еколошког отиска. Разлика између укупног еколошког отиска државе и њених биокапацитета означава се као *еколошки дефицит* уколико је отисак већи од биокапацитета или *еколошка резерва* уколико је обратно. Значи, ако нека држава троши онолико ресурса колико их има на располагању, однос ове две вредности биће 1. Државе ћемо приказати тачкацима у дводимензионалном координатном систему у коме су на x-оси вредности еколошког отиска, а на y-оси вредности укупног биокапацитета државе. На тај начин можемо да видимо какво је "распршење" држава и колико нјих има разлилите комбинације вредности две варијабле (високе-високе, ниске-ниске, високе-ниске, просечне-ниске итд.). Тачкице ћемо обојити различитим бојама у зависности од њиховог богатства, односно категорије просечних прихода њихових становника.  

import matplotlib.pyplot as plt
import seaborn as sbrn

logTra = False # Подесите на True ако желите да се вредности на осама трансформишу
graBio = 100   # Подесите на мању вредност ако желите да смањите распон варијабле Total biocapacity

sbrn.set_theme(style='darkgrid')

# Овај тип графикона приказује "укрштање" дистрибуција две варијабле  
graf = sbrn.jointplot(data=otisak[otisak['Total biocapacity'] < graBio].sort_values(by='Income Group R'), hue='Income Group',
    x='Total Ecological Footprint', y='Total biocapacity', height=9, s=50)

# Наслов графикона и називи оса
graf.fig.suptitle("Однос укупног биокапацитета и еколошког отиска", y=1.02, fontsize = 14)
graf.ax_joint.set_xlabel('Укупни еколошки отисак државе', fontsize=13)
graf.ax_joint.set_ylabel('Укупни биокапацитет државе', fontsize=13)

# Логаритамска трансформација вредности на осама
if logTra:
    graf.ax_joint.set_xscale('log')
    graf.ax_joint.set_yscale('log')

# Уређивање изгледа легенде
leg = graf.ax_joint.legend_
leg.set_title('Ниво прихода', prop = {'size':12})
nazKat = ['ниски', 'нижи средњи', 'виши средњи', 'високи']
leg.get_frame().set_linewidth(0)
plt.setp(leg.get_texts(), fontsize='12')
for rb, lab in enumerate(leg.get_texts()):
    leg.get_texts()[rb].set_text(nazKat[rb])

# Цртање дијагоналне линије, тј. функције y = x
x0, x1 = graf.ax_joint.get_xlim()
y0, y1 = graf.ax_joint.get_ylim()
lims = [max(x0, y0), min(x1, y1)]
graf.ax_joint.plot(lims, lims, color='maroon', linestyle='--', linewidth=1)

plt.show()

Црвеном линијом на горњем графикону исцртана је функција `y = x`, тачније граница одрживости. То је теоријски низ вредности који приказује однос у коме би свака држава трошила онолико ресурса колико их има на располагању. Видимо да је нешто више држава испод те линије што показује да имају еколошки дефицит, тј. да им је вредност на x-оси (потрошња) већа од вредности на y-оси (биокапацитет). На основу боје тачкица може се закључити да су то углавном државе са високим просечним приходима становника. На ободима дијаграма распршења приказане су и дистрибуције вредности обе варијабле што нам омогућава да проценимо њихове просеке и степен варијаблности за сваку категорију држава. Дистрибуције категорија су обојене бојама које су приказане на легенди.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Велика варијабилност појава отежава нам интерпретацију резутата приказаних на горњем графикону. Подесите вредност варијабле <b>logTra</b> у горњем коду на <b>True</b> да бисте трансформисали вредности на осама рачунањем њихових логаритама.</div> 

>Логаритамска трансформација вредности на осама координатног система је метода која се често користи како би се унапредила читљивост графикона. У основи, ради се o умањивању вредности али тако да се оне које се веома велике умање више од оних мањих. Стога се оваква врсте трансформације назива *нелинеарном*. На пример, природни логаритам броја 10 је 1, броја 100 је 2, а броја 1.000 је 3. Очигледно је да се вредности на осама након трансформације не могу интерпретирати на исти начин, али то нам није толико битно. Битно је да су односи међу објектима приказаним на графикону остали у суштини непромењени и да можемо лакше да их поредимо. При томе нисмо уклонили ниједан аутлајер како што бисмо то учинили када бисмо смањили вредност варијабле `graBio` у горњем коду.

Еколошки дефицит или резерва већ су израчунати за сваку државу и забележени у колони *Ecological Deficit or Reserve*. Приказаћемо основне описне показатеље ове варијабле за четири групе држава формиране на основу категорија просечних прихода по становнику.

# Групишемо државе по категоријама прихода
tabela = otisak.groupby('Income Group R')['Ecological Deficit or Reserve'].describe().reset_index()

# Мењамо називе колона
tabela.rename(columns={'Income Group R': 'Приходи', 'count': 'Број држава'}, inplace=True)

# Мењамо ознаке категорија текстом
tabela['Приходи'].replace({1: 'ниски', 2: 'нижи средњи', 3: 'виши средњи', 4: 'високи'}, inplace=True)

# Приказујемо табелу
tabela

Из табеле се види да богатије државе имају негативну просечну вредности варијабле, тј. еколошки дефицит. Највећу еколошку резерву у просеку имају државе са приходима који су окарактерисани као нижи средњи. Међутим, приликом поређења група у статистици треба имати на уму две јако битне ствари. Прва је да два броја која се разликују у апсолутном смислу уопше не морају да буду и *статистички значајно* различити. То значи да разлике међу аритметичким срединама, нпр. друге две категорије држава, могу да буду небитне или потпуно случајне. Тестирање значајности разлика између две аритметичке средине обично се обавља методом која се зове *t-тест*. Израчунаћемо вредност t-теста за два пара категорија држава (НС-ВС и НС-ВИ) уз помоћ пакета `scipy`. Можете самостално да промените параметре у коду испод и израчунате вредности t-теста за друге парове аритметичких средина. 

from scipy.stats import ttest_ind

# Рачунање t-теста за комбинацију прихода НС-ВС 
ttestNSVS = ttest_ind(otisak[otisak['Income Group R'] == 2]['Ecological Deficit or Reserve'], 
    otisak[otisak['Income Group R'] == 3]['Ecological Deficit or Reserve'])

# Рачунање t-теста за комбинацију прихода НС-ВИ
ttestNSVI = ttest_ind(otisak[otisak['Income Group R'] == 2]['Ecological Deficit or Reserve'], 
    otisak[otisak['Income Group R'] == 4]['Ecological Deficit or Reserve'])

# Исписивање вредности t-теста
print ('Нижи средњи - виши средњи: t = ', ttestNSVS[0].round(2), ', p = ', ttestNSVS[1].round(2))
print ('Нижи средњи - високи: t = ', ttestNSVI[0].round(2), ', p = ', ttestNSVI[1].round(2))

Функција `ttest_ind` враћа две вредности којима смо приступили преко индекса 0 и 1 и заокружили на две децимале. Прва је вредност t-теста, а друга је тзв. *p вредност*. Вредност p нам на одређени начин показује колика је вероватноћа да се разлика међу аритметичким срединама коју смо добили десила сасвим случајно. У оба примера та вероватноћа је релативно велика, поготово за први пар варијабли. То значи да разлике не можемо да сматрамо стварним или статистички значајним. Консензус у статистици је да се разлике, односно статистички тестови, сматрају значајним ако су p вредности мање од 0,05 или, још боље, 0,01.

Приказаћемо ову другу разлику и графички. Полигоном фреквенција ћемо исцртати дистрибуције варијабле *Ecological Deficit or Reserve* за државе из група ниже средњих и високих прихода. Линијама ћемо обележити аритметичке средине дистрибуција.

# Дефинишемо величину графикона
plt.figure(figsize = (9,5))

# Исцртавамо полигон фреквенција (element='poly') за Ecological Deficit or Reserve
# Ограничавамо државе на две групе ['Income Group R'].isin([2,4])
ax = sbrn.histplot(otisak[(otisak['Income Group R'].isin([2,4]))], 
    x='Ecological Deficit or Reserve', hue='Income Group R', alpha=0.2, element='poly', palette='Set1')

# Подешавамо наслов графикона и називе оса
ax.set_xlabel('Еколошки дефицит или резерва')
ax.set_ylabel('Број држава')

# Нећемо уклањати аутлајере, али ћемо ограничити распон x-осе
ax.set_xlim(-15,15)

# Учитавамо објекат legend графикона у варијаблу leg ...
leg = ax.get_legend()
# ... да бисмо променили неколико параметара легенде
leg.set_frame_on(False)
leg.set_title('Категорија прихода')
leg.texts[0].set_text('нижи средњи')
leg.texts[1].set_text('високи')

# Исцртавамо линије којима су представљене аритметичке средине 
ax.axvline(otisak[otisak['Income Group R']==2]['Ecological Deficit or Reserve'].mean(), linestyle='--', color='#c52425', lw=1)
ax.axvline(otisak[otisak['Income Group R']==4]['Ecological Deficit or Reserve'].mean(), linestyle='--', color='#346994', lw=1)

plt.show()

Обратите пажњу да су аритметиче средине дистрибуција померене удесно у односу на доминантне вредности, односно "брдашца". Разлог су аутлајери које нисмо уклонили, али се не виде на графикону јер смо ограничили распон x-осе на -15 до 15. Осим тога, просек еколошких резерви је очигледно већи у групи држава са нижим приходима, али t-тест је показао да та разлика није статистички значајна. Овде долазимо до друге веома битне ствари везане за тестирање разлика, а то је варијабилност појаве унутар група. На основу вредности у горњој табели видимо да је стандардна девијација у категорији најбогатијих држава веома висока, тј. да је варијабилност међу државама веома велика. Распон вредности се креће од -13.8 до чак 92.1. Због тога ни аритемтичке средине група не можемо сматрати нарочито поузданим, па тако ни вредност t-теста. Стога се у статистици често користе и "грубље" метода за тестирање разлика међу групама у којима се не рачунају просеци већ се пореде рангови ентитета на некој варијабли. Један такав тест је *Мен-Витнијев U тест*. Израчунаћемо и његове вредности за исте парове категорија држава.

from scipy.stats import mannwhitneyu

# Рачунање М-В теста за комбинацију прихода НС-ВС
MWNSVS = mannwhitneyu(otisak[otisak['Income Group R'] == 2]['Ecological Deficit or Reserve'], 
    otisak[otisak['Income Group R'] == 3]['Ecological Deficit or Reserve'])

# Рачунање М-В теста за комбинацију прихода НС-ВИ
MWNSVI = mannwhitneyu(otisak[otisak['Income Group R'] == 2]['Ecological Deficit or Reserve'], 
    otisak[otisak['Income Group R'] == 4]['Ecological Deficit or Reserve'])

# Исписивање вредности М-В теста
print ('Нижи  средњи - виши средњи: U = ', MWNSVS[0].round(2), ', p = ', MWNSVS[1].round(2))
print ('Нижи  средњи - високи: U = ', MWNSVI[0].round(2), ', p = ', MWNSVI[1].round(2))

Овога пута резултати су потпуно другачији. Мен-Витнијев тест показује да су разлике међу свим категоријама држава заиста статистички значајне и да најбогатије државе заиста троше значајно више природних ресурса, више од осталих држава и више од онога што имају на располагању. Имајте на уму да p вредности заправо нису нулте и никада не могу да буду, већ су само изузетно мале.

Наравно, у ситуацијама када варијабилност не би била толико велика или у ситуацијама када је разлика међу групама изузетно велика, чак и уз велику варијабилност, t-тест би нам указао на постојање значајне разлике. У наредном примеру ћемо израчунати један веома очигледан t-тест који нам говори да се државе са ниским и високим приходима статистички значајно разликују по вредностима БПП. 

ttestNSVS = ttest_ind(otisak[otisak['Income Group R'] == 1].dropna()['GDP per cap'], 
    otisak[otisak['Income Group R'] == 4].dropna()['GDP per cap'])

print ('Разлика БДП између држава са ниским и високим приходима: t =', ttestNSVS[0].round(2), ', p =', ttestNSVS[1].round(2))

На крају, погледајмо и које то државе имају веома високе вредности еколошког дефицита или еколошких резерви. Овога пута ћемо приказати резултате на 3Д дијаграму распршења користећи пакете бибилиотеке `plotly`. Поред варијабле `Ecological Deficit or Reserve` приказаћемо и вредности __[indeksa humanog razvoja](https://sr.wikipedia.org/wiki/%D0%98%D0%BD%D0%B4%D0%B5%D0%BA%D1%81_%D1%85%D1%83%D0%BC%D0%B0%D0%BD%D0%BE%D0%B3_%D1%80%D0%B0%D0%B7%D0%B2%D0%BE%D1%98%D0%B0)__ (HDI) којим се мере мере сиромаштво, писменост, образовање и животни век нације, као и индекс остварења __[циљева одрживог развоја](https://www.rs.undp.org/content/serbia/sr/home/sustainable-development-goals.html)__ (SDGi).

import plotly.express as px

# Исцртавамо 3Д хистограм, али искључујемо неколико држава са веома ниским вредностима због прегледности графикона
graf = px.scatter_3d(otisak[otisak['Ecological Deficit or Reserve'] < 20], 
    x='HDI', y='SDGi', z='Ecological Deficit or Reserve', 
    color='Region', width=800, height=600, hover_data=['Country'])

# Мало естетски дотерујемо тачкице (маркере) 
graf.update_traces(marker=dict(size=6, line=dict(width=1, color='white')), selector=dict(mode='markers'))

# Смањујемо маргине графикона, позиционирамо легенду и постављамо називе графикона и оса
graf.update_layout(margin=dict(l=0, r=0, t=0, b=0), legend=dict(title='Регион', y=0.99, x=0.01, bgcolor='rgba(0,0,0,0)'),
    scene=dict(xaxis_title='Индекс хуманог развоја', yaxis_title='Индекс одрживог развоја', zaxis_title='Еколошки дефицит или резерва'))

# Овде уметнине код за промену назива региона у легенди

graf.show()

Ротирајте графикон и анализирајте повезаности међу варијаблама, као и позиције држава. Уочите да је индекс одрживог развоја у већој корелацији са индексом хуманог развоја него са еколошким резервама. Ово је и логично јер се одрживи развој не тиче само остварења циљева везаних за екологију, већ и за побољшање здравља, смањенје сиромаштва, унапређење образовања итд. Ови показатељи су много ближи онима на основу којих се рачуна индекс хуманог развоја. Уочите и то да земље Арапског полуострва имају највећи еколошки дефицит јер су им биокапацитети ниски, а богатство (нафтом) подиже потрошачке капацитете њихових грађана. Покушајте да процените степен и смер (+ или -) међусобне корелације варијабли приказаних на графикону, а потом упоредите своју процену са вредностима у наредној корелационој матрици.

otisak[otisak['Ecological Deficit or Reserve'] < 20][['HDI', 'SDGi', 'Ecological Deficit or Reserve']].corr().round(2)

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Покушајте сами да пронађете начин да промените називе региона у легенди графикона. Као полазна основа може да вам послужи <a href='https://stackoverflow.com/questions/64371174/plotly-how-to-change-variable-label-names-for-the-legend-in-a-plotly-express-li' target='_blank'>овај чланак</a>. Ако се не снађете, искористите код из датотеке <a href='podaci/legenda.txt' target='_blank'>legenda.txt</a>.</div> 
# Шта чини еколошки отисак?
У претходним лекцијама смо објаснили значење термина еколошки отисак, као и неке показатеље на основу којих можемо да закључимо које државе троше више ресурса него што имају на распологању. У ствари, тачнија формулација би била "него што их имамо на располагању" јер сви трошимо заједничке, укупне капацитете планете Земље. Сада ћемо се мало детаљније позабавити структуром еколошког отиска. Сама чињеница да смо често користили термин "укупни", говори нам да је еколошки отисак заправо збир више елемената који се односе на потребе становника за различитим врстама ресурса.

За почетак ћемо учитати скуп података (онај који смо уредили у првој лекцији), али ћемо ограничити основних информација ограничити само на варијабле које у свом називу имају термин *footprint*.   

import pandas as pd

otisak = pd.read_csv('podaci/NFA 2021 v2.csv')

# Правимо низ колона које имају 'Footrpint' у називу
ftKol = [kol for kol in otisak.columns if 'Footprint' in kol] 

otisak[ftKol].info()

На основу листе варијабли може се закључити да укупни еколошки отисак заправо чини пет компонената. Оне се тичу потреба за различитим природним ресурсима, како оним за производњу хране, тако и за апсорпцију штетних материја које човек производи. Пет компонената еколошког отиска односе се на утицај који човек, заједница или држава имају на оранице (енгл. *cropland*), пашњаке (енгл. *grazing*), шуме (енгл. *forest*), емисију гасова стаклене баште (енгл. *carbon*) и рибљи потенцијал (енгл. *fish*). У медијима се најчешће указује на важност *карбонског отиска*, али очигледно је да емисија штетних гасова представља само једну компоненту укупног еколошког отиска.

Приказаћемо дистрибуције појединачних компоненти на засебним графиконима, а затим и све заједно на истом графикону уз вредности укупног еколошког отиска.

import matplotlib.pyplot as plt
import seaborn as sbrn

# Правимо мрежу графикона 2 x 3
fig, ((ax1, ax2, ax3), (ax4, ax5, ax6)) = plt.subplots(2, 3, figsize=(15,8))

# За боје ћемо искористити matplotlib палету tab10
boje = plt.get_cmap('tab10')

# Додељујемо називе x-оса
naziviX = ['Оранице', 'Пашњаци', 'Шуме', 'Угљен-диоксид', 'Риба', 'Укупни еколошки отисак']
# Само први графикони у сваком реду имају називе y-оса
naziviY = ['Број држава', '', '', 'Број држава', '', ''] 

# Да не бисмо понаваљали код за сваки графикон користићемо for петљу
for rb, ax in enumerate(fig.axes[:-1]):
    # Исцртавамо стубичасти дијаграм са 15 стубића за сваку компоненту отиска
    sbrn.histplot(otisak[ftKol], x=ftKol[rb], alpha=0.7, ax=ax, color=boje(rb), bins=15, edgecolor='white')
    
    boja = list(boje(rb))   # Овде се играмо и мењамо провидност (alpha) ниво тренутне боје у низу boje(rb)
    boja[3] = 0.2           # Боје се изражвају као tuple објекат са четири елемента (RGBA):
    bordura = tuple(boja)   # R - црвена, G - зелена, B - плава, A - провидност
    
    # Исте податке представљамо полигоном фреквенција (елемент='полy') на последњем графикону
    sbrn.histplot(otisak[ftKol], x=ftKol[rb], alpha=0.2, element='poly', ax=ax6, color=boje(rb), edgecolor=bordura) 
    
    # Постављамо називе оса
    ax.set_xlabel(naziviX[rb])
    ax.set_ylabel(naziviY[rb])

    # Уписујемо редни број графикона у горњи десни угао
    ax.text(0.95, 0.95, rb+1, transform=ax.transAxes, fontsize=20, color=boje(rb), ha='right', va='top')

# На последњи графикон додајемо још и дистрибуцију укупног отиска
sbrn.histplot(otisak[ftKol], x=ftKol[5], alpha=0.5, element='poly', ax=ax6, color='gray')
ax6.text(0.95, 0.95, '6', transform=ax6.transAxes, fontsize=20, color='gray', ha='right', va='top')
ax6.set_xlabel('Укупни еколошки отисак')
ax6.set_ylabel('')

# Овим мало сабијамо простор између "кућица"
plt.tight_layout() 

За почетак обратите пажњу да вредности на x- и y-осама графикона нису једнаке. Због тога апсолутно поређење графикона није потпуно оправдано. На пример, можда вам делује да трећи и четврти графикон имају сличне распоне и дистрибуције, али након увида у вредности x-оса види се да је распон карбонског отиска чак четири пута већи. Исто важи и за поређење вредности на y-осама. Релативни однос дистрибуција и њихово поређење оправдано је само на шестом графикону, али на њему је много теже уочити распоне појединачних компоненти због великих разллика у распонима.

На основу изгледа дистрибуција на шестом графикону можемо да закључимо и да је карбонски отисак (црвени полигон) кључна компонента укупног еколошког отиска (сиви полигон). Вероватно ћете због тога једино за карбонски отисак успети да повучете аналогију између стубичастог дијаграма на графикону 4 и црвеног полигона фреквецнија на графикону 6. Остали полигони имају толико мале распоне у поређењу са укупним вредностима да се појављују као уски "шпицеви" у левом крају x-осе.

Обратите пажњу да су све дистрибуције мање или више позитивно искошене. То нам указује да је већина земаља груписана у зонама ниског отиска, а да релативно мали број држава веома одудара од типичних вредности. Ова аберантност је најуочљивија на другом, трећем и петом графикону. Наравно, треба напоменути да високе вредности отиска не значе нужно да је држава у еколошком дефициту, јер су то можда државе које имају и велики природни потенцијал.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Pokušajte samostalno da odaberete po pet država koje imaju najveće vrednosti na svakoj varijabli. Preporučujemo da upotrebite funkcije <b>sort_values()</b>, <b>head()</b> i <b>concat()</b> и да потражите њихове описе на интернету. Ако се не снађете, искористите код из датотеке <a href='podaci/ekotop5.txt' target='_blank'>ekotop5.txt</a>.</div> 
# Колике су разлике еколошког отиска међу регионима?
До сада смо анализирали укупни еколошки отисак, еколошки дефицит и еколошке резерве држава користећи просечан ниво прихода као критеријум за груписање. У наредних неколико примера бавићемо се поређењем држава са различитих континената. То значи да ћемо користити варијаблу *Region* као групишућу, односно категоријалну. 

Као и до сада, учитавамо кориговане податке које смо припремили у првој лекцији.

import pandas as pd

otisak = pd.read_csv('podaci/NFA 2021 v2.csv')

Ради лакше манипулације легендама и називима графикона које ћемо исцртатвати, одмах ћемо заменити називе региона терминима на српском језику.

# Променићемо називе региона у самом скупу и објединити категорије 'EU-28' и 'Other Europe'
# За ове потребе користимо Пајтон објекат dictionary (речник)
otisak.replace({'EU-28': 'Европа', 
                     'Other Europe': 'Европа',
                     'Africa': 'Африка',
                     'Asia-Pacific': 'Азија-Пацифик',
                     'North America': 'Северна Америка',
                     'South America': 'Јужна Америка',
                     'Middle East/Central Asia': 'Блиски исток и Централна Азија',
                     'Central America/Caribbean': 'Централна Америка'
                    }, inplace=True) # Промене обављамо директно у скупу otisak (inplace=True)

Вредности варијабле *Total Ecological Footprint* груписаћемо по регионима и упоредићемо дистрибуције помоћу кутијастог дијаграма. Обратите пажњу на разлике између аритметичких средина које су приказане кружићима и и медијане дистрибуција приказане линијама унутар кутије. Такође обратите пажњу на облике дистрибуција поредећи дужине левог и десног "брка" кутијастог дијаграма. На крају, звездицама су означени аберантни резултати или аутлајери. Постоје различити критеријуми за "проглашавање" неког резултата аутлајером, али обично се користе они које је предложио __[*Džon Tuki*](https://en.wikipedia.org/wiki/Outlier#Tukey's_fences)__, амерички статистичар који је и осмислио кутијасти дијаграм. 

import matplotlib.pyplot as plt

# Правимо копију скупа коју ћемо на крају обрисати
otisakBox = otisak[['Region', 'Total Ecological Footprint']].copy() 

# Овде дефинишемо изглед линија,
forLin = dict(linestyle='-', linewidth=1.5, color='#085545')

# овде изглед аутлајера,
forMar = dict(marker='*', markerfacecolor='white', markeredgecolor='#085545', markersize=9, markeredgewidth=1)

# а овде аритметичке средине
forAS = dict(marker='o', markerfacecolor='white', markeredgecolor='#085545', markersize=6, markeredgewidth=1.5)

# Припрема графикона
boks = otisakBox.sort_values('Region').boxplot(figsize=[14,7], column='Total Ecological Footprint', by='Region',
               vert=False, grid=False, flierprops=forMar, meanprops=forAS, 
               whiskerprops=forLin, capprops=forLin, boxprops=forLin, widths=0.6,
               medianprops=forLin, showmeans=True, showfliers=True # fliers су аутлајери
              ) 

plt.xlabel('Укупни еколошки отисак', fontsize=12)
plt.suptitle('')
plt.title('')

# У наредних неколико редова ћемо уз називе региона на y-оси дописати број држава које их чине
brDrz = otisakBox.sort_values('Region').groupby('Region').count().reset_index()
regioni = boks.axes.get_yticklabels()
for reg in regioni:
    ime = reg.get_text()
    reg.set_text(ime + ' (' + str(brDrz[brDrz['Region']==ime].iloc[0]['Total Ecological Footprint']) + ')')
boks.axes.set_yticklabels(regioni)

# На крају приказујемо графикон
plt.show()

Најпре уочавамо да је варијбилност еколошког отиска међу државама и међу континентима веома велика. Код већине дистрибуција дужина десног "брка" и положај медијане која је мања од аритметичке средине говори нам да су дистирбуције позитивно искошене, тј. да су одступања од типичних вредости већа у њеном десном делу. Иако поређења региона нису потпуно оправдана због великих разлика међу државама унутар истог региона, може се уочити да највећи еколошки отисак имају државе Северне Америке, а најмањи афричке државе. Помало чудан облик кутијастог дијаграма у случају Северне Америке последица је тога што су у ову категорију сврстане само четири државе. Највећу варијабилност унутар једног региона показују државе Блиског истока и Централне Азије.     

У одељку о јавном здрављу смо детаљније објаснили логику кутијастог дијаграма тако што смо га исцртали заједно са хистограмом. Учинићемо то и овде како бисмо још једном објаснили шта је представљено кутијом, а шта "брчићима". Употребићемо библиотеку `seaborn` и варијаблу *Total Ecological Footprint*.

# Увозимо библиотеку seaborn
import seaborn as sbrn

# Креирамо објекат figure (мрежу) са две осе ("кућице") (ax_box и ax_hist)
# "Кућице" ће делити x-осу (sahrex=True), a visine će im biti u odnosu 20% : 80%
fig, (ax_box, ax_hist) = plt.subplots(2, sharex=True, figsize=(10,6), gridspec_kw={'height_ratios': (0.15, 0.85)})
 
# У горњој "кућици" приказаћемо кутијасти дијаграм
sbrn.boxplot(data=otisakBox['Total Ecological Footprint'], orient="h", ax=ax_box, color='#019573')
# а у доњој хистограм за исту варијаблу
sbrn.histplot(data=otisakBox['Total Ecological Footprint'], ax=ax_hist, color='#019573')
 
# Уклањамо име и подеоке y-осе кутијастог дијаграма
ax_box.set(xlabel='', yticklabels='')

# Дајемо име x-оси
ax_hist.set(xlabel='Укупни еколошки отисак', ylabel='Број држава')

plt.show()

Уочите да на основу оба графикона можете да закључите да је дистрибуција искошена удесно на основу дужине десног "брчића" и висине стубића у десном делу хистограма. Такође се лако уочавају и аутлајери у виду изолованих стубића на хистограму, односно ромбића на кутијастом диијаграму. Око половине држава групише се у интервалу вредности од приближно 1,5 до приближно 4.  

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Промените вредност параметра <b>showfliers</b> у <b>True</b> у коду којим смо исцртали расподеле по регионима и анализирајте како неприказивање аутлајера утиче на изглед и прегледност кутијастих дијаграма. Израчунајте варијабилност (стандардну девијацију) приказане варијабле по регионима.</div> 

У наредном примеру употребићемо библиотеку __[Plotly Express](https://plotly.com/python-api-reference/plotly.express.html#px)__ да бисмо приказали профиле региона с обзиром на висину различитих компоненти еколошког отиска коришћењем тзв. *радар* или *паук дијаграма*. Сам назив графикона говори нам како он изгледа. У питању је круг издељен на онолико сегмената колико има варијабли. Свака варијабла је представљена линијом која полази из центра круга, а вредности варијабле су изражене удаљеношћу тачки од центра. Спајањем тачака добија се својеврстан профил ентитета (нпр. региона) на више варијабли. 

import plotly.express as px

stnd = False

# Правимо копију података тако што издвајамо колоне 6 до 14 из почетног скупа и бришемо две сувишне
otisakRadar = otisak.iloc[:,6:15].drop(columns=['Population (mil)', 'Income Group']).copy()

# Мењамо називе варијабли и рачунамо њихов просек за државе по регионима
otisakRadar.set_axis(['Region', 'Оранице', 'Пашњаци', 'Шуме', 'CO2', 'Риба', 'Земљиште'], axis=1, inplace=True)
otisakRadar = otisakRadar.groupby('Region').mean()

# На овом месту стандардизујемо вредости да бисмо их лакше упоредили
if stnd:
    for kol in range(0, 6): 
        otisakRadar[otisakRadar.columns[kol]] = otisakRadar[otisakRadar.columns[kol]] /  otisakRadar[otisakRadar.columns[kol]].max()

# Овде колоне табеле претварамо у редове тако да сваки регион добије онолико редова колико има варијабли
# Више информација о функцији stack() можете да пронађете на адреси https://pandas.pydata.org/docs/user_guide/reshaping.html
otisakRadar = otisakRadar.stack().reset_index()

# Мењамо називе колона 
otisakRadar = otisakRadar.rename(columns={otisakRadar.columns[1]: 'Tip', otisakRadar.columns[2]: 'Vrednost'})

# Исцртавамо поларни, паук или радар дијаграм
graf = px.line_polar(otisakRadar, r="Vrednost", theta="Tip", color="Region", line_close=True, width=700, height=400)
graf.update_layout(margin=dict(l=0, r=0, t=0, b=20), legend=dict(title='Регион', y=1.06, x=-0.3, bgcolor='rgba(0,0,0,0)'))
graf.update_traces(fill='toself', opacity=0.5)
graf.show()

del otisakRadar

У претходним анализама установили смо да је карбонски отисак најзначајнијна компонента еколошког отиска. __[Карбонски отисак](https://www.overshootday.org/how-many-earths-or-countries-do-we-need/)__ представља укупну количину емитованих гасова стаклене баште и обично се изражава у килограмима или тонама еквивалентног CO<sub>2</sub> (CO<sub>2</sub>eq). У скупу отворених података који користимо, ове вредности су конвертоване у површину биолошки продуктивног земљишта потребну да се апсорбују емитовани гасови. Иако су јединице приказаних димензија еквивалентне (gha), велике разлике у распонима отежавају поређење. Стога ћемо вредности стандардизовати на веома једноставан начин - дељењем са максималном вредношћу у низу.

Промените вредност варијабле `stnd` у `True` и поново покрените горњи код. Сада се много лакше уочавају разлике међу регионима. Државе Азијско-Пацифичког региона највише се ослањају на морски потенцијал, док су у случају Јужне Америке то пашњаци. Као што смо видели и у претходној анализи, државе Северне Америке имају највећи еколошки отисак, а и релативно посматрано највећу емисију гасова стаклене баште и највеће потребе за биокапацитетима типа ораница и шума.

На крају ове лекције поново ћемо се позабавити еколошким отиском у контексту богатства нација, тачније општег благостања становника. Овога пута ћемо анализирати повезаност еколошких резерви и индекса хуманог развоја (ИХР) државa. Најпре ћемо дефинисати скуп података на коме радимо и израчунаћемо корелације варијабли *HDI* и *Ecological Deficit or Reserve*.

# Прво нацртајте графикон са овим поставкама, а потпом направите измене:
# 1. Други параметар у between(-100, 100) промените у 40
# 2. Уклоните # испред другог реда да би се узео у обзир услов квалитета података 3А
# 3. Услов otisak['HDI']>-1 промените у otisak['HDI']>0 да би се искључиле државе без податка о HDI
otisakSkater = otisak[(otisak['Ecological Deficit or Reserve'].between(-100, 100)) &  
                      #(otisak['Data Quality']=='3A') &                             
                      (otisak['HDI']>-1)
                     ].copy()                                     

# Правимо корелациону матрицу од варијабли HDI и Ecological Deficit or Reserve
korMat = otisakSkater[['HDI', 'Ecological Deficit or Reserve']].corr(method='spearman').round(2)
korMat

У дијагоналним ћелијама матрице су јединице јер је свака варијабла у максималној корелацији сама са собом. У ћелијама [0,1] и [1,0] су исте вредности корелација. Корелације су негативне што значи да државе које имају виши индекс хуманог развоја генерално имају ниже вредности варијабле *Ecological Deficit or Reserve*, односно већи еколошки дефицит.

Сада ћемо употребити дијаграм распршења на коме су државе приказане кружићима у дводимензионалном простору варијабли *HDI* и *Ecological Deficit or Reserve*. Кружићи су обојени у складу са регионом којем припадају што је приказано у легенди. Да бисте видели називе држава пређите показивачем миша преко кружића.

# Узимамо корлеацију из ћелије [0,1] корелационе матрице да бисмо је исписали у називу графикона 
kor = korMat.iloc[0,1].round(2)

# Исцртавамо скатер дијаграм користећи дискретну палету боја px.colors.qualitative.Set2 
graf = px.scatter(otisakSkater, x='HDI', y='Ecological Deficit or Reserve', template='plotly_white',
                  width=900, height=600, hover_data=['Country'], color='Region', color_discrete_sequence=px.colors.qualitative.Set2
                 )

# Мало уређујемо изглед маркера
graf.update_traces(marker=dict(size=8, line=dict(width=1, color='darkgreen')), selector=dict(mode='markers'))

# Смањујемо маргине и подешавамо наслове графиконa и легенде 
graf.update_layout(margin=dict(l=80, r=0, t=60, b=60), 
                   xaxis_title='Индекс хуманог развоја', yaxis_title='Еколошки дефицит или резерва',
                   legend=dict(title='Регион', y=1, x=1.02, bgcolor='rgba(0,0,0,0)'),
                   title=dict(text='Повезаност ИХР и еколошких резерви по регионима (r = ' + str(kor) + ')'), 
                   title_xanchor='center', title_x=0.5
                  )

# Гранична линија за баланс отиска и биокапацитета (0)
graf.add_hline(y=0, line_width=1, line_dash='dot', line_color='darkgreen')
# Гранична линија за висок индекс хуманог развоја (0)
graf.add_vline(x=0.7, line_width=1, line_dash='dot', line_color='darkgreen')

graf.show()

del otisakSkater

Прва ствар коју уочавамо на графикону су атипичини и аберантни резултати који умногоме нарушавају изглед графикона. Три државе из групе тзв. Гвајана, које карактерише релативно велика површина и мали број становника, издвајају се по екстремно високим вредностима еколошких резерви. Са друге стране, неколико држава има нулте вредности ИХР, што може да се припише лошем квалитету података. И поред тога, корелација две варијабле је умерена и негативна што показује да државе у којима влада веће благостање генерално имају мање еколошке резерве, односно већи еколошки дефицит.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Направите промене услова за укључивање држава како је назначено у претпрошлој ћелији и поново покрените код у претходне две ћелије да бисте исцртали нови графикон.</div> 

Као што видите, корелација је сада још већа (по апсолутној вредности), а графикон је прегледнији. Корелација је негативна првенствено зато што је велики број тачака груписан у доњем десном квадранту графикона. То су државе који имају висок индекс хуманог развоја и ниске резерве природних ресурса, односно велики еколошки дефицит. Ипак, и даље треба имати на уму да се варијабилност еколошког дефицита драстично разликује између држава високог и ниског ИХР. Према препорукама Уједињених нација (__[UNDP](https://en.wikipedia.org/wiki/Human_Development_Index)__) та граница је постављена на вредност 0,7. Хоризонтална линија означава равнотежу између расположивих биокапацитета и потреба државе за њима. И овом анализом смо потврдили претходне резултате који говоре у прилог повезаности богатства државе, тачније благостања њених становника, и потреба за биолошким ресурсима. Негативна корелација указује на то да државе са већим ИХР имају мање еколошке резерве, односно већи еколошки дефицит. Тај дефицит је посебно висок код неких европских држава и држава Блиског истока. Са друге стране, већину афричких држава карактерише низак БДП и низак еколошки дефицит.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Које државе са високим индексом хуманог развоја бисте навели као позитивне примере односа према природној средини и биоптенцијалима, а које као негативне и лоше. Какав је тај однос с обзиром на регионе?</div> 
# Како се мењао еколошки отисак у последњих пола века?
У скупу података коју користимо налази се и табела која приказује промене вредности глобалног еколошког отиска у времену. Учитаћемо табелу *NFA 1961-2017* и анализирати доступне податке. Одмах ћемо променити називе варијабли да не бисмо накнадно морали да мењамо ознаке оса и легенди.

import pandas as pd

otisakTrend = pd.read_csv('podaci/NFA 1961-2017.csv')

# Оса (axis) 1 sadrži nazive kolona koje menjamo u samom skupu operatorom inplace=True
otisakTrend.set_axis(['Година', 'Оранице', 'Пашњаци', 'Шуме', 'CO2', 'Риба', 'Земљиште', 'Еколошки отисак', 'Биокапацитет'], axis=1, inplace=True)

# Приказујемо основне информацију о скупу
otisakTrend.info()

Погледаћемо најпре како се мењао однос вредности укупног еколошког отиска и расположивих биокапацитета у периоду од 1961. до 2017. године.

import plotly.express as px

# Параметар markers је доступан само у новијим верзијама библиотеке plotly,
# па ће можда бити потребно да је освежите користећи команду pip install --upgrade plotly
graf = px.line(otisakTrend, x='Година', y=['Еколошки отисак', 'Биокапацитет'], 
               markers=True, width=800, height=400, template='plotly_white')

# Мало подешавамо изглед линија, тачкица, наслове...
graf.update_layout(margin=dict(l=80, r=30, t=60, b=0), 
                   xaxis_title='', yaxis_title='Глобални хектари по становнику',
                   legend=dict(title='', y=0.01, x=0.01, bgcolor='rgba(0,0,0,0)', font=dict(size=12)),
                   title=dict(text='Промене глобалног еколошког отиска и биокапацитета у периоду 1961-2017.'), 
                              title_xanchor='center', font=dict(size=11), title_x=0.5
                  )

# Повећавамо број подеока на x-оси
graf.update_xaxes(nticks=13) 

# Приказујемо графикон
graf.show()

Разлике у правцима линија показују да од 70-тих година однос између укупног еколошког отиска и биокапацитета Земље добија негативан тренд. То се може приписати не толико порасту потреба за природним ресурсима, колико њиховом трошењу или уништавању. С обзиром на то да се биокапацитет планете Земље изражава у глобалним хектарима по становнику, на овај драстичан пад вероватно је утицао и глобални пораст популације. Уочите да су се одређени глобални феномени, као што су рецесије __[1973-1975](https://en.wikipedia.org/wiki/1973%E2%80%931975_recession)__ и __[2007-2009](https://en.wikipedia.org/wiki/Great_Recession)__, одразили и на смањење еколошког отиска, првенствено због смањених економских активности, али и платежне моћи становника.
<BR><BR>
У наредном кораку ћемо погледати како су се мењале вредности различитих компонената еколошког отиска у периоду од 1961. до 2017. Овога пута смо скупу додали и варијаблу `Земљиште` (енгл. *build-up land*) која се односи на потребе за грађевинским земљиштем, индустријским земљиштем и површинама за рудасрке копове. Промене ћемо приказати помоћу *дијаграма попуњених површина* (енгл. *filled area*). Међутим, пре тога морамо да трансформишемо табелу у нешто другачији формат. Погледајмо најпре како изгледа оригинална табела.

otisakTrend.head(5)

Видимо да табела има 9 колона од којих нам је заправо потребно само првих седам које се односе на компоненте еколошког отиска и годину. При томе не рачунамо крајњу леву колону која служи као нека врста идентификације записа и назива се *индексом*. У наредном кораку ћемо издвојити поменутих седам колона, а варијабли *Година* доделити статус индекса.

otisakTrendIndeks = otisakTrend.iloc[:,0:7].set_index('Година') # У наставку се могу низати функције
otisakTrendIndeks.head(5)

Колоне смо одабрали командом __[`iloc`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.iloc.html)__ којом се на основу целобројних вредности (енгл. *integer-locaton*) издвајају жељене ћелије табеле са подацима. Први аргумент у угластим заградама односи се на редове, а други на колоне. У нашем примеру издвојили смо све редове пошто смо ознаку `:` унели без распона бројева. Обратите пажњу да се колоне нумеришу бројевима од *0*  до *број колона - 1*, као и да колона са редним бројем 7 није издвојена. То значи да смо командом `iloc[:,0:7]` издвојили све записе из првих седам колона. Поред тога, колону *Година* смо претворили у индекс што можете да видите по томе што је назив колоне издвојен у засебан ред. На крају ћемо "препаковати" податке користећи функцију __[`stack`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html)__ тако да се колоне са називима варијабли за сваку годину претворе у редове. На тај начин се добија табела са тзв. *хијерархијским индексима* два нивоа.  

otisakTrendStack = otisakTrendIndeks.stack()
otisakTrendStack.head(10)

На крају остаје само да ресетујемо индексе и претворимо их у класичне колоне табеле. Бивши индекси који нису имали називе биће претворени у колоне под називима *level_1*, *level_2* итд., док ће колонама бити додељени називи *0*, *1*, *2* итд. 

otisakTrendPlot = otisakTrendStack.reset_index()
otisakTrendPlot.head(5)

Зато ћемо приликом ресетовања индекса одмах променити и називе колона.  

otisakTrendPlot = otisakTrendStack.reset_index().rename(columns = {'level_1': 'Тип', 0: 'Вредност у gha'})
otisakTrendPlot.head(5)

Табела је коначно спремна и можемо да исцртамо дијаграм попуњених површина. Имајте на уму да смо трансформације обавили у неколико корака због бољег разумевања и да сте све функције (`stack()`, `reset_index()` и `rename()`) mogli da nanižete u početnom okviru nakon `set_index('Година')`.

import plotly.express as px

# Сортирали смо вредности по опадајућем редоследу да би CO2 био на дну (ascending=False)
graf = px.area(otisakTrendPlot.sort_values('Вредност у gha', ascending=False), 
                                            x="Година", y="Вредност у gha", 
                                            color="Тип", width=800,
                                            template='plotly_white')

graf.update_layout(margin=dict(l=50, r=20, t=20, b=50),
                   legend=dict(title='Компонента еколошког отиска', y=1, x=0.01, bgcolor='rgba(0,0,0,0)')
                  )

graf.update_xaxes(nticks=13)

graf.show()


Као што се види на основу графикона, глобални еколошки отисак је у сталном порасту у протеклих 50 година. Највећи пораст се тиче емисије гасова стаклене баште, тачније површина потребних да се они апсорбују. Можете показивачем миша прећи преко линија да бисте видели колико се биле вредности у појединачним годинама. Ипак, на основу графикона је тешко закључивати о тачним вредностима промена, па ћемо за крај израчунати и тачну разлику између крајње и почетне године за сваку компоненту. Употребићемо табелу са подацима коју смо употребили и за цртање графикона.

otisak1961 = otisakTrendPlot[otisakTrendPlot['Година']==1961][['Тип', 'Вредност у gha']]
otisak2017 = otisakTrendPlot[otisakTrendPlot['Година']==2017][['Тип', 'Вредност у gha']]
otisakOdnos = otisak1961.merge(otisak2017, on='Тип')
otisakOdnos

Најпре смо направили нове табеле са колонама *Тип* и *Вредност у gha* за 1961. и 2017. годину, а потом смо те две табеле спојили командом `merge()` повезујући редове по колони *Тип*. Остаје само да израчунамо разлику издвојених вредности.

otisakOdnos['Промена (%)'] = (((otisakOdnos['Вредност у gha_y'] - otisakOdnos['Вредност у gha_x']) / otisakOdnos['Вредност у gha_x']) * 100).round(2)
otisakOdnos[['Тип', 'Промена (%)']]

Разлику између 2017. и 1961. године поделили смо вредношћу за 1961. како бисмо добили процентуални пораст. Неке разлике нису биле уочљиве на основу гррафикона, али сада су много јасније. На пример, потреба за површинама пашњака се у протеклих пола века чак и смањила, додуше незнатно. Исто тако, уочавамо да најзначајнији пораст није онај који се тиче емисије гасова већ онај који се односи на површине грађевинског земљишта. 

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Промене између година изразили смо процентуално што можда није најинтуитивнији начин. Како бисте изразили промену као умножак, тј. одговор на питање колико пута је отисак повећан? Покушајте да коригујете горњи код како бисте добили табелу са таквим вредностима.</div> 
# Колико смо далеко од одрживог развоја?
У претходним лекцијама одељка о еколошком отиску бавили смо се (материјалним) благостањем нација израженим кроз индекс хуманог развоја, категорију просечних прихода становика и бруто домаћи производ (БДП) по становнику. Присетите се да смо ову последњу варијаблу прочистили јер је садржала доларску ознаку и зарез због којих је третирана као текстуална. У коригованој табели, ове вредности су квантитавине и односе се на просечан приход државе остварен производњом роба и услуга у домаћој економији. Неспорно је да индустрија и стварање адекватних услова за живот захтева трошење природних ресурса. У наредним анализама ћемо се позабавити односима поменутих варијабли како бисмо видели да ли већи развој носи са собом и већи еколошки отисак. 
<BR><BR>
Најпре ћемо учитати кориговану табелу са подацима.

import pandas as pd

otisak = pd.read_csv('podaci/NFA 2021 v2.csv')

Сада ћемо проверити да ли је већа економска развијеност земље повезана са већим благостањем њених становника, овога пута израженим кроз очекивану дужину животног века. Како бисмо детаљније анализирали природу те повезаности, претходно ћемо поделити државе у две категорија - оне у којима је очекивани животни век дужи од 72 године и оне у којима је краћи од 73. 

import matplotlib.pyplot as plt

# Дефинисање објекта figure 
fig = plt.figure(figsize=(8,6))

# Скуп држава са очекиваним животним веком грађана краћим од 72 године
kraLE = otisak[otisak['Life Expectancy'] < 73][['Life Expectancy', 'GDP per cap', 'Country']].sort_values('GDP per cap', ascending=False).copy()
# Скуп држава са очекиваним животним веком грађана дужим од 71 године
duzLE = otisak[otisak['Life Expectancy'] > 72][['Life Expectancy', 'GDP per cap', 'Country']].sort_values('GDP per cap', ascending=False).copy()

# На истом графикону цртамо оба скупа података различиим бојама
plt.scatter(x=kraLE['Life Expectancy'], y=kraLE['GDP per cap'], color='maroon', alpha=0.5, s=60, linewidth=2)
plt.scatter(x=duzLE['Life Expectancy'], y=duzLE['GDP per cap'], color='seagreen', alpha=0.5, s=60, linewidth=2)

# Рачунамо коефицијент корелације живорног века и БДП
kor = otisak['Life Expectancy'].corr(otisak['GDP per cap'])

# Исписујемо наслов гарфикона и називе оса
plt.title('Повезаност дужине очекиваног животног\nвека и БДП по становнику r = ' + '%.2f' % kor, fontsize=12)
plt.ylabel('Очекивани животни век (целокупан распон)', fontsize=12)
plt.xlabel ('БДП по становнику', fontsize=12)

plt.show()

На горњем графикону приказана је повезаност БДП и дужине животног века за све државе. Кружиће смо учинили делимично провидним како би се јасније видело "гомилање" кружића око блиских вредности. Видимо да је корелација релативно висока и износи 0,65. Међутим, очигледно је да се интензитет везе разликује унутар две подкатегорије држава. Сада ћемо исцртати одвојене скатер дијаграме за две подкатегорије држава.

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(13,7))

# Скатер дијаграм за државе са краћим животним веком
ax1.scatter(x=kraLE['Life Expectancy'], y=kraLE['GDP per cap'], color='maroon', alpha=0.5, s=70, linewidth=2)

# Коефицијент корелације дужине животног века и БДП за прву групу
kor = kraLE['Life Expectancy'].corr(kraLE['GDP per cap'])

ax1.text(0.03, 0.92, 'r = ' + '%.2f' % kor, transform = ax1.transAxes, fontsize=14)
ax1.set_ylabel('БДП по становнику', fontsize=12)
ax1.set_xlabel('Очекивани животни век краћи од 72 године', fontsize=12)

# Скатер дијаграм за државе са дужим животним веком
ax2.scatter(x=duzLE['Life Expectancy'], y=duzLE['GDP per cap'], color='seagreen', alpha=0.5, s=70, linewidth=2)

# Коефицијент корелације дужине животног века и БДП за другу групу
kor = duzLE['Life Expectancy'].corr(duzLE['GDP per cap'])

ax2.text(0.03, 0.92, 'r = ' + '%.2f' % kor, transform = ax2.transAxes, fontsize=14)
ax2.set_xlabel('Очекивани животни век дужи од 71 године', fontsize=12)

# Овде уметните код за обележавање тачкица. Приликом формирања скупова kraLE и duzLE сортирали смо државе по 
# опадајућим вредностима БДП-а како бисмо могли да издвојимо само неколико аберантних резултата на графикону.

fig.suptitle('Повезаност дужине очекиваног животног века и БДП по становнику', fontsize=13)

fig.tight_layout()


Приказали смо исте корелације као и на претходном графикону, али појединачно за државе одређене категорије. Имајте на уму да су се распони оса изменили у складу са распонима вредности, али однос и распршење зелених, односно црвених тачкица је потпуно исти на доњим графиконима, као и на горњем. Видимо да је корелација у црвеној групи знатно нижа, док је у зеленој заправо виша него на укупном узорку. Овај феномен је у статистици познат као __[*Симпсонов парадокс*](https://en.wikipedia.org/wiki/Simpson%27s_paradox)__ и обично настаје као последица ограничавања распона неке варијабле. Приликом рачунања корелације варијабли увек треба обратити пажњу на то да ли закључак који је донет на укупном узорку важи и за сваки подузорак испитаника. У томе нам, наравно, највише помаже дијаграм распршења.  

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>На црвеном графикону постоји држава која има абернатну позицију и која се може сматрати аутлајером. Због ње је коефицијент корелације вероватно нижи него што би био када би се уклонила. Покушајте да измените услов за формирање скупа <i>kraLE</i> тако да ова држава буде искључена из анализе.</div>

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Пронађите начин да додате називе држава уз тачкице на графикону да бисмо видели која држава је аутлајер. Као полазна основа може да вам послужи <a href='https://stackoverflow.com/questions/14432557/matplotlib-scatter-plot-with-different-text-at-each-data-point' target='_blank'>овај чланак</a>. Ако се не снађете, искористите код из датотеке <a href='podaci/anotacije.txt' target='_blank'>anotacije.txt</a>.</div> 

Погледајмо сада у каквом је односу БДП са индексом хуманог развоја и укупним еколошким отиском.

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(13,6))

# Искључујемо државе код којих је вредност HDI 0, очигледно због грешке у подацима
otisakHDI = otisak[otisak['HDI'] > 0].copy()

ax1.scatter(x=otisakHDI['HDI'], y=otisakHDI['GDP per cap'], color='steelblue', alpha=0.5, s=70, linewidth=2)
kor = otisakHDI['HDI'].corr(otisakHDI['GDP per cap'])
ax1.text(0.03, 0.92, 'r = ' + '%.2f' % kor, transform = ax1.transAxes, fontsize=14)
ax1.set_ylabel('БДП по становнику', fontsize=12)
ax1.set_xlabel('Индекс хуманог развоја', fontsize=12)

ax2.scatter(x=otisakHDI['Total Ecological Footprint'], y=otisakHDI['GDP per cap'], color='purple', alpha=0.5, s=70, linewidth=2)
kor = otisakHDI['Total Ecological Footprint'].corr(otisakHDI['GDP per cap'])
ax2.text(0.03, 0.92, 'r = ' + '%.2f' % kor, transform = ax2.transAxes, fontsize=14)
ax2.set_xlabel('Укупни еколошки отисак', fontsize=12)

fig.suptitle('Повезаност БДП са индексом хуманог развоја и еколошким отиском', fontsize=14)
fig.tight_layout()

Познато је да се вредност БДП по становнику __[не може сматрати мером благостања нације](https://hbr.org/2019/10/gdp-is-not-a-measure-of-human-well-being)__. То је посебно очигледно на плавом графикону у групи дражава са нижим индексом хуманог развоја. Једно од могућих објашњења је делатност страних компанија које остварују профит на теротирији неке државе, али релативно мали проценат тог профита завршава код становника те државе. Са друге стране, чини се да је већа економска активност повезана са већим еколошким отиском, мада и у овом случају треба обратити пажњу на аберантне резултате на љубичастом графикону.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Покушајте да процените колика је корелација индекса хуманог развоја и дужине животног века на основу изгледа плавог и црвено-зеленог графикона. Пратећи упутство у <a href='https://pandas.pydata.org/pandas-docs/version/1.1.5/user_guide/style.html' target='_blank'>овом тексту</a> направите стилизовану корелациону матрицу варијабли које смо до сада описали да бисте проверили тачност процене. Упоредите своје решење са кодом у датотеци <a href='podaci/matrica.txt' target='_blank'>matrica.txt</a>.</div>

Одрживи развој подразумева развој друштва у коме се људске потребе задовољавају расположивим природним ресурсима. Тиме се осигурава дугорочно постојање људског друштва уз очување животне средине и биокапацитета планете. Према проценама организације чије податке користимо у овом одељку, човечанству су уз садашњу потрошњу биокапацитета потребне 1,73 планете Земље. То значи да трошимо природне ресурсе готово дупло брже него што природа успева да их обнови. У последњем примеру приказаћемо повезаност индекса хуманог развоја и броја потребних Земаља како бисмо утврдили које државе су успешније, а које мање успешне у остваривању циљева одрживог развоја. Овога пута ћемо употребити посебну врсту дијаграма распршења у коме се, уз вредности две варијабле на осама, приказује и трећа варијабле као величина круга. Због тога је овај графикон познат и као *мехурасти дијаграм* (енгл. *bubble chart*). У нашем примеру, величину кругова ћемо дефинисати на основу броја становника сваке државе, тј. варијабле *Population (mil)*. 

import plotly.express as px

# Мењамо називе региона и објединјујемо европске државе (EU-28 и Other Europe)
otisakHDI.replace({'EU-28': 'Европа', 
                     'Other Europe': 'Европа',
                     'Africa': 'Африка',
                     'Asia-Pacific': 'Азија-Пацифик',
                     'North America': 'Северна Америка',
                     'South America': 'Јужна Америка',
                     'Middle East/Central Asia': 'Блиски исток и Централна Азија',
                     'Central America/Caribbean': 'Централна Америка'
                    }, inplace=True)

# Исцртавамо скатер као мехурасти дијаграм у коме је величина круга дефинисана варијаблом Population (mil)
graf = px.scatter(otisakHDI, x='HDI', y='Number of Earths required',
                    size='Population (mil)', size_max=50,
                    color='Region', hover_name='Country',
                    template='plotly_white', width=800, height=500,
                    range_x=[0.3,1], range_y=[0,6]
                   )

# Референтна вредност за број планета
graf.add_hline(y=1, line_width=0.5, line_dash='dot', line_color='green') 

# Референтна вредност високох индекса хуманог развоја
graf.add_vline(x=0.7, line_width=0.5, line_dash='dot', line_color='green') 

# Квадрант одрживог развоја
graf.add_hrect(y0=0, y1=1, x0=(0.7-0.3)/0.7, x1=1, line_width=0, fillcolor='green', opacity=0.2) 

graf.update_layout(margin=dict(l=60, r=20, t=30, b=60), 
                   legend=dict(title='Регион', y=0.99, x=0.05, bgcolor='rgba(0,0,0,0)'),
                   xaxis_title='Индекс хуманог развоја', yaxis_title='Број потребних планета'
                  )

# Исписивање текста у квадранту глобалног одрживог развоја
graf.add_annotation(dict(font=dict(color='green',size=13),
                         x=0.97, y=0.35, xanchor='right', yanchor='bottom',
                         showarrow=False, text='Квадрант глобалног одрживог развоја'
                        )
                   )

graf.show()

На графикону су линијама означене две референтне вредности. Прва је вертикална линија изнад вредности 0,7 која се сматра границом високог индекса хуманог развоја, а друга је хоризонтална линија наспрам вредности 1 која означава да потрошња државе одговара тренутним биокапацитетима планете Земље. Donji desni pravougaonik ograničen ovim linijama predstavlja tzv. *kvadrant održivog razvoja*. Видимо да се само неколико држава налази у овом квадранту или близу њега. Већина је или у доњем левом или у горњем десном квадранту. Прву групу чине државе, углавном оне са афричког континента, које имају ниске вредности еколошког отиска, али и ниске вредности индекса хуманог развоја. У другој групи се налази САД и већина високо развијених европских држава које уједно имају и изузетно велику потршњу биокапацитета. Na osnovu vrednosti na grafikonu možemo da vidimo da bi nam bilo potrebno čak 4 do 6 planeta kada bismo svi živeli kao građani SAD, Kanade, Australije ili Ujedinjenih Arapskih Emirata.  

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Да ли бисте рекли да је величина популације, односно број становника неке државе, повезан са њеним развојем или еколошким отиском? Одговор на ово питање можете да добијете ако употребите код приказан у датотеци <a href='podaci/matrica.txt' target='_blank'>matrica.txt</a> који смо користили нешто раније.</div>

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Да смо као почетну тачку квадранта одрживог развоја на x-оси (<b>x0</b>) поставили на вредност 0.7, правоугаоник не би био правилно исцртан. Уместо тога, координате смо израчунали као вредност израза <b>(0.7-0.3)/0.7</b>. Да ли можете да откријете како смо дошли до њега? Обратите пажњу на дефинисани распон вредности x-осе.</div>
## 1. Увод

Да ли се музикa мења, има ли истине у критикама наших родитеља да је наша музика лошија од њихове? Да ли су неке песме (пре)више бучне, неке друге више за играње, неке више тужне...? Да ли је нешто од овога типично за неки музички жанр? Постоји ли нешто специфично код култних песама? О којим темама се најчешће пева? Сигурни смо да на сва или готово сва ова питања имате одговоре на основу свог музичког искуства и музичког укуса, али је циљ анализа пред нама да пробамо да потражимо одговоре на ова питања систематичније, на основу података.

***Питања***: Какви (који) подаци су вам потребни да одговорите на ова питања? (питање са понуђеним одговорима: текст, слика, бројеви,...)
Где бисте потражили податке да одговорите на ова питања? (питање са понуђеним одговоима: Репубублички завод за статистику, Јутјуб, Гугл тренд, лична колекција плоча, подаци платформе Спотифај...)

У овом одељку, анализираћемо скуп података прикупљен у оквиру једног научно-истраживачког рада. Аутори рада су у духу отворене науке и отворених података све прикупљене податке, анализиране у раду, оставили на располагање и свима нама да поновимо неке од претрага али и постављамо своја питања и тражимо одговоре. Оригинални рад бави се анализом тема о којима се пева у песмама од 1950 до данас и можете га пронаћи у локалном фолдеру, док се подаци прикупљени и анализирани у њему налазе [**овде**](https://data.mendeley.com/datasets/3t9vbwxgr5/3), али и у локалном фолдеру са подацима. 

Пре него што додатно формулишемо наша питања и кренемо у потрагу за одговорима, хајмо да се упознамо са садржајем скупа података, са карактеристикама податка, али предностима и манама метода којим су прикупљени и припремљени.

За почетак, учитаћемо само [pandas](https://pandas.pydata.org/docs/) библиотеку да бисмо учитали податке и погледали првих пар редова користећи функције [read_csv](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html) и [head](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html).

import pandas as pd # učitavanje biblioteke i nazivanje je njenom standardnom skraćenicom "pd"

podaci = pd.read_csv('muzika podaci/tcc_ceds_music_wo_index.csv') # učitavanje podataka csv formata iz lokalnog foldera
podaci.head(2) # prikaz prva dva reda podataka u tabeli

Како видимо да нам је на располагању 30 колона и не видимо све податке у прва два реда (зато што нису излистане све колоне), погледаћемо њихова имена, садржај и тип података користећи опцију [info](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.info.html):

podaci.info() # prikaz imena kolona, broja unosa i tipa podataka u svakoj od kolona

Видимо да имамо на располагању нешто преко 28 хиљада уноса (различитих песама - како бисте проверили да ли су све различите?), видимо да се у 30 колона крију подаци различитих типова и назива. Да ли имате идеју шта је у колонама? Како бисмо то открили?

На пример, можемо искористити и функцију [describe](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html) која ће нам дати увид у основне сумарне статистике за колоне у којима су бројеви ```podaci.describe()```.

Али можемо погледати и различите вредности које се налазе у појединим колонама, на пример користећи функцију [unique](https://pandas.pydata.org/docs/reference/api/pandas.unique.html) и примењујући је на колону жанр (енг. *genre*) можемо видети који све жанрови нумера постоје у подацима:

podaci.genre.unique()

Појединачним колонама можете приступати на два начина или користећи `podaci.genre` као горе, или користећи `podaci['genre']` оба начина ће произвести приказ података из колоне (пробајте). Први начин за позивање колона има краћи запис и већ писањем `podaci.g` можете притиском на таб подстаћи *jupyter* да вас допуни и понуди различита имена колона и метода који почињу словом `g`, међутим овај начин не ради уколико имате имена колона која у себи садрже празне карактере или неке карактере које `python` не дозвољава у именима променљивих (нпр. ћирилична имена колона, колоне које садрже `/` итд), стога је други начин често сигурнији начин да ћете позвати жељену колону. 

Садржај неких колона је очигледан, нпр. име аутора (енг. *artist_name*), име песме (енг. *track_name*), итд. На пример, горе, у резултатима наредбе `podaci.info()` видимо да је колона време (енг. *relese_date*) типа `int64` тј. целобројно, што значи да је највероватније у питању година издавања нумере (што видимо и у резултатима наредбе `podaci.head()`). Поред ових очигледнијих колона (укључујући и жанр, текст песме и сл.), постоји и прегршт нумеричких колона (типа `float64`) чије нам име, али ни претходно виђених првих пар уноса не говоре пуно - на пример `dating`, `violence`, `romantic`, `communication`. Неразумевање података и њиховог садржаја (чак и када је нагађање могуће) је обично добар повод да се потраже такозвани метаподаци, тј. опис садржаја података које су аутори скупа података или оставили заједно са табелама, или се као у овом случају детаљи могу наћи у раду или неком другом виду документације. Ово је кључан корак да бисмо могли да установимо да ли подаци које имамо могу да нам помогну да нађемо одговоре на питања која истражујемо.

Ако погледамо изворни рад сазнаћемо да су подаци о песмама прикупљени користећи платформу [Spotify](https://www.spotify.com/) и детаљи о појединачним колонама које представљају атрибуте, тј. каратеристике песама можемо наћи у документацији [овде](https://developer.spotify.com/documentation/web-api/reference/#/operations/get-audio-features). Карактеристике песама налазе се у следећим колонама:
- Акустичност (енг. *аcousticness*), говори нам да ли песма садржи музику акустичних или електричних инструмената, што је ова вредност ближа 1 песма је више акустична, док је ближе 0 песма у којој су доминантне електрични инструменти (нпр. електричне гитаре, или генерално електронска музика).
- Погодност за плес (енг. *danceability*, коју ћемо у наставку материјала звати плесозовност), овај атрибут је комбинација музичких елемената попут темпа, ритма и служи да оцени "разиграност" песме - нумере које имају вредност близу 1 су добре за плес.
- Гласност (енг. *loudness*), тј. субјективна јачина звука усредњена током целе песме, вредности су такође нормиране на распон од 0 до 1 (јако гласно).
- Инструменталност (енг. *instrumentalness*) у екстремним вредностима каже нам да ли је песма инструментал (1) или чисто вокална (0).
- Валентност (енг. *valence*) је мера позитивности (1 одговара срећним, еуфоричним емоцијама), тј. негативности (0 одговара тужним или љутим емоцијама) емоција које изазива песма.
- Енергичност (енг. *еnergy*) је мера којом разликујемо  брзе, гласне и бучне песме од оних које су споре, тихе и сл. аутори дају пример метал музике као енергичне, насупрот Баховим "Prelude" које би имале ниску вредност на овој скали.

Хајде да погледамо која песма у скупу података је оцењена као најпогоднија за плес. То можемо урадити тако што прво у једној променљивој сачувамо највећу пронађену вредност у колони `danceability` а затим нађемо ред табеле који у колони `danceability` има ту вредност:

maxdance = max(podaci['danceability']) # funkcija max pronalazi najveću vrednost u koloni danceability tabele 
podaci[podaci['danceability']==maxdance] # prikaz dela tabele za koji je tačno da se u koloni danceability nalazi baš pronađena maksimalna vrednost

Претходно смо објаснили да `podaci['danceability']` излистава садржај колоне, у овом случају колоне `danceability` и стога смо над тим садржајем могли да применимо функцију [`max`](https://docs.python.org/3/library/functions.html) да нађемо највећу вредност овог параметра. Међутим, једна јако згодна особина табела у *pandas* библиотеци је што у угласте заграде, осим имена колоне, можемо ставити и неки услов и на тај начин ћемо добити део табеле за који је тај услов испуњен. То смо испробали у другом реду горњег кода. Наш услов је да вредност колоне `danceability` буде једнака баш вредности коју смо издвојили као максималну и исход тог дела кода је ред табеле у коме можемо прочитати све карактеристике нумере која има максималну плесозовност. Ево и [линка](https://www.youtube.com/watch?v=1hJiQT2pVH0) ка истакнутој песми, преслушајте и реците и ви да ли вас довољно вуче на игру.

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/>Како бисте идентификовали која песма је најмање инструментална? А највише енергична?</div> 

#resenje
#podaci[podaci['instrumentalness']==min(podaci['instrumentalness'])] 
#podaci[podaci['energy']==max(podaci['energy'])] 

Као што сте сигурно приметили слушајући музику до сада, песме се разликују по дужини, по броју и типу вокала (нпр. да ли је у питању песма једне ауторке или хора, да ли је у питњу инструментална нумера...), по постојању инструмената (да ли се у нумери чује гитара, бубањ, саксофон...), да ли је песма брза, гласна и још много других различитих квалитета. Додатно, свака од песама може имати једне квалитете на почетку (нпр. почиње инструменталним уводом), а затим се драстично променити до краја. То значи да бисмо практично сваки од претходно уведених атрибута могли да меримо као неку карактеристику песме из тренутка у тренутак и то значи да би само једна песма могла бити цео један компликован скуп података за себе. За питања која имамо на уму, да бисмо лакше поредили најразличитије нумере, свођење компликованог описа сваке песме (и свих њених музичких параметара који вам могу пасти на ум) на пар претходно излистаних бројева који су сви на истој скали значајно олакшава поређење песама и закључивање о сличностима и разликама међу песмама и жанровима. 

**Иванова илустрација *осакаћених* песама.**

Овакав тип анализе где се компликовани подаци (какве су музичке нумере) своде на групу кључних карактеристика превазилази оквире овог курса, али за више информација можете истражити издвајање карактеристика машинским учењем (енг. *feature extraction*, *feature engineering*).

Уводно упознавање са подацима, завршићемо идентификујући ауторе који имају највише нумера у скупу податка. До тог броја можемо доћи на више различитих начина, овде ћемо се фокусирати на функцију [value_counts](https://pandas.pydata.org/docs/reference/api/pandas.Series.value_counts.html) која пребројава понављања различитих уноса у колони, а коју ћемо применити на колону `artist_name`:

podaci['artist_name'].value_counts() # prebrojavamo sva pojavljivanja različitih unosa u koloni

Видимо да се у скупу података налазе 5426 различита извођача међу којима **johnny cash** има највише нумера. У наредним сегментима видећемо како овакве податке можемо визуелно представити на ефективнији начин осим табелом, али сада ево само једног интересантог запажања, прво двоје од 5426 аутора заслужно је за преко 1% од 28372 нумере, док са друге стране постоји преко 2000 аутора који имају само по једну песму у овом скупу података (како бисте нашли њихов тачан број?). 

Ова необичност заправо је врло честа одлика података и видимо је у расподели богатства, заступљености речи у језику, броју публикација научника, и можда сте чули за ову особину под називом **Паретов парадокс** или **Паретова дистрибуција**, али вратићемо се на то касније у овом темату.

# rešenje pitalice u tekstu
# sum(podaci['artist_name'].value_counts()==1)

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/>Као што смо открили колико који аутор има песама у табели, можемо истражити колико има песама ког жанра, истражите!</div> 

# rešenje zadatka
# podaci['genre'].value_counts()

За наставак истраживања ових музичких података, фокусираћемо се само на изворне колоне које су аутори рада прикупили са **Spotify** платформе (које смо додатно описали претходно), док ћемо елиминисати колоне које су продукт анализа спроведених у раду, али подстичемо заинтересоване читаоце да истраже и њихов садржај.

#nazivi kolona koje ćemo zadržati
kolone = [ 'release_date', 'artist_name','track_name','genre', 'lyrics','acousticness',
           'danceability','instrumentalness','loudness','valence','energy']
novi_podaci = podaci[kolone].copy() # pravimo kopiju tabele koja sadrži samo kolone na koje će se fokusirati ostatak analize
novi_podaci.head() # prikaz prvih pet redova tabele koju ćemo koristiti u nastavku

Коначно, додаћемо и колону која ће године трансформисати и у одговарајуће музичке декаде (попут веселих седамдесетих) пошто ће нам често бити згодно да тако пратимо промене. Нећемо се служити математичком дефиницијом десетице по којој би нпр. осма десетица садржала бројеве од 71 до 80, већ ћемо користити периоде од 10 година који су типичнији за музику, те су седамдесете од 70 до 79 године.

#dodajemo jos jednu kolonu zato sto ce nam biti od koristi da grupisemo podatke u nastavku:
novi_podaci['muzicka_dekada']=pd.cut(novi_podaci.release_date,
                      bins=[1949,1959,1969,1979,1989,1999,2009,2019],
                      labels=['1950s','1960s','1970s','1980s','1990s','2000s','2010s'])

Новонасталу табелу са знатно мањим бројем колона ћемо сачувати за истраживања које ће уследити:

novi_podaci.to_csv('muzika podaci/music_data.csv',# čuvamo novu verziju skupa podataka za dalje korišćenje
            index=False) # ovom opcijom izbegavamo da čuvamo indeksnu kolonu pošto su u njoj trenutno samo redni brojevi koje ćemo svakako dobiti učitavanjem tabele
            ## 2. Да ли је музика младости ваших родитеља другачија од музике ваше младости?

Сигурно сте од својих родитеља (и од њихових родитеља) пуно пута чули да ово што ви данас слушате не може ни да се пореди са Музиком њихове младости. Овакве "осуде" музичког укуса данашњих генерација могу подстаћи више истраживачких питања, нпр. да ли су неки жанрови које су наши родитељи више ценили сада мање заступљени, или су се и сами жанрови променили (чули сте сигурно и нешто попут "то што ти слушаш није рок, зна се шта је рок и то више не постоји" и варијације на тему). Циљ истраживања у наставку је да пробамо да видимо да ли подаци поткрепљују овакве тврдње.

Немамо на располагању омиљене или најпопуларније песме које одговарају баш вашим ближњима којима се ваша музика не допада, али имамо велики број песама издатих у различитим годинама, па можемо истражити да ли су се неке од карактеристика жанрова мењале, да ли је заступљеност различитих жанрова иста кроз време и слично. Да бисмо генерализовали закључке, неопходно је да **узорак** односно скуп песама чије карактеристике имамо на располагању буде **репрезентативан**, односно насумично изабран. О овоме се посебно води рачуна када се на пример спроводе истраживања у којима учествују испитаници и на основу чијих одговора ми желимо да донесемо закључак о понашању целе популације (видите нпр. темат о *Јавном здрављу*). Међутим, када су у питању подаци који су сакупљени за неку другу намену (нпр. у овом случају песме су прикупљене прво на платформи *Spotify* за неке њихове потребе, а затим и прикупљене у истраживачке сврхе), репрезентативност често неће бити гарантована. Шта мислите зашто је то тако?
Један одговор крије се у томе да нису све песме систематично дигитализоване и постале доступне на *Spotify* платформи, сигурно има неких старих или локалних песама за које није било превеликог интересовања глобалних корисника ове платформе па се на њој нису нашле.
То што имамо разлога да сумњамо у репрезентативност ових песама (у односу на неки нашири скуп ***свих песама*** на свету) не значи да наша анализа нема смисла, само је потребно да будемо опрезнији у закључивању. Не би требало да тврдимо да је хип хоп увек онакав какав ми закључимо да је у нашој анализи, већ да тврдимо да је хип хоп који се слуша на *Spotify* платформи такав и такав, и слично.

# učitavanje neophodnih biblioteka:
import pandas as pd # manipulacija tabelarnim podacima
import matplotlib.pyplot as plt # vizualizacija podataka
import numpy as np # manipulacjia nizovima
import seaborn as sns # vizualizacija podataka

podaci = pd.read_csv('muzika podaci/music_data.csv') # učitavanje prethodno pripremljenog skupa podataka i cuvanje u promenljivoj podaci
podaci.tail(2) # podsetnik sta je u podacima koje obradjujemo, ovaj put kroz prikaz poslednja dva reda da se upoznamo i sa ovom alternativom funkciji head

За почетак, хајде да видимо који временски период нам је на располагању, тј. колико далеко у прошлост можемо истраживати карактеристике музичких нумера. Погледајмо прву и последњу годину за које имамо расположиве податке користећи колону `release_date` и функције `min` и `max`:

min(podaci['release_date']),max(podaci['release_date'])

Видимо да у оквиру скупа података постоје песме од 1950. године па до 2019. чиме имамо на располагању 7 деценија да истражимо евентуалне промене. Међутим, сада смо само видели која година је највећа, а која најмања у одговарајућој колони, не знамо да ли за сваку годину имамо довољно података да бисмо изводили адекватне закључке. Да бисмо то проверили, можемо као у претходном одељку избројати колико се пута свака од година појавиљује у одговарајућој колони. Овај пут резултате функције `value_counts` нећемо приказати као табелу већ ћемо их нацртати.

Један природан избор визуализације података овог типа је стубичасти дијаграм. Позиције стубића одговарају годинама у хронолошком редоследу, а висина стубића одговара броју песама у датој години:

# za sada ne obracajte paznju na ovaj kod, samo na grafik, a na kraju sveske se ponovo vratite i na ovaj kod

broj_pesama_po_godinama = podaci['release_date'].value_counts() # broj pesama po godinama, rezultat je sačuvan kao pandas series objekat
broj_pesama_po_godinama = broj_pesama_po_godinama.sort_index() # sortiramo rezultate po godinama od najmanje do najveće
broj_pesama_po_godinama.plot(kind='bar',figsize=(12,3),color='tomato') # koristimo funkciju plot u okviru pandas biblioteke kojoj dodatnim argumentima definišemo specifičnosti, npr. kind definiše tip grafika, ovde stubičasti 
plt.xlabel('Година издавања') #dodajemo ime x osi
plt.ylabel('Број песама') #dodajemo ime y osi
plt.show() #prikaz grafika

Алтернативно исте податке можемо приказати и тачкицама (лево) тако да х координата тачке одговара години за коју је бројимо издате песме у оквиру скупа података, док у координата, тј. висина тачке на дијаграму одговара броју песама. Са десне стране приказани су исти подаци, али тако што су избројане песме издате у периодима од по десет година (од 1950 до 1959, од 1960 до 1969,итд.):

# za sada ne obracajte paznju na ovaj kod, samo na grafik, a na kraju sveske se ponovo vratite i na ovaj kod

plt.figure(figsize=(12,4)) # veličina prostora za crtanje, pošto crtamo dva grafika prostor je širi a sa manjom visinom

plt.subplot(1,2,1)
podaci['release_date'].value_counts().plot(ls='',marker='o',color='tomato') #brojimo pojavljivanje svake od razlicitih godina u okviru kolone a zatim crtamo
plt.ylim(bottom=0) # obezbedjujemo da y osa pocinje od 0 (negativan broj pesama u godini nema smisla)
plt.xlim(right=2021) # obezbedjujemo da x osa sadrzi i trenutnu godinu 
plt.xlabel('Година издавања') #dodajemo ime x osi
plt.ylabel('Број песама') #dodajemo ime y osi

plt.subplot(1,2,2)
plt.hist(podaci['release_date'],bins = [*range(1950,2030,10)],color='tomato',edgecolor='lightgrey') #funkcija hist za nas broji godine u svakom od intervala, zadatim argumentom bins, i rezultat prikazuje visinom stubića na dijagramu
plt.xlabel('Деценија издавања') #dodajemo ime x osi
plt.ylabel('Број песама') #dodajemo ime y osi

plt.show()

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/>Десни график можете добити и на исти начин као и први, ако примените функцију бројања на неку другу колону - покушајте и то!</div> 

**Овај задатак постоји само у свесци за преузимање пошто ће ту бити видљива претходна 2 кода**

# #rešenje
# broj_pesama_po_decenijama = podaci['muzicka_dekada'].value_counts() # broj pesama po godinama, rezultat je sačuvan kao pandas series objekat
# broj_pesama_po_decenijama = broj_pesama_po_decenijama.sort_index() # sortiramo rezultate po godinama od najmanje do najveće
# broj_pesama_po_decenijama.plot(kind='bar',color='tomato') # koristimo funkciju plot u okviru pandas biblioteke kojoj dodatnim argumentima definišemo specifičnosti, npr. kind definiše tip grafika, ovde stubičasti 
# plt.xlabel('Деценија издавања') #dodajemo ime h osi
# plt.ylabel('Број песама')#dodajemo ime u osi
# plt.show() #prikaz grafika

Претходна три графика на различите начине приказују информацију о броју песама које су издате у одређеној години (или декади). Видимо да у скупу података најмање имамо песама из педесетих година прошлог века, док је највише песама из претходне деценије. Осим педесетих из којих имамо значајно мање песама, све остале декаде су слично заступљене, иако је било продуктивнијих и мање продуктивних година (што можемо видети на првом стубичастом дијаграму).

Пораст броја песама са временом је донекле и очекиван и у складу са доступношћу технологије. Међутим, треба имати на уму да график који смо добили не говори о укупном броју песама које постоје из сваке године, већ само о броју тих песама у нашем скупу података. Иако имамо разлога да верујемо да је скуп података насумичан подскуп свих песама доступних на Spotify платформи, треба увек бити опрезан око тумачења резултата насталих на узорку.

Предност стубичастих дијаграма је што се једноставно могу упоредити њихове висине и са већом лакоћом се може утврдити у којој години (деценији) има више песама. Међутим, када број стубића постане превелики (као у случају првог графика у ком има 70 стубића) ова предност престаје, тј. са великом лакоћом можемо упоредити оближње стубиће, али није једнако лако оценити да ли је више песама из 1973 или 1996. Тачкасти дијаграми нам не помажу пуно код претходно поменутог проблема - одабир две тачке и тачно очитавање њихових х и у координата није увек најједноставније, али су ови графици изузетно згодни када покушавамо да уочимо да ли постоји тренд међу подацима. У овом случају доста лакше на тачкастом дијаграму видимо да постоји тренд раста песама кроз време у посматраном периоду од 70 година. Мањи број стубића, као на хистограму десно помаже и да лако уочимо тренд али и да са лакоћом упоредимо заступљеност различитих деценија у подацима, али смо изгубили на детаљности података. Зависно од тога да ли је циљ да искомуницирамо постојање временског тренда, јасније очитавање броја песама за сваку годину или за сваку деценију, једна од ове три визузализације ће бити боља од других, тако да је при избору графика кључно да размислите о поруци коју хоћете да пошаљете.

**Хајде да видимо како цртати овакве графике!**
Истражимо на пример да ли је и број песама одређеног жанра променљив током времена, као што видимо да је укупан број издатих песама. Погледајмо то прво за поп музику. За почетак ћемо у нову променљиву сачувати копију табеле која садржи песме поп жанра  и проверити број уноса у тој табели:

popmuzika = podaci[podaci.genre=='pop'].copy() # selektujemo samo podatke za pesme pop žanra
len(popmuzika) # provera koliko imamo pop pesama u skupu

Видимо да је готово четвртина песама поп жанра. За број песама по годинама, на колону `release_date` ове нове табеле применићемо функцију [value_counts](value_counts) и резултате сачувати у нову променљиву.

pop_tokom_vremena = popmuzika['release_date'].value_counts() # brojimo pesme pop žanra po godinama
type(pop_tokom_vremena)

Резултат бројања појављивања различитих година, сачуван је као серија, што је практично колона података у оквиру `pandas` библиотеке, више можете погледати у документацији [овде](https://pandas.pydata.org/docs/reference/api/pandas.Series.html), а погледајмо прве уносе, типична функција `head()` може се применити и на серију:

pop_tokom_vremena.head()

Садржај ове серије су бројеви песама у свакој години, тако да су дате године искоришћене као индексна колона. Често ћемо желети да користимо и године као *нормалну* колону којом можемо манипулисати, али у овом случају најједноставније графике попут горе нацртаних можемо направити баш чувајући овај формат података. Али хајде прво још да сортирамо ове податке по години користећи `sort_index()`:

pop_tokom_vremena = pop_tokom_vremena.sort_index()
pop_tokom_vremena.head()

Најједноставнији график можемо добити само коришћењем [plot](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html) функције у оквиру `pandas` библиотеке. Подразумевани облик овог графика је линијски график у коме су све вредности (броја песама сваке године) повезани пуном линијом плаве боје:

pop_tokom_vremena.plot()

Већ на овом графику можемо одмах видети да укупан број поп песама прати сличан тренд током година као и укупан број свих песама - најмање песама има у педесетим годинама, а затим број песама брзо порасте и благо варира из године у годину. 

Функција `plot` настала је адаптацијом сродних функција из [matplotlib.pyplot](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.html) библиотеке, тако да можемо користити функције из ове веће библиотеке за цртање да поправимо овај график и допишемо имена оса, променимо боје и слично:

pop_tokom_vremena.plot(marker='o',color='grey') #tačkastim dijagramom prikazujemo dobijene rezultate
plt.ylim(bottom=0) # obezbeđujemo da u osa počinje od 0 (negativan broj pesama u godini nema smisla)
plt.xlabel('Година издавања') #ime х ose
plt.ylabel('Број поп песама') #ime у ose
plt.show()

Сада смо у оквиру функције `plot` искористили пар додатних аргумената: `marker` да додатно истакнемо податке које цртамо и разликујемо њихове позиције од линија које их повезују и `color` којим смо дефинисали боју података (додатно на пример. аргументом `ls=''` стил линије од енг. *line style* можете избацити линију која повезује тачке и тако добити график који личи на други график горе). Функција `plot` има још један врло згодан аргумент којим можете мењати тип графика `kind` којим можете изабрати и стубичасти дијаграм (пробајте `kind='bar'` тако ћете добити нешто што више личи на први график у овој свесци).

# resenje

# plt.figure(figsize=(12,3)) # promenili smo dimenzije slike da bi se sve godine lepo videle
# pop_tokom_vremena.plot(kind='bar',color='grey') #tačkastim dijagramom prikazujemo dobijene rezultate
# plt.ylim(bottom=0) # obezbeđujemo da u osa počinje od 0 (negativan broj pesama u godini nema smisla)
# plt.xlabel('Година издавања') #ime h ose
# plt.ylabel('Број поп песама') #ime u ose
# plt.show()

Додатно смо функцијама библиотеке `matplotlib.pyplot` (чије смо име при учитавању скратили у `plt`) поред података, обезбедили да график има и информације шта је на осама тако што смо исписали имена х и у осе (функције [xlabel](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.xlabel.html) и [ylabel](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.ylabel.html)), обезбедили да у оса почиње од 0 (функција [ylim](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.ylim.html)) и приказали график (функција [show](https://matplotlib.org/api/_as_gen/matplotlib.pyplot.show.html), обратите пажњу на прву верзију графика плаве боје, тамо је поред графика постојао још неки испис, то је зато што нисмо искористили ову функцију да на излазу приказује само графичке елементе без пропратних исписа).

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/>Пробајте да припремите сличан график за друге жанрове и користећи друге вредности аргумената функција (нпр. друге боје, другог типа линије која спаја податке, или користећи стубичасти дијаграм).</div> 

# # resenje

# izabrana_muzika = podaci[podaci.genre=='rock'].copy() # selektujemo samo podatke za pesme žanra po izboru, ovde rok
# izabrana_muz_tokom_vremena = izabrana_muzika['release_date'].value_counts() # brojimo pesme pop žanra po godinama
# izabrana_muz_tokom_vremena = izabrana_muz_tokom_vremena.sort_index() # sortiramo vrednosti po godinama
# izabrana_muz_tokom_vremena.plot(ls='--',marker='o',color='grey') #tačkastim dijagramom prikazujemo dobijene rezultate
# plt.ylim(bottom=0) # obezbeđujemo da u osa počinje od 0 (negativan broj pesama u godini nema smisla)
# plt.xlabel('Година издавања') #ime x ose
# plt.ylabel('Број песама') #ime y ose
# plt.show()

Ако сте покушали да урадите претходни задатак, прошли сте кроз различите ћелије кода изнад и спојили пар редова у један низ у коме сте само мењали име жанра у првом селектовању података из табеле. Када бисмо сада хтели да нацртамо један график за сваки од жанрова, скупило би се бар петнестак линија кода који се махом понавља - осим издвајања подтабеле за жанр, све остале команде би биле исте. Ово је онда прави повод да се уведе функција, да не бисмо изнова и изнова писали код са само једном изменом, спаковаћемо претходне линије кода у једну **[функцију](https://petlja.org/biblioteka/r/lekcije/TxtProgInPythonSrLat/02_console-02_console_15_defining_functions)** и затим њеним позивањем цртати графике за различите жанрове:

def broj_pesama_zanra(odabrani_zanr):
    """
    Za *odabrani_zanr* koji je tipa string, tj ta promenljiva sadrzi ime muzickog zanra, 
    ova funkcija izdvaja podatke samo tog zanra i broji pesme datog zanra u svakoj godini. 
    U prethodnom primeru *odabrani_zanr* je bio pop, a sada pisemo funkciju koja ce raditi 
    za bilo koji od mogucih zanrova.
    
    Rezultat ove funkcije je tackasti grafik izdvojenih podataka na osnovu odabranog_zanra.
    """
    # definisemo recnik u kome su engleski nazivi svih zanrova kljucevi, a cirilicni srpski prevodi vrednosti
    # ovaj recnik ce nam koristiti za legendu
    zanr_cirilicom = {'pop':'поп','country':'кантри','blues':'блуз','jazz':'џез','reggae':'реге','rock':'рок','hip hop':'хип хоп'}

    muzika = podaci[podaci.genre==odabrani_zanr] #selektujemo samo podatke za pesme odabranog žanra
    zanr_u_vremenu = muzika['release_date'].value_counts() # brojimo pesme odabranog žanra po godinama
    zanr_u_vremen = zanr_u_vremenu.sort_index() # sortiramo vrednosti po godinama 
    zanr_u_vremenu.plot(ls='',marker='o',color='grey') #tačkastim dijagramom prikazujemo dobijene rezultate
        
    plt.ylim(bottom=0) # obezbeđujemo da u osa počinje od 0 (negativan broj pesama u godini nema smisla)
    plt.xlabel('Година издавања') #ime x ose
    plt.ylabel('Број песама') #ime y ose
    plt.legend(['Музички жанр је ' + zanr_cirilicom[odabrani_zanr]]) #u legendu unosimo ime žanra
    plt.xlim([1950,2021]) # za svaki žanr, nezavisno da li ima pesme iz celog opsega posmatranih godina fiksiramo istu h osu za lakše poređenje

Сада можете и претходни задатак решити у једном реду користећи написану фунцкију, на пример, ако сте посматрали број рок песама на следећи начин: `broj_pesama_zanra('rock')`. А ово поједностављење са функцијом можемо искористити и да са мало линија кода на једној слици прикажемо 2 жанра, то можемо урадити са функцијом [`subplot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.subplot.html). Функција `subplot` позива се увек са 3 аргумента, први је број редова, други је број колона, док је трећи број редни број графика који цртате, у нашем случају, ако желимо да нацртамо 2 графика један изнад другог радићемо то тако што користимо `plt.subplot(2,1,1)` за горњи график и `plt.subplot(2,1,2)` за доњи, овако:

plt.subplot(2,1,1) # fokusiramo se na crtanje gornjeg od 2 grafikona
broj_pesama_zanra('hip hop') # pozivamo napisanu funkciju za žanr hip hop
plt.subplot(2,1,2) # crtamo donji od 2 grafikona
broj_pesama_zanra('rock') # pozivamo funkciju za žanr rok

Видимо да број различитих песама по годинама није исти за различите жанрове. Док се број песама поп жанра не мења драстично од 1960их до данас, број рок и хип хоп песама је мало променљивији на посматраном периоду. Специфично, најстарија хип хоп песма у скупу је из 1980их (што отприлике одговара и периоду када овај жанр постаје популаран) од када углавном расте. Са друге стране, највећи број песама рок жанра имамо из раних осамдесетих али и пар година 2010их су више заступљене у нашим подацима. *Истражите ове графике и за преостале жанрове!*

# na primer:
# broj_pesama_zanra('jazz')

Али нас заправо више занима да ли су се карактеристике музике мењале кроз време, сетите се, ми желимо да истражимо да ли је наша данашња музика другачија од музике наших родитеља. Наравно, ако ви слушате првенствено хип хоп, ви већ донекле имате свој одговор - овај правац је био тек у својом почецима током младости ваших родитеља, а није ни постојао током времена њихових родитеља. Међутим, ако поред броја песама, ми желимо да видимо какво је стање са карактеристикама песама и жанрова.

<details>    
<summary>
    <font color="darkgreen"><b>Да ли се сећате карактеристика песама које имамо на располагању? А да ли имате претпоставку која од музичких карактеристика се највише мењала кроз време?</b></font>
</summary>
Од карактеристика које анализирамо (акустичност, инструменталност, гласност, разиграност, позитивност, енергичност), неке делују као да се вероватно неће пуно мењати кроз време - нпр. очекивали бисмо да се песме за игру појављују једнако често и данас и пре пар десетина година (анегдотски: чини као да је лето време за нове хитове за играње ;D), али је можда свеприсутност технологије оставила јак печат и у музици па се можда акустичност променила, хајде да то проверимо.

Можемо проверити жељену карактеристику за коју претпостављамо да се мењала (или баш напротив, неку за коју претпостављамо да се није мењала) у оквиру целог скупа података, а и по жанровима. Сетимо се акустичност је број између 0 и 1 који говори о томе да ли у песми доминирају акустични инструменти (вредности ближе 1), или електрични (вредности ближе 0). Хајде да проверимо да ли се акустичност музике свеукупно мењала током посматраног периода (иако очекујемо да су неки жанрови више акустични од других), зато што претпостављамо да је уплив технологије у све сфере нашег живота, па тако и у музику довољно јак да приметимо промене.

Ово можемо урадити тако што у оквиру скупа података групишемо заједно све податке којима имају исту годину издавања (`release_date`) и у оквиру сваке групе израчунамо просечну вредност акустичности (`acousticness`). То радимо користећи функције [`groupby`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html) и [`mean`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html):

akusticnost_prosek = podaci.groupby('release_date').acousticness.mean()
akusticnost_prosek.head()

Променљива `acoustic_mean` сада садржи просечну вредност акустичности за сваку годину, што можете проверити лоцирањем вредности акустичности за годину по избору, користећи [`loc`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html):

akusticnost_prosek.loc[1998]

Као што смо претходно увежбали ове податке можемо згодно и брзо нацртати користећи функцију `plot` библиотеке `pandas`:

akusticnost_prosek.plot(color='tomato') # crtamo podatke linijskim dijagramom kome smo samo odabrali boju
plt.xlabel('Година издавања') # dodajemo naziv x ose
plt.ylabel('Просечна акустичност') # dodajemo naziv y ose
plt.show() # prikazujemo grafik

Видимо да је просечна акустичност била највиша током педесетих година. Након тога, видимо да је просечна вредност акустичности у песмама свих жанрова опадала до осамдесетих година, након чега постоји мали раст, али генерално од тада па до данас, просечна акустичност је доста ниско. Ово наравно не значи да данас не постоји акустична музика, чак не значи ни да су све песме на *Spotify* платформи акустичне, већ да је у просеку песама акустичност ниска, али могу постојати и песме са већом и мањом акустичношћу од просека - тиме ћемо се више бавити у наредним радним свескама.

Уместо да истражујемо само акустичност, можемо издвојити просечне вредности за све музичке атрибуте. Хајде да то урадимо за неке жанрове, тако што ћемо опет издвајати податке за одређени жанр, а затим их груписати по годинама и израчунати просечне вредности по свим расположивим музичким атрибутима:

# u jednu listu skupili smo sve nazive kolona, muzickih atributa, da bismo lakse za sve njih izracunali prosecnu vrednost
muzicki_atributi = ['acousticness', 'danceability', 'instrumentalness', 'loudness','valence', 'energy'] 

pop_muzika = podaci[podaci.genre=='pop'] # izdvajamo pop muziku i cuvamo u novoj promenljivoj
pop_prosek = pop_muzika.groupby('release_date')[muzicki_atributi].mean() # grupisemo pop muziku po godinama i za svaki od muzickih atributa racunamo prosek
jazz_prosek = podaci[podaci.genre=='jazz'].groupby('release_date')[muzicki_atributi].mean() # isto samo za dzez muziku
pop_prosek.head(2) # prikaz prva 2 reda prosecnih vrednosti muzickih atributa za pop muziku

Сада лако можемо поредити ова два жанра по одабраним параметрима, ево на пример промена у акустичности и разиграности у џез и поп музици:

plt.figure(figsize=(10,4)) # definisemo velicinu prostora na kome cemo crtati 10 je sirina, 4 je visina mereno u incama

plt.subplot(1,2,1) # sada crtamo slike u redu, zato 1,2 dok je poslednji broj tu da oznaci da prvo crtamo na levom prostoru
pop_prosek.acousticness.plot(label = 'Поп музика',color='tomato') # crtamo prosecnu akusticnost pop muzike
jazz_prosek.acousticness.plot(label = 'Џез музика',color='grey') # crtamo prosecnu akusticnost dzez muzike
plt.xlabel('Година издавања') # dodajemo naziv x ose
plt.ylabel('Просечна акустичност') # dodajemo naziv y ose
plt.ylim([0,1]) # definisemo raspon y ose od 0 do 1

plt.subplot(1,2,2) # sada crtamo na desnom od dva grafika u jednom redu
pop_prosek.danceability.plot(label = 'Поп музика',color='tomato') # plesozovnost pop muzike
jazz_prosek.danceability.plot(label = 'Џез музика',color='grey') # plesozovnost dzez muzike
plt.xlabel('Година издавања') # dodajemo naziv x ose
plt.ylabel('Просечна плесозовност') # dodajemo naziv y ose
plt.ylim([0,1]) # raspon y ose
plt.legend() # crtamo legendu samo na desnom grafiku posto koristimo iste boje na oba pa nema potrebe ad se ponavljamo

plt.savefig('muzika slike/Dzez_Pop_akusticnost_razigranost.png',dpi=300) # cuvamo sliku
plt.show() # prikazujemo grafik

Овакви упоредни графици нам олакшавају поређење и истовремено закључивање о више варијабли (овде акустичност и разиграност) и више различитих категорија података (овде музичких жанрова поп и џез). На левом графику видимо да акустичност и појединачних музичких жанрова опада током времена на сличан начин као и када смо анализирали све музичке нумере заједно - акустчност је била највиша током педесетих од када опада до осамдесетих и од тада до данас има мање или веће варијације око неке стабилне вредности. Интересантно код овог графика за два жанра је што можемо видети да је просечна вредност акустичности џез музике већа од акустичости поп музике, као и да су варијације од године до године веће у џез музици. Десни график са друге стране говори нам да се просечна вредност плесозовности много мање мењала током посматраног периода (за то је посебно важно што смо оба распона у осе подесили на исте вредности и стога лакше закључујемо који параметар се више мењао). Видимо да постоји благи тренд раста просечне плесозовности, али не постоје уочљиве разлике између жанрова, некад је вредност већа код џеза, а некад код попа.

На овим графицима смо додатно обезбедили да у оба случаја распон бројева на у оси одговара свим могућим вредностима (овде од 0 до 1). Аутоматски је тај распон задат тако да сви подаци буду на графику, али не пуно више од тога, што значи да би цео десни график могао стати  распон од око 0.3 до око 0.7 (видите како изгледа график ако искоментаришете линију `plt.ylim([0,1])`) и такви прикази нам згодно представљју да ли постоје промене, али ако желимо да оценимо колике су те промене у односу на могуће или у односу на промене неког другог параметра (као овде) згодно је обезбедити да су распони на оба графика исти.

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/>Испробајте неку другу комбинацију музичких жанрова и музичких атрибута и представите резултате истим упоредним линијским графиком као што је искоришћен изнад. На пример, можете проверити да ли је и гласност нешто што се мењало, опет као последица технологије.</div> 

# #resenje

# rok_prosek = podaci[podaci.genre=='rock'].groupby('release_date')[muzicki_atributi].mean() # grupisemo pop muziku po godinama i za svaki od muzickih atributa racunamo prosek
# rege_prosek = podaci[podaci.genre=='reggae'].groupby('release_date')[muzicki_atributi].mean() # isto samo za dzez muziku

# plt.figure(figsize=(10,4)) # definisemo velicinu prostora na kome cemo crtati 10 je sirina, 4 je visina mereno u incama

# plt.subplot(1,2,1) # sada crtamo slike u redu, zato 1,2 dok je poslednji broj tu da oznaci da prvo crtamo na levom prostoru
# rok_prosek.loudness.plot(label = 'Рок музика',color='tomato') # crtamo prosecnu akusticnost pop muzike
# rege_prosek.loudness.plot(label = 'Реге музика',color='grey') # crtamo prosecnu akusticnost dzez muzike
# plt.xlabel('Година издавања') # dodajemo naziv x ose
# plt.ylabel('Просечна гласност') # dodajemo naziv y ose
# plt.ylim([0,1]) # definisemo raspon y ose od 0 do 1

# plt.subplot(1,2,2) # sada crtamo na desnom od dva grafika u jednom redu
# rok_prosek.valence.plot(label = 'Рок музика',color='tomato') # plesozovnost pop muzike
# rege_prosek.valence.plot(label = 'Реге музика',color='grey') # plesozovnost dzez muzike
# plt.xlabel('Година издавања') # dodajemo naziv x ose
# plt.ylabel('Просечна позитивост') # dodajemo naziv y ose
# plt.ylim([0,1]) # raspon y ose
# plt.legend() # crtamo legendu samo na desnom grafiku posto koristimo iste boje na oba pa nema potrebe ad se ponavljamo

# plt.show() # prikazujemo grafik

Коначно, показаћемо да припрема података коју смо претходно правили - груписање и рачунање просечне вредности по годинама - може да се уради још једноставније у оквиру функције која ће на крају аутоматску нацртати и резултате. У питању je библиотека функција [seaborn](https://seaborn.pydata.org/) (коју скраћено називамо `sns`) и функцију [lineplot](https://seaborn.pydata.org/generated/seaborn.lineplot.html). Ова функција када наиђе на више података са истом х коордиантом (у нашем случају годином издавања) за које има различите вредности у координате (у нашем случају изабрана музичка карактеристика), за у коориднату црта просечну вредност и без наше претходне припреме, видите на пример овде:

rock_reggae = podaci[(podaci.genre=='reggae')|(podaci.genre=='rock')] # izdvajamo samo dva muzicka zanra zarad lakseg prikaza na grafiku
sns.lineplot(data = rock_reggae, # izbor podataka koje crtamo
             x = 'release_date',y='danceability', # izbor kolona koje se nalaze na x i y osi
             hue='genre', # biramo da linije budu obojene po zanrovima
             palette=sns.color_palette("colorblind")[1:3], # definisemo boje, u ovom slucaju 2. i 3. boju iz palete prikazane u nastavku
             ci=None) # ovim parametrom definisemo da se na grafiku pojave samo izracunate prosecne vrednosti, vise o tome u nastavku
plt.show()

У односу на претходно нацртане графике, овај пут нисмо морали да дефинишемо име х и у осе као ни легенду, то је све преузето на освноу имена колона и података у њима (жанр), али исте претходно коришћене команде (`plt.xlabel`, `plt.ylabel` и сличне) могу бити додате и тако ћемо добити график са ћириличним исписима, пробајте!

У последњој функцији смо уместо бирања боја по имену или хекс коду као на другим местима, искористили смо постојећу палету боја у оквиру `seaborn` библиотеке. Специјално, ово је палета боја у којој је вођено рачуна да и особе које имају потешкоћа са разликовањем боја могу уочити разлике међу њима, видите све боје ове палете овде:

sns.color_palette("colorblind")

У овом другом приступу цртању одабрали смо да упоредимо реге и рок песме и њиохове просечне вредности плесозовности. Видимо да су реге песме током целог посматраног периода оцењене као више плесозовне од рок песама. Ваша индивидуална оцена ових жанрова и њихове плесозовности се може разликовати од ове, али је интересантно да је на великом броју песама и током великог броја година просечна вредност реге песама увек виша од просечне вредности разиграности рок песама. Пре него што придамо овом сазнању додатну важност, у наредним свескама ћемо истражити колико је заправо просек репрезентативан. Проверићемо да ли су песме неког жанра углавном у близини просечне по овом или другим критеријумима, да ли има пуно песама које одступају и да ли можемо разликовати и ауторе а не само жанрове по овим музичким карактеристикама.
## 3. Покретни просек

У овој лекцији циљ нам је да се позабавимо скакутањем вредности из године у годину које смо имали прилике да видимо на графицима у претходној лекцији, ево подсетника на акустичности и плесозовност током времена:

<img src="muzika slike/Dzez_Pop_akusticnost_razigranost.png"
     alt="Markdown Monster icon"
     width='700' />

Као што смо дискутовали претходно, на овим графицима видимо да постоје неки јаснији трендови пада и раста (када се вредности по у оси драматичније мењају), али и доста мањих варијација, поготово међу узастопним годинама (што чини да наше линије имају овај цик-цак облик). 
Поменути цик-цак облик нам је још уочљивији када се користимо визуализацијама које спајају измерене вредности, али га једнако можемо приметити и када ове податке представљамо стубичастим дијаграмима и наш циљ у наставку је да решимо овај *проблем*. Током протекле две године сте имали прилику да често виђате податке који имају тако честе варијације међу узастопним подацима, а онда сте можда видели и једно решење:

<img src="muzika slike/kovid_slika_google.jpg"
     width='400' />
*Извор слике: гугл претрага броја ковид случајева у србији, принтскрин.*

На овим графицима броја ковид случајева, сви смо имали прилике да видимо да се број случајева из дана у дан мења на необичан начин. Постоје периоди драматичног раста (када креће нови талас) и пада (када ситуација креће да се стабилизује и долази до смањења броја нових случајева), али и у оквиру тих периода бројеви из дана у дан су некад већи а некад мањи од претходног дана. Један узрок у овом ковид примеру је на пример различит рад лабораторија које се баве тестирањем узорака, па тако број позитивних варира више као последица дана у недељи и радних навика а не због неких специфичности ширења вируса. Начин на који су те мале дневне варијације решене и на претходном графику је цртање седмодневног просека (то је тамно плава линија, преко дневних вредности забележених светло плавим стубичастим дијаграмом). Ово *усредњавање* нам помаже да се поменуте варијације испеглају и тиме лакше уочавамо трендове раста и пада, односно у овом примеру лакше примећујемо периоде и трајање различитих таласа ковид пандемије.

У наставку ћемо припремити и објаснити функцију која рачуна покретни просек за податке за временски зависне податке које смо гледали у претходној лекцији (нпр. број песама по годинама, просечна акустичност по годинама и тако даље). Ова лекција није неопходна за схватање наредних, али вам може бити од користи уколико се у будућности будете сусретали са графицима попут поменутог са ковид подацима или будете желели да своје податке анализирате уз помоћ покретног просека и тиме лакше уочите временске трендове.

import pandas as pd # učitavanje biblioteke za manipulaciju tabelama i nazivanje je njenom standardnom skraćenicom "pd"
import matplotlib.pyplot as plt # ucitavanje bibliotke za crtanje i nazivanje je njenom standardnom skracenicom "plt"
import seaborn as sns # ucitavanje biblioteke za crtanje

podaci = pd.read_csv('muzika podaci/music_data.csv') # učitavanje prethodno pripremljenog skupa podataka i cuvanje u promenljivoj podaci

Издвојићемо као у претходној лекцији песме једног жанра у посебну табелу, а затим избројати песме тог жанра из године у годину:

popmuzika = podaci[podaci.genre=='pop'].copy() # selektujemo samo podatke za pesme pop žanra
pop_tokom_vremena = popmuzika['release_date'].value_counts() # brojimo pesme pop žanra po godinama
pop_tokom_vremena = pop_tokom_vremena.sort_index()

Овакве податке смо у претходној лекцији цртали као тачкасте, линијске и стубичасте дијаграме, овде ћемо поновити стубичасти дијаграм пре него што му додамо линију покретног просека:

plt.figure(figsize=(12,3)) # dimenzije prostora na kome crtamo, odabrali smo ovaj izduzeni pravougaonik zato sto se stubici tako lakse vide, probajte bez ove komande
plt.bar(pop_tokom_vremena.index,pop_tokom_vremena,color='lightgrey') # stubicasti dijagram sive boje
plt.xlabel('Година') # ime x ose
plt.ylabel('Број поп песама') # ime y ose
plt.show() # prkaz grafika

Главна идеја иза покретног просека је да уместо вредности које имате из године у годину (или у примеру са ковидом из дана у дан) приказујете вредности које су просек последњих пар вредности (у примеру са ковидом последњих 7 дана). Да бисмо припремили те податке, направићемо 2 листе, једну у којој ћемо чувати временске одреднице, а једну у којој ћемо чувати нове просечне податке. 

Ако хоћемо да приказујемо средње вредности последњих на пример 5 година, не можемо ту вредност израчунати за прве 4 године, зато ће листа година у којима ћемо срачунати просек претходних 5, почињати од пете године, овако правимо ту листу:

vremenski_interval = 5 # interval tokom koga racunamo prosek
prva_godina = min(pop_tokom_vremena.index)+vremenski_interval-1 # prva godina za koju mozemo da sracunamo petogodisnji prosek, mora biti bar 5 godina veca od prve godine koju imamo u podaciam
poslednja_godina = max(pop_tokom_vremena.index) # poslednja godina je najveca vrednost podataka o godinama u podacima
vreme = [t for t in range(prva_godina,poslednja_godina+1)] # lista godina pocev od prve godine do poslednje godine koje smo identifikovali kao bitne
#vreme = [*range(prva_godina,poslednja_godina+1)] # i ovo radi isto sto i prethodno, ostavljam kao ideju za skracivanje koda
print(vreme[:5])# prikaz prvih pet godina za proveru

У претходном блоку кода, једна новина крије се у овој линији `vreme = [t for t in range(prva_godina,poslednja_godina+1)]`. Прочитаћемо значење ове линије: ова листа (зато што су употребљене угласте заграде) садржи `t` за свако `t` које је у опсегу (`range`) између прве и последње године које смо идентификовали као битне. Ово је једна јако пајтон специфична команда, уместо да направите `for` петљу и попуњавате листу на традиционалан начин:
```
vreme = [] # prazna lista
for t in range(prva_godina,poslednja_godina+1): # za svako t u definisanom opsegu 
    vreme.append(t) # dodaj t u listu
```
док смо овде одмах попунили листу на тај начин, више о погодностима листа можете прочитати у [документацији](https://docs.python.org/3/tutorial/datastructures.html) или кроз овај [курс на петљи](https://petlja.org/biblioteka/r/lekcije/TxtProgInPythonSrLat/02_console-toctree) где се можете подсетити и петљи, опсега и сличних пајтон специфичности.

Са петљом у наставку проћи ћемо кроз све године из листе `vreme` и за сваку годину ћемо срачунати просечан број поп песама издатих у претходних пар година (контролисано променљивом `vremenski_interval` чија је вредност сада 5, али ако хоћемо да променимо број година на којима рачунамо просек можемо то променити):

proseci = [] # prazna lista u koju cemo dodavati proseke
for god in vreme: # za svaku godinu u okviru pripremljene liste vreme
    # kroz promenljivu uslov definisemo za koje godine hocemo da usrednjimo podatke - sve godine u poslednjem vremenskom intervalu 
    uslov = (pop_tokom_vremena.index>god-vremenski_interval)&(pop_tokom_vremena.index<=god)
    # izdvajamo podatke koji odgovaraju uslovu i cuvamo ih u promenljivoj prosek:
    podskup = pop_tokom_vremena[uslov]
    # listu proseka dodajemo prosecnu vrednost podskupa podataka
    proseci.append(podskup.mean())
print(proseci[:5])

Листа `proseci` сада садржи просечне бројеве поп песама претходних 5 година, и можемо је као линију доцртати на претходно цртани стубичасти дијаграм:

plt.figure(figsize=(12,3)) # dimenzije prostora na kome crtamo, odabrali smo ovaj izduzeni pravougaonik zato sto se stubici tako lakse vide, probajte bez ove komande
plt.bar(pop_tokom_vremena.index,pop_tokom_vremena,color='lightgrey') # stubicasti dijagram sive boje
plt.plot(vreme,proseci,color='darkred',marker='o') # novoizdacunati pokretni prosek crtamo u tamno crvenoj boji
plt.xlabel('Година') # ime x ose
plt.ylabel('Број поп песама') # ime y ose
plt.show() # prkaz grafika

Тачкицама дуж линије истакли смо израчунате вредности да бисмо лако могли за сваку годину да упоредимо просек претходних пет година (тамно црвени кружић) и број песама издатих те године (висина стубића).

Очекивано, петогодишњи просек не можемо срачунати првих 4 година, стога линија померајућег просека на графику креће касније, тј. први пут када је могуће израчунати просек првих 5 година. Видимо да је крива са петогодишњим просецима глаткија, тачније скоковите промене које јасно примећујемо на стубичастом дијаграму су поравнате. 

Обратите пажњу на почетак тамно црвене линије, деценија раста броја песама (од половине педесетих до половине шездесетих година прошлог века) је сада једна глатка увек растућа линија. Примећујемо у овом делу да су вредности на тамно црвеној линији увек ниже од висина стубића, то је последица усредњавања са претходне 4 вредности - када постоји пораст у вредности, тај пораст се на овако усредњеној линији мање види. Баш та особина нам помаже да се неке краткотрајне промене (скокови и падови) ублаже, да би се јасније видели само неки трендови који се понављају дужи низ година (као на пример и раст крајем седамдесетих година, или пад крајем деведесетих). Обратите пажњу на пример и на године непосредно пре седамдесетих када судећи по стубичастом дијаграму постоји скок у годишњој продукцији поп песама, али усредњена линија га не види зато сто се тај раст није понављао у наредним годинама. Слично је и са падовима, нпр. 1990. године иако су вредносно и поменути раст и пад, промене од по двадесетак песама и  упоредиви са растом који се бележи крајем педесетих, чињеница да се промене нису понављале учиниле се да се ова одступања заравне и да можемо лако да сагледамо само дугорочније трендове.

Додатна последица вишегодишњег усредњавања је и кашњење у постигнутим вредностима - видите нпр. годину у којој стубичасти дијаграм први пут достигне вредности блиске 100, и када тамно црвена линија достигне исто. 

Покретни просек (на енг. moving average, rolling average) се често користи да се одстране брзе промене у подацима и да се лакше сагледа нека доминантија, односно дужа правилност. Поред ковид примера са почетка, типични примери коришћења покретног просека су у финансијама када се посматрају промене у ценама током времена.

Сада ћемо рачунање покретног просека применити и на податке о музичким карактеристикама. Урадићемо то у оквиру функције коју после лако можемо примењивати на различите жанрове и музичке карактеристике. Резултат функције може бити листа просечних вредности које ћемо накнадно нацртати (као горе), али смо се ми одлучили да функција одмах и црта израчунато.

podaci.columns

def grafik_pokretnog_proseka(podaci, zanr, muz_karakteristika, vremenski_interval, boja):
    """
    Ova funkcija za odabrani zanr i muzicku karakteristiku crta grafik promene karakteristike kroz vreme
    ali se usrednjavanje ne vrsi na godisnjem vec na visegodisnjem nivou (definisano parametrom vremenski_interval).
    
    podaci - skup podataka koji sadrzi pesme razlicitih zanrova i za svaku ima vrednosti muzickih karakteristika (akusticnost, glasnost,itd.)
    zanr - string koji oznacava muzicki zanr koji hocemo da selektujemo - moze biti 'pop', 'rock' itd
    muz_karakteristika - string koji oznacava karakteristiku koju usrednjavamo i crtamo, mora da odgovara imenu kolone u tabeli podaci(moze biti 'acousticness', 'danceability'...)
    vremenski_interval je broj godina (int), za 1 radi isto sto i groupby('release_date').mean(), za 10 crta desetogodisnji prosek
    boja - string sa imenom boje (npr.'grey') ili heks kodom ('#000000') kojom crtamo liniju izracunatog proseka
    """

    zanr_cirilicom = {'pop':'поп','country':'кантри','blues':'блуз','jazz':'џез','reggae':'реге','rock':'рок','hip hop':'хип хоп'}
    muz_cirilicom = {'acousticness':'Акустичност','instrumentalness':'Инструменталност',
                     'danceability':'Плесозовност','loudness':'Гласност','valence':'Позитивност',
                     'energy':'Енергичност'}
    
    podaci_podskup = podaci[podaci.genre==zanr][['release_date',muz_karakteristika]] # deo skupa podataka koji odgovoara odabranom zanru i muzickoj karakteristici
    
    prva_godina = min(podaci_podskup.release_date)+vremenski_interval-1 # prva godina za koju mozemo da sracunamo petogodisnji prosek, mora biti bar 5 godina veca od prve godine koju imamo u podaciam
    poslednja_godina = max(podaci_podskup.release_date) # poslednja godina je najveca vrednost podataka o godinama u podacima

    vreme = [t for t in range(prva_godina,poslednja_godina+1)] # lista godina od min za koju cemo sracunati prosek do maksimalne za zanr koji posmatramo
    prosek = [] # lista u kojoj cemo sacuvati prosecne podatke u toku odabranog vremenskog intervala
    for t in vreme: # za svaku godinu iz liste
        uslov = ((podaci_podskup.release_date)>=t-vremenski_interval)&((podaci_podskup.release_date)<t)
        podskup_t = podaci_podskup[uslov][muz_karakteristika] # izdvajamo deo podataka koji odgovara prethodnim godinama u okviru posmatranog prozora
        prosek.append(podskup_t.mean()) # racunamo prosek i dodajemo u listu
    plt.plot(vreme, prosek,color=boja,label=zanr_cirilicom[zanr]+', '+str(vremenski_interval)+'-годишњи просек') # crtamo grafik
    plt.xlabel('Година')
    plt.ylabel(muz_cirilicom[muz_karakteristika].capitalize())
    #return time,mean_feature # alternativno, ova funkcija bi mogla da vraca sracunate vrednosti a da na drugom mestu crtamo grafik

Можемо да испробамо рад функције на поп музици и њеној акустичности коју смо претходно анализирали:

grafik_pokretnog_proseka(podaci,'pop','acousticness',1,'grey') # isprobavamo kreiranu funkciju za pop zanr i akusticnost, koristeci jednogodisnje usrednjavanje
#grafik_pokretnog_proseka(podaci,'pop','acousticness',5,'grey')
grafik_pokretnog_proseka(podaci,'pop','acousticness',10,'darkred') # desetogodisnje usrednjavanje
plt.legend()
plt.show()

Да тестирамо креирану функцију, овде смо је испробали са претходно цртаним поп жанром и акустичношћу (видите прву слику ове лекције). Нацртали смо једногодишњи просек (који смо у претходној лекцији цртали уз помоћ `groupby` функције а који је сада специјални случај нове функције за вредност временског интервала од једне године) сивом бојом, и за поређење десетогодишњи просек тамном црвеном бојом. Као и у случају броја поп песама, видимо да је и покретни просек акустичности поп песама глаткија линија на којој лакше можемо да видимо да је до осамдесетих година акустичност била у паду, након чега је прилично стабилна, односно електроника доминира поп музиком од тада.

Сада, када имамо функцију којом једноставно цртамо глатку линију промена музичког атрибута кроз време, хајде да пробамо да на једном графику сагледамо све жанрове које имамо у скупу података и упоредимо их по вредности енергичности.

plt.figure(figsize=(8,5)) # definišemo prostor za crtanje, malo veći nego inače da bismo lakše pročitali legendu grafika
i=0 # brojač koji nam pomaže da iteriramo kroz paletu boja
for genre in podaci.genre.unique(): # za sve žanrove u listi jedinstvenih žanrova u našem skupu podataka
    grafik_pokretnog_proseka(podaci, genre,'energy',10, # pozivamo našu funkciju za crtanje usrednjene vrednosti energičnosti pesama po žanrovima za prozor od 10 godina
                 sns.color_palette("colorblind")[i]) # za parametar boje koristimo listu boja palete sa kojom imamo najveće šanse da čitaoci razlikuju boje linija
    i+=1 # uvećavamo brojač da iskoristimo sledeću boju za sledeći žanr

plt.legend() # legenda na grafiku

plt.show()

Примећујемо да је енергичност песама сада већа од енергичности песама током шездесетих и седамдесетих, без обзира на жанр. Видимо такође да је енергичност неких жанрова увек већа од других (упоредите на пример џез и блуз). Покретни просек нам је помогао да видимо на једном месту све жанрове и да тако лакше сагледамо да је код неких жанрова током деведесетих дошло до пада у енергичности, али је након тога у свим жанровима енергичност у порасту. Видите у наставку на пример график који можете добити користећи `sns.lineplot` функцију без покретног просека: 

plt.figure(figsize=(8,5)) # definišemo prostor za crtanje, malo veći nego inače da bismo lakše pročitali legendu grafika
sns.lineplot(data = podaci, # izbor podataka koje crtamo
             x = 'release_date',y='energy', # izbor kolona koje se nalaze na x i y osi
             hue='genre', # biramo da linije budu obojene po zanrovima
             palette="colorblind", # definisemo paletu boja za koriscenje, kao u prethodnoj svesci 
             ci=None) # ovim parametrom definisemo da se na grafiku pojave samo izracunate prosecne vrednosti, vise o tome u nastavku
plt.ylabel('Енергичност') # ime u ose, h smo definisali u funkciji
plt.xlabel('Година') # ime u ose, h smo definisali u funkciji
plt.legend() # legenda na grafiku

plt.show()

Без пкретног пресека сви жанрови имају цик цак линије и јако је тешко испратити шта се дешава у највећем делу података које анализирамо - видимо да је рок осамдесетих најенергичнији, али не можемо тако лако наћи где је рок пре тога, слично је и са осталим жанровима. Интересантно је такође да се у графику са покретним просеком не види да је енергичност рок музике и на самом почетку била јако висока, хајде да видимо о чему се ради:

rok_podaci = podaci[(podaci.genre=='rock')] # izdvajamo rok podatke i cuvamo ih u posebnu promenljivu
min_god = min(rok_podaci.release_date) # izdvajamo prvu godinu za koju imamo rok pesme
rok_podaci[rok_podaci.release_date==min_god] # prikazujemo pesme koje su izdate u prvoj godini koju imamo u podacima

Обабезно послушајте ове песме ([овде](https://www.youtube.com/watch?v=7BLU0pUYWMU) и [овде](https://www.youtube.com/watch?v=4Q7jPi0gZEU)) и сами се уверите да ли су оцене о њиховим музичким карактеристикама онакве каквим их параметри приказују.

Али и поред индивидуалне оцене, оно што можемо да приметимо је да за 1955. годину постоје само 2 рок песме истог аутора, са врло високом вредношћу параметра енергичности, што је и информација коју смо приметили на цик-цак дијаграму без покретног пресека. Хајде да видимо како се број рок песама до краја педесетих мењао:

rok_podaci[(rok_podaci.muzicka_dekada=='1950s')].release_date.value_counts()

Видимо да је свих осталих година било више од 2 песме, стога када смо кренули да примењујемо пкретни пресек, ове две изузетно енергичне песме су изгубиле на значају и њихово одступање више није видљиво на графику који приказује петогодишње просеке. Ово је још једна предност покретног пресека - специфичне године са мало података који одступају не могу тако драстично променити изглед графикона.

Вратимо се сада графикону покретног просека енергичности за различите жанрове. Иако смо видели пуно интересантних информација на овом графику, он и даље није претерано привлачан за посматрање ни лак за комуникацију кључних порука зато што има пуно линија и пуно боја. Боја је користан алат за издвајање различитих категорија података, али постоји лимит на лако разазнавање и праћење броја, са 7 жанрова и толико боја отежавамо читаоцу схватање порука. Када се на линијском дијаграму види прегршт линија различитих боја, то се популарно заове и шпагети дијаграм, енг. *spagetti plot*, потражите те лоше примере да видите зашто нам је поребно да их превазилазимо, иако 7 шарених линија још увек није пуно страшно.

Један начин да превазиђемо овај проблем је поређење мањег броја жанрова као што смо радили на првом приказаном графику у овој лекцији. Други начин је појединачан график за сваку од линија, као што смо посматрали број песама за сваки жанр. Међутим, пажљива употреба боја може бити још једно решење:

plt.figure(figsize=(8,5))
i=0
for genre in podaci.genre.unique():
    if genre == 'rock':
        grafik_pokretnog_proseka(podaci,genre,'energy',10,'darkred')
    else:
        grafik_pokretnog_proseka(podaci,genre,'energy',10,sns.color_palette('Greys')[i])
        i+=1
plt.legend()
plt.show()

Нијансе сиве уз једну линију коју желите да истакнете често могу бити далеко ефектније решење од коришћења десет различитих боја. Овде на пример смо усмерили пажњу читалаца на тамно црвену боју која представља енергичност рок жанра, док остале линије служе да искомуницирају контекст, овде на пример, да је енергичност свих других жанрова мања и не бавимо се превише тиме колико и у ком периоду.

Видели смо како да израчунамо покретни просек и како нам то помаже да на истом графику сагледамо више жанрова и промена које су се у њима дешавале током година што нам је било тешко да сагледамо на цик-цак графицима које смо претходно добијали. Приметили смо да је енергичност у порасту за већину жанрова, а остављамо вама да истражите плесозовност и гласност (да ли очекујете да неки жанр буде више гласан, а више за плес?). Иако смо уз помоћ просечних вредности сада лако могли да уочимо неке промене које су се дешавале током периода који посматрамо, ми смо сводили цео један жанр са пуно различитих извођача и песама на једну вредност - просечну. Питање којим ћемо се позабавити у наредној лекцији тиче се управо ове теме, да ли просек садржи довољно информација, тј. да ли је пуно песама једног жанра слично просечним вредностима или не?

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/>Истражити како се плесозовност и гласност мењала по жанровима кроз време. Анализирајте промене на графицима које можете добити примењујући функцију `sns.lineplot()` и функцију `grafik_pokretnog_proseka`.</div> 

# # resenje

# plt.figure(figsize=(8,5))
# i=0
# for genre in podaci.genre.unique():
#     if genre == 'pop':
#         grafik_pokretnog_proseka(podaci,genre,'danceability',10,'darkred')
#     else:
#         grafik_pokretnog_proseka(podaci,genre,'danceability',10,sns.color_palette('Greys')[i])
#         i+=1
        
# plt.ylim([0,1])
# plt.legend()
# plt.show()

# # resenje

# plt.figure(figsize=(8,5))
# i=0
# for genre in podaci.genre.unique():
#     if genre == 'country':
#         grafik_pokretnog_proseka(podaci,genre,'loudness',10,'darkred')
#     else:
#         grafik_pokretnog_proseka(podaci,genre,'loudness',10,sns.color_palette('Greys')[i])
#         i+=1
        
    
# plt.legend()
# plt.show()
## 4. Да ли је просек довољан?

До сада смо линијама представљали просечне вредности (аритметичке средине, добијене коришћењем функције `mean`), међутим, поставља се питање да ли је та просечна вредност добар репрезент нумера тог жанра или тог периода? Да ли је већина песама има карактеристике сличне просечној вредности или је просечна вредност само то - нека израчуната вредност која не мора нужно бити добар репрезент?

Да бисмо то проверили, у наставку ћемо користити **хистограме** да испитамо колико песама има разне могуће вредности музичких карактеристика, од плесозовности до енергичности, за различите временске периоде и жанрове. Почећемо као и обично учитавањем неопходних библиотека и скупа података који анализирамо:

# učitavanje neophodnih biblioteka:
import pandas as pd # manipulacija tabelarnim podacima
import matplotlib.pyplot as plt # vizualizacija podataka
import numpy as np # manipulacjia nizovima
import seaborn as sns # vizualizacija podataka

podaci = pd.read_csv('muzika podaci/music_data.csv') # učitavanje prethodno pripremljenog skupa podataka

Нацртаћемо за почетак хистограм плесозовности поп песама 2010их година, тако да почињемо издвајањемо ових песама из табеле:

segment_podataka = podaci[(podaci.genre=='pop')&(podaci.muzicka_dekada=='2010s')] #selektujemo pop pesme 2010ih

За цртање ћемо искористити функцију [hist](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.hist.html) библиотеке `matplotlib.pyplot`, у свом основном облику, она не захтева ништа више од података, ми прослеђујемо колону плесозовности `danceability`:

plt.hist(segment_podataka.danceability)

Добили смо график, хистограм, који личи на стубичасти дијаграм. И сада видимо стубиће различите висине и они нам говоре о заступљености песама одређене карактеристике. Међутим, код стубичастих дијаграма на х оси, тј. сваком стубићу одговарала је тачно једна категорија (на пример, стубић је одговарао свим песмама издатим у једној години), док овде, код хистограма, стубић одговара интервалу вредности - висином стубића представљен је броју песама чија је вредност плесозовности у неком интервалу а сам интервал обележен је ширином стубића на х оси. Додатно, код стубичастих дијаграма (које цртамо на пример `bar` функцијом) пре цртања дијаграма ми пребројимо податке и функцији прослеђујемо листу висина стубића, док `hist` функција врши и бројање и цртање (те можете ако желите да сачувате и резултате бројања у нову променљиву ако хоћете нешто даље да радите са тим бројевима - део тих бројева видите горе изнад графика).

Нацртајмо поново овај хистограм, али користећи још опција да график постане информативнији:

plt.hist(segment_podataka.danceability, # podaci nad kojima primenjujemo funkciju hist
         bins=[0,0.25,0.5,0.75,1], # pozicije intervala u kojima prebrojavamo pesme, ovde date kao lista od 5 elemenata koje su granice 4 intervala
         alpha=0.3, # transparentnost
         color='salmon',
         edgecolor='salmon') # boja ivica stubica
meanval = np.mean(segment_podataka.danceability) # prosecna vrednost podataka nacrtanih histogramom
plt.axvline(x=meanval,color='salmon') # dodajemo prosecnu vrednost kao uspravnu liniju sa x koordinatom koja odgovara prosecnoj vrednosti
plt.xlabel('Плесозовност')
plt.ylabel('Број песама')
plt.show()

На овом хистограму смо променили боје (аргументима функције `color` за боју стубића, `edgecolor` за боју ивица и `alpha` за прозирност) и имена на осама које смо користили и раније. Међутим, променио се и број стубића чиме видимо да се по облику овај и претходни дијаграм разликују, иако смо цртали исте податке. То је зато што основна верзија функције коју смо прво искористили врши пребројавање песама тако што могући опсег података (од минималне до максималне вредности) подели у 10 једнаких интервала и затим преброји колико песама је у ком од интервала (на пример, колико је песама са плесозовношћу од 0 до 0.1, затим од 0.1 до 0.2 и тако даље). Зависно од тога у колико интервала делимо простор могућих вредности, дијаграм ће изгледати више или мање детаљно и то контролишемо аргументом `bins`. Oвај аргумент варирамо или тако што му додељујемо број интервала (нпр. `bins=20` чиме се подаци деле у 20 једнаких интервала од најмање до највеће вредности у подацима) или тако што дефинишемо границе интервала (нпр. `bins=[0,0.25,0.5,0.75,1]` ће бројати песме у четири интервала од 0 до 0.25, од 0.25 до 0.5, од 0.5 до 0.75 и од 0.75 до 1). 

Када хоћемо да задамо неки број интервала од одабране најмање до највеће вредности, за то можемо користити функцију `linspace` библиотеке `numpy`:

np.linspace(0,1,11) # za na primer granice 10 intervala od 0 do 1 pozivamo linspace funkciju zajtevajuci 11 brojeva od 0 do 1

Следећи код служи да креира интерактивни приказ хистограма на коме можете уз помоћ клизача мењати број интервала за хистограм, а из падајућег менија можете одабрати музичку карактеристику чији хистограм желите да прикажете, не обазирите се пуно на код већ се играјте са вредностима и испитајте колико се разликују хистограми за различити број интервала, а затим и колико су другачији хистограми другачијих музичких карактеристика попут инструменталности, акустичности, гласности и других.

# ovaj kod sluzi da kreira interaktivnu verziju histograma na kojoj mozete menjati muzicku karakteristiku i broj intervala

from ipywidgets import interactive # ukljucivanje interaktivnog modula


def plot_hist(broj_intervala,muzicka_karakteristika,zanr, muzicka_dekada): # funkcija kojom crtamo histogram za zadate parametre
    data_segment = podaci[(podaci.genre==zanr)&(podaci.muzicka_dekada==muzicka_dekada)] #selektujemo pop pesme 2010ih
    plt.hist(data_segment[muzicka_karakteristika], # podaci nad kojima primenjujemo funkciju hist
             bins=np.linspace(0,1,broj_intervala+1), # pozicije intervala u kojima prebrojavamo pesme, ovde date kao 20 intervala jednake duzine
             alpha=0.5) # transparentnost
    meanval = np.mean(data_segment[muzicka_karakteristika]) # prosecna vrednost podataka nacrtanih histogramom
    plt.axvline(x=meanval)
    stdval = np.std(data_segment[muzicka_karakteristika]) # standardna devijacija 
    plt.axvline(x=meanval+stdval,ls='--') # uspravna linija na datoj x poziciji
    plt.axvline(x=meanval-stdval,ls='--')    
    muz_cirilicom = {'acousticness':'Акустичност','instrumentalness':'Инструменталност',
                 'danceability':'Плесозовност','loudness':'Гласност','valence':'Позитивност',
                 'energy':'Енергичност'}
    
    plt.xlabel(muz_cirilicom[muzicka_karakteristika])
    plt.ylabel('Број песама')
    plt.show()


interactive_plot = interactive(plot_hist, broj_intervala=(2,40,2),muzicka_karakteristika = ['danceability','energy','valence','loudness','acousticness','instrumentalness'],zanr='pop',muzicka_dekada='2010s')
output = interactive_plot.children[-1]
output.layout.height = '350px'
interactive_plot

Поред броја песама у сваком од интервала плесозовности, тј. хистограма, претходни графици садрже и додатну усправну линију која означава просечну вредност коју смо до сада користили (пуна усправна линија). 

Са малим бројем сегмената добијемо неку грубу структуру, нпр да је више песама код којих је плесозовност између 0.5 и 0.75 (ако користите само 4 интервала), док са повећањем добијате све детаљније информације. Израчуната просечна вредност наравно не зависи од овог избора и она се стално налази на истом месту, али са финијом структуом (више интервала) боље можете уочити број песама који се налази у истом интервалу или у непосредној околини просечне вредности.

Ако на претходном графику задржите неки број интервала са чијим нивоом детаљности сте задовољни и промените музичку карактеристику која се приказује на графику можете видети и пар других примера података представљеним хистограмима и њихових просечних вредности.

<details>    
<summary>
    <font color="darkgreen"><b>Шта је све другачије на хистограму акустичности или гласности у односу на претходно разматрану плесозовност?</b></font>
</summary>
Хистограм није више симетрична слика (у односу на вертикалу). Ако погледамо гласност, та асиметрија је блажа, док је у случају акустичности то драстичније. Ширина дијаграма се мења - у случају гласности готово да не постоје вредности испод 0.4 а и генерално су сконцентираније око просечне вредности, док у случају акустичности постоје песме са свим могућим вредностима акустичности иако су неке далеко популарније од других.
Коначно, просечна вредност у случају акустичности није више тако близу вредности која је и најпопуларнија у подацима.


Математички појам који описује оно што приказујемо хистограмима зове се **расподела** или **дистрибуција** и као што име каже, говори нам о томе како су подаци расподељени у простору могућих вредности. Наш циљ у анализи података је често да сазнамо што је више могуће о расподели података, али зависно од тога колико нам је података доступно наше сазнање је ограничено. То нам делимично илуструје разлика у томе како нам се чини да расподела изгледа зависно од тога колико детаљне бинове бирамо у хистограму - ако их одаберемо премало сазнајемо јако мало о томе како су подаци расподељени, док превише интервала производи график који је можда превише скоковит што такође вероватно не одговара реалности већ пре може бити последица неких насумичности у подацима. Када сакупљамо податке или мерењима или испитивањем кроз анкете, ови интервали су често дефинисани за нас коришћеним мерним инструментом. У случају мерења физичких величина, најмањи могући интервал дефинисан је прецизношћу коришћеног мерног инструмента, нпр. када меримо температуру термометром коме је најмањи могући подеок 1 степен целзијуса, ми не можемо имати интервале који имају мању ширину од тог једног степена. Слично, често када анкетама питамо људе о њиховим платама, не питамо их да нам дају тачан износ у динар (када би ширина најмањег могућег интервала била 1 динар) већ им обично понудимо интервале вредности, тако да већ прикупљањем одговора на анкету ми радимо на припреми хистограма.

Најчешће немамо довољно података да сазнамо детаљан облик расподеле, али имамо начине да квантификујемо неке од особина које смо препознали као различите поредећи хистограме других података. На пример, за ширину расподеле најчешће користимо **стандардну девијацију**. Расподеле са већом стандардном девијацијом су шире од оних које имају мању стандардну девијацију, испрекиданим усправним линијама на претходним графицима смо обележили вредност која је једну стандардну девијацију већа и мања од просечне вредности, те можете оценити колико података се у различитим случајевима налази у овом опсегу. Више о дистрибуцијама, просечним вредностима и стандардној девијацији прочитајте у речнику статистичких појмова на крају овог курса.

За симетричне расподеле за које можемо очекивати да су довољно близу **нормалној расподели** очекујемо да се око 2/3 података налази у околини просечне вредности, можемо проверити како стоје ствари код наших података за различите карактеристике музике:

meanval = np.mean(segment_podataka.danceability) # prosecna vrednost podataka nacrtanih histogramom
stdval = np.std(segment_podataka.danceability) # standardna devijacija 
uslov = (segment_podataka.danceability<=meanval+stdval)&(segment_podataka.danceability>=meanval-stdval)# ovim uslovom biramo podatke koji su manje od jedne standardne devijacije daleko od prosecne vrednosti
round(100*len(segment_podataka[uslov])/len(segment_podataka),2) # racunamo procenat podataka koji se nalaze najvise jednu standardnu devijaciju daleko od prosecne vrednosti

Видимо да се преко 67% поп песама 2010их налазе у околини просечне песме на највећој удаљености од једне стандардне девијације. 
<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/> Испитајте на исти начин како се овај проценат мења за акустичност или гласност. На основу претходних графикона, да ли већ имате нека очекивања да ли ће воај број бити већи или мањи?</div> 

# #resenje

# meanval = np.mean(segment_podataka.loudness) # prosecna vrednost podataka nacrtanih histogramom
# stdval = np.std(segment_podataka.loudness) # standardna devijacija 
# uslov = (segment_podataka.loudness<=meanval+stdval)&(segment_podataka.loudness>=meanval-stdval)# ovim uslovom biramo podatke koji su manje od jedne standardne devijacije daleko od prosecne vrednosti
# round(100*len(segment_podataka[uslov])/len(segment_podataka),2) # racunamo procenat podataka koji se nalaze najvise jednu standardnu devijaciju daleko od prosecne vrednosti

Користећи `seaborn` библиотеку можемо лако видети расподеле по одабраној колони за више различитих жанрова или више различитих декада користећи [FacetGrid](https://seaborn.pydata.org/generated/seaborn.FacetGrid.html) функцију, ево примера како се расподела плесозовности у последњој деценији разликује по жанровима:

g = sns.FacetGrid(podaci[podaci.muzicka_dekada=='2010s'], col="genre")
g.map_dataframe(sns.histplot, x="danceability",bins=np.linspace(0,1,21))
plt.show()

Овако лако и са мало линија кода (мада јесмо оставили основне боје и нисмо исправљали имена на осама), можемо видети како се плесозовност разликује по жанровима. У неким жанровима расподела је ужа (нпр. кантри), а негде је шира (нпр. џез), што можемо проверити и ако израчунамо стандардне девијације ових расподела:

muzika2010ih = podaci[podaci.muzicka_dekada=='2010s'] # izdavajamo muziku 2010ih
muzika2010ih.groupby('genre').danceability.std() # grupisemo muziku 2010ih po zanrovima i na koloni danceability racunamo standardnu devijaciju

Видимо да су израчунате вредности стандардних девијација су у складу са нашом визуелном оценом, џез дистрибуција као најшира има и највећу вредност стандардне девијације.

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/> Нацртајте хистограме гласности музике по жанровима (за музичку декаду по избору) и израчунајте стандардне девијације тих дистрибуција.</div> 

# #resenje
# g = sns.FacetGrid(podaci[podaci.muzicka_dekada=='2010s'], col="genre")
# g.map_dataframe(sns.histplot, x="loudness",bins=np.linspace(0,1,21))
# plt.show()
# muzika2010ih = podaci[podaci.muzicka_dekada=='2010s'] # izdavajamo muziku 2010ih
# print(muzika2010ih.groupby('genre').loudness.std()) # grupisemo muziku 2010ih po zanrovima i na koloni loudness racunamo standardnu devijaciju

Исту функцију можемо икористити да погледамо и како се акустичност у џез музици мењала током деценија:

g = sns.FacetGrid(podaci[podaci.genre=='jazz'], col="muzicka_dekada")
g.map_dataframe(sns.histplot, x="acousticness",bins=np.linspace(0,1,21))
plt.show()

Ове дистрибуције су још занимљивије - не само да нису више симетричне као дистрибуције плесозовности, већ видимо да се облик дистрибуције драстично мењао кроз време. У педесетим годинама прошлог века, најпопуларнија вредност акустичности била је близу максималне вредности од 0.1, док у последњим декадама видимо да су најпопуларније вредности близу 0, тј. електрична музика присутна је и у џез музици. 

Код расподела које су асиметричне попут ових расподела акустичности најчешћа вредност (која се такође зове и мод или модус) у скупу података није близу просечне (видите то на графику испод) и тада је згодно поред ове две вредности наводити и **медијалну** вредност која је тачно на половини, тј. половина података је мања од ње, а половина је већа, видите то на следећем примеру (означено усправном испрекиданом линијом):

data_segment = podaci[(podaci.genre=='jazz')&(podaci.muzicka_dekada=='2010s')] #selektujemo pop pesme 2010ih
plt.hist(data_segment.acousticness, # podaci nad kojima primenjujemo funkciju hist
         bins=np.linspace(0,1,20), # pozicije intervala u kojima prebrojavamo pesme, ovde date kao 20 intervala jednake duzine
         alpha=0.5) # transparentnost
meanval = np.mean(data_segment.acousticness) # prosecna vrednost podataka nacrtanih histogramom
plt.axvline(x=meanval) # dodavanje uspravne linije na poziciji prosecne vrednosti
medianval = np.median(data_segment.acousticness) # medijalna vrednost podataka nacrtanih histogramom
plt.axvline(x=medianval,ls='--') # dodavanje uspravne linije na poziciji medijalne vrednosti
plt.xlabel('Акустичност')
plt.ylabel('Број песама')
plt.show()

Коначно, велики број савремених алата на основу доступних података покушава да процени како изгледа математичка расподела која најбоље описује доступне податке:

sns.histplot(data=podaci[(podaci.genre=='jazz')&(podaci.muzicka_dekada=='2010s')], x="acousticness",bins=20, kde=True, element="step")
plt.xlabel('Акустичност')
plt.ylabel('Број песама')
plt.show()

Иако су глатке верзије расподела често лепше и стога популарније коришћене и у научним радовима и у популарној комуникацији података, треба са њима увек бити опрезан пошто су настале као апроксимација података. Те апроксимације често се ослањају на неке претпоставке о подацима (врло често да су подаци добро описани једном или са више нормалних расподела) и стога је опрезније погледати колико се глатка расподела и дискретна расподела коју креира хистограм разликују (попут слике изнад) и на основу тога просудити да ли је визуализација одговарајућа. Процену да ли је нешто одговарајућа апроксимација или не увежбаћете са великим бројем погледаних графика, али угрубо, желите да ваша приближна глатка дистрибуција одговара подациам, овде на пример, ова крива значајно лошије оцењује вредности које су близу 0, тако да овде ова крива није одговарајућа. Када су вредности ваших података у ограниченом интервалу (као овде између 0 и 1), ове глатке апроксцимације често не раде како треба и понудиће вам процењене вредности и изван граница могућег, на то посебно обратите пажњу. 

**Просек: пре употребе погледати!**

Кључна порука ове лекције је да када користите просек да сажмете неку велику групу података у пар бројева, погледате дистрибуцију података и уверите се да је просек заиста меродаван. У случају дистрибуција каква је нпр. расподела плесозовност поп музике последње музичке декаде, дистрибуција је само благо асиметрична, па се просечна вредност налази у околини медијалне, а и у околини најпопуларније вредности. У таквим ситуацијама, просечна вредност наравно умањује број информација у односу на целу дистрибуцију, али се пуно песама налази у непосредној околини ове вредности, те комуницирате неку битну и заступљену вредност међу вашим подацима. Ово је још израженије код дистрибуције гласности истог музичког жанра, која иако јесте још више асиметрична је изузетно уска дистрибуција (мала стандардна девијација) па је велики број података (преко 80%) једну стандардну девијацију удаљен од просечне вредности.

Са друге стране, ако ваши подаци изгледају као дистрибуције акустичности, потребно је да размотрите алтернативе и уместо просечне вредности комуницирате најпопуларију вредност (мод) или бар вредност која је тачно на половини (медијана). То је стога што је просек доста удаљенији од најпопуларнијих вредности (видите акустичност џеза 2010их) и у његовој околини нема пуно песама. Ово је обично сигнализирано и великим вредностима стандардних дистрибуција, па вам преглед и тих вредности може помоћи да закључите да је дистрибуција доста широка и да је њено свођење на један број (просек) неадекватно. Предност медијалне вредности код оваквих дистрибуција је посебно очигледна када подаци нису ограничени на интервал од 0 до 1 као овде, већ се појављују неке изузетно велике вредности које могу подизати просечну вредност, али неће значајно мењати медијалну. Ову особину има дистрибуција зарада код које је готово увек смисленије причати о медијалној него о просечној вредности.

Коначно, има дистрибуција попут нпр. акустичности у џез музици током деведесетих које имају два популарна региона - има пуно података и са врло високом и врло ниском акустичношћу. Те дистрибуције се зову бимодалне (два мода) код њих су често медијална и просечна вредност на блиске, али су обе недовољно информативне пошто су обе доста удаљене од популарних вредности. У тим случајевима је информативније навести модове, или са великом вредношћу стандардне девијације сигнализирати да је дистрибуција широка и да се не обраћа пуно пажње на просек.

Сада када смо се упознали са расподелама и једном од мера њихове ширине, можемо поново погледати како изгледају линијски дијаграми које креира функција `lineplot` библиотеке `seaborn`, овај пут користећи аргумент `ci` - интервал поверења (енг. confidence interval). Прослеђивањем вредности `sd` овом аргументу, сигнализирамо функцији да свуда око линије која је просечна вредност обележи област у којој су подаци који су једну стандардну девијацију удаљени од просека:

rock_reggae = podaci[(podaci.genre=='reggae')|(podaci.genre=='rock')] # izdvajamo samo dva muzicka zanra zarad lakseg pracenja grafika
sns.lineplot(data = rock_reggae, # izbor podataka koje crtamo
             x = 'release_date',y='danceability', # izbor kolona koje se nalaze na x i y osi
             hue='genre', # biramo da linije budu obojene po zanrovima
             palette=sns.color_palette("colorblind")[1:3], # definisemo boje, u ovom slucaju 2. i 3. boju iz palete prikazane u nastavku
             ci='sd') # ovim parametrom definisemo da se na grafiku pojave samo izracunate prosecne vrednosti, vise o tome u nastavku
plt.ylim([0,1])
plt.ylabel('Плесозовност')
plt.xlabel('Година')
plt.show()


Сетите се, овај график смо приказали на крају друге лекције, и чинило нам се тада да су рок и реге значнајно другачији током целог временског интервала у коме посматрамо музику (тада смо приказали само просечне вредности). Сада са осенченим регионима којима комуницирамо и ширину расподела, односно угрубо комуницирамо у ком опсегу вредности се налази највише песама за дату годину, видимо да су разлике међу жанровима мање, често два обојена региона или додирују или поклапају. Специјално у последњим годинама, видимо да је просечна вредност једног жанра у оквиру региона другог жанра, односно пуно песама има карактеристике које по карактеристикама личе и на просечне песме једног и другог жанра. Са друге стране током осамдесетих година два жанра су далеко више раздвојена и тада са већом сигурношћу можемо говорити о дистинкцијама међу њима. Ова сличност и разлика међу подацима коју за сада оцењујемо само преклапањем између типичних региона параметара, формално се оцењује кроз статистичке тестове и више о тој теми можете прочитати у речнику појмова на крају и у оквиру темата о екологији.

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/> Како смо приметили да се само приказивањем промена просечних вредности можемо заварати и лоше проценити значајност промена у оквиру неког жанра, ова визуализација може бити интересантан начин да искомуницирате промене у ширини и облику дистрибуција које су се мењале кроз време:</div> 

<img src="muzika slike/bluz_energicnost.png"
     alt="Markdown Monster icon"
     width='400' />
На овој слици видимо да је енергичност блуз музике расла (дистрибуција се полако кроз деценије померала све више у десно), али и да је током деведесетих у блуз музици било песама свих нивоа енергичности практично једнако заступљених.  
Покушајте да је репродукујете користећи пример кода који се налази на [овој адреси](https://seaborn.pydata.org/examples/kde_ridgeplot.html).

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/> У претходној лекцији смо направили функцију која рачуна и црта померајући просек музичке карактеристике по избору, ваш задатак је да прилагодити ту функцију тако да поред просечне вредности црта и интервал поверења од једне стандардне девијације (као што то ради функција `lineplot` изнад. За то ће вам од користи бити ова функција fill_between:https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.fill_between.html</div> 

# #resenje

# def grafik_pokretnog_proseka(podaci, zanr, muz_karakteristika, vremenski_interval, boja):
#     """
#     Ova funkcija za odabrani zanr i muzicku karakteristiku crta grafik promene karakteristike kroz vreme
#     ali se usrednjavanje ne vrsi na godisnjem vec na visegodisnjem nivou (definisano parametrom vremenski_interval).
    
#     podaci - skup podataka koji sadrzi pesme razlicitih zanrova i za svaku ima vrednosti muzickih karakteristika (akusticnost, glasnost,itd.)
#     zanr - string koji oznacava muzicki zanr koji hocemo da selektujemo - moze biti 'pop', 'rock' itd
#     muz_karakteristika - string koji oznacava karakteristiku koju usrednjavamo i crtamo, mora da odgovara imenu kolone u tabeli podaci(moze biti 'acousticness', 'danceability'...)
#     vremenski_interval je broj godina (int), za 1 radi isto sto i groupby('release_date').mean(), za 10 crta desetogodisnji prosek
#     boja - string sa imenom boje (npr.'grey') ili heks kodom ('#000000') kojom crtamo liniju izracunatog proseka
#     """

#     zanr_cirilicom = {'pop':'поп','country':'кантри','blues':'блуз','jazz':'џез','reggae':'реге','rock':'рок','hip hop':'хип хоп'}
#     muz_cirilicom = {'acousticness':'Акустичност','instrumentalness':'Инструменталност',
#                      'danceability':'Плесозовност','loudness':'Гласност','valence':'Позитивност',
#                      'energy':'Енергичност'}
    
#     podaci_podskup = podaci[podaci.genre==zanr][['release_date',muz_karakteristika]] # deo skupa podataka koji odgovoara odabranom zanru i muzickoj karakteristici
    
#     prva_godina = min(podaci_podskup.release_date)+vremenski_interval-1 # prva godina za koju mozemo da sracunamo petogodisnji prosek, mora biti bar 5 godina veca od prve godine koju imamo u podaciam
#     poslednja_godina = max(podaci_podskup.release_date) # poslednja godina je najveca vrednost podataka o godinama u podacima

#     vreme = [t for t in range(prva_godina,poslednja_godina+1)] # lista godina od min za koju cemo sracunati prosek do maksimalne za zanr koji posmatramo
#     prosek = [] # lista u kojoj cemo sacuvati prosecne podatke u toku odabranog vremenskog intervala
#     stdevs = [] # lista u kojoj cemo sacuvati standardne devijacije
#     for t in vreme: # za svaku godinu iz liste
#         uslov = ((podaci_podskup.release_date)>=t-vremenski_interval)&((podaci_podskup.release_date)<t)
#         podskup_t = podaci_podskup[uslov][muz_karakteristika] # izdvajamo deo podataka koji odgovara prethodnim godinama u okviru posmatranog prozora
#         prosek.append(podskup_t.mean()) # racunamo prosek i dodajemo u listu
#         stdevs.append(podskup_t.std()) # dodajemo standardne devijacije
#     plt.plot(vreme, prosek,color=boja,label=zanr_cirilicom[zanr]+', '+str(vremenski_interval)+'-годишњи просек') # crtamo grafik
#     prosek = np.array(prosek) # pretvaramo listu u numpy niz da bismo lakse sabirali i oduzimali vrednosti duz svih elemenata niza
#     stdevs = np.array(stdevs)
#     plt.fill_between(vreme, prosek-stdevs,prosek+stdevs,color=boja,alpha=0.2) # crtamo grafik u kome je osencen region udaljen jednu standardnu devijaciju od proseka
#     plt.xlabel('Година')
#     plt.ylabel(muz_cirilicom[muz_karakteristika].capitalize())
#     #return time,mean_feature # alternativno, ova funkcija bi mogla da vraca sracunate vrednosti a da na drugom mestu crtamo grafik

# # resenje
# grafik_pokretnog_proseka(podaci,'pop','loudness',5,'grey')
## 5. Песме у више димензија

Да ли су песме једног жанра близу једа другој и у више димензија (акустичност, позитивност, разиграност...)? Да ли су далеко од других жанрова? А песме појединачних ауторки или аутора? А најпопуларније песме свих времена? 

Док тражимо одговоре на ова питања, илустроваћемо музичке нумере из музичког скупа података на још начина. До сада смо се углавном фокусирали на један аспект нумере - акустичност, енергичност или било који други од атрибута песама и посматрали како се у оквиру једног жанра или временског тренутка (године или деценије) песме међусобно разликују. То значи да смо посматрали једну димензију песама, заборављајући на тренутак остале димензије. Међутим, свака од песама има истовремено све поменуте атрибуте, што значи да о свакој песми можемо мислити као о тачкици у једном више димензионалном простору (овде 7Д ако размишљамо само о нумеричким колонама). На жалост, немамо добар начин да визуелно представимо толико димензија у оквиру нашег тродимензионалног простора, али са добром припремом, селекцијом, бојама и другим визуелним каналима можемо приказати више од само две димензије, па хајде да видимо како.

# ucitavanje neophodnih biblioteka

import pandas as pd # ucitavanje i manipulacija tabelarnih podataka
import seaborn as sns # vizualizacija
import matplotlib.pyplot as plt # vizualizacija
import numpy as np # manipulacija nizovima i matricma
import plotly.express as px # interaktivne vizualizacije

podaci = pd.read_csv('muzika podaci/music_data.csv') # učitavanje prethodno pripremljenog skupa podataka

За почетак, уместо представљања само једне димензије песама, можемо представити све песме као тачице у дводимензионалном простору (одабравши две координате, тј. два атрибута за сваку песму). То ћемо урадити користећи функцију [scatterplot](https://seaborn.pydata.org/generated/seaborn.scatterplot.html) из `seaborn` библиотеке (коју смо скраћено назвали `sns` као и раније):

plt.figure(figsize=(6,6))
sns.scatterplot(data = podaci[podaci.muzicka_dekada=='1950s'], x='energy',y='valence',color='lightgrey') # crtamo tackasti dijagram
# probajte isto koristeći kombinacije (danceability,energy) ili (loudness, danceability) na h,u osama
plt.xlabel('Енергичност')
plt.ylabel('Позитивност')
plt.show()

Видимо да су песме које су енергичније (виша вредност атрибута `energy`) су често и песме које су позитивније `valence`. То видимо тиме што се песме (тачкице) ретко налазе у домену високих енергичности, а мале позитивности, односно у доњем десном региону. Слично нема пуно песама које су доста позитивне а слабо енергичне (горе лево). *Како бисте статистички испитали потенцијалну повезасност између ове две варијабле (енергичност и позитивност)?*

Представљене су само песме из 1950их зато што би у противном дијаграм био потпуно преплављен тачкицама (*пробајте!*). 

На претходном графику смо искористили само два атрибута за сваку од песама, а имамо могућност да додамо још 2 особине песама користећи величину кружића и њихову боју, користећи аргументе `size` и `color`:

plt.figure(figsize=(8,6))

dzezmuzika = podaci[(podaci.muzicka_dekada=='1950s')&(podaci.genre=='jazz')] # izdvajamo dzez pesme i ostale
nedzezmuzika = podaci[(podaci.muzicka_dekada=='1950s')&(podaci.genre!='jazz')]
sns.scatterplot(data = nedzezmuzika, x='energy',y='valence',size='instrumentalness',alpha=0.7,color='grey')
sns.scatterplot(data = dzezmuzika, x='energy',y='valence',size='instrumentalness',alpha=0.9,color='#7f3c8d',legend=False)
plt.xlabel('Енергичност',fontsize=12)
plt.ylabel('Позитивност',fontsize=12)
plt.show()

Могли смо изабрати и да сваки жанр буде другачије боје, али нажалост то би учинило дијаграм исувише шареним и нечитљивим. Овако, издвајањем само једног жанра (у овом случају џеза) можемо генерисати додатне хипотезе за проверу. На пример, чини се да су џез песме педесетих година више груписане у доњем-левом делу, тј. мање енергичне и мање валентне (мање позитивне), иако има изузетака. Погледајмо на пример овај уочљив изузетак - џез песму са највећом енергичношћу и високим уделом инструментала: 

maxenergicnost = max(dzezmuzika.energy) # trazimo maksimalnu vrednost energicnosti
dzezmuzika[dzezmuzika.energy == maxenergicnost] # izdvajamo iz dzez tabele pesmu koja ima najvecu energicnost

На [овом линку](https://www.youtube.com/watch?v=xA758W0CHsI) можете преслушати ову џез песму која се издваја од осталих. А да бисмо лакше проналазили информације о песмама тј. тачкицама на графику које нам привлаче пажњу, нацртаћемо исти график у интерактивном облику. За то користимо библиотеку [plotly.express](https://plotly.com/python/plotly-express/) скраћено `px` и у њој одговарајућу функцију [scatter](https://plotly.com/python-api-reference/generated/plotly.express.scatter), да бисмо лакше приметили сличности и мане ова два графикона искористићемо исте податке и исте атрибуте на осама:

podaci['author_track'] = podaci['artist_name']+': '+podaci['track_name'] # pravimo novu kolonu u kojoj u jedan string spajamo ime autora i ime pesme 
podaci50s = podaci[(podaci.muzicka_dekada=='1950s')] # izdvajamo kao i prethodno podatke iz pedesetih godina proslog veka

fig = px.scatter(podaci50s, # skup podataka na osnovu kog crtamo grafik
                 x="energy", y="valence", # biramo muzicke atribute za x i y osu
                 size='instrumentalness',color="genre", # biramo kolone koje ce se koristiti za velicinu i boju kruzica
                 hover_name='author_track', # kolona koju cemo koristiti za ispis kada se misem predje preko kruzica
                 color_discrete_sequence=px.colors.qualitative.Bold, # paleta boja
                labels={'energy':'Енергичност', # promena imena x i y ose
                       'valence':'Позитивност'})
fig.update_xaxes(range=[0, 1]) # definisemo opseg na x osi
fig.update_yaxes(range=[0, 1]) # definisemo opseg na y osi
fig.update_layout(
    autosize=False,
    width=800, # velicina slike
    height=600,
    template= 'plotly_white' # boja pozadine
)
fig.show()

Предност интерактивног приказа је да можемо елиминисати различите жанрове кликом на њихов кружић у легенди (и тако да једноставно можемо уклонити и додати претходно истакнути џез), али и прочитати додатне податке преласком миша преко кружића. Овде смо одабрали да преласком миша преко маркера прочитамо име извођача и песме чиме лако истражујемо које су то песме које одступају од тренда који нам се чини доминантним - да с порастом енергичности песма постаје и позитивнија. 

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/> Одаберите податке из неке друге деценије, нпр последње и видите како исти дијаграм изгледа - да ли су енергичност и валентност и даље у сличном односу? Да ли уочавате неке другачије правилности? Шта ако одаберете друге атрибуте на х и у оси?</div> 


На претходним графицима чинило нам се и да можемо проценити где је већа густина тачкица - али то није лако оценити гледајући само тачкасте дијаграме зато што се пуно песама (тачака) прекалапа што отежава процену. Зато, аналогно хистограму у једној димензији, можемо уз помоћ 2Д хистограма, пребројати песме (тачкице) које припадају одређеном сегменту простора и исто представити тамнијим и светлијим бојама. Ево претходно цртаних података представљених и на тај начин:

broj_intervala = np.linspace(0,1,26) # kao i kod jednodimenzionalnih histograma ključan parametar je gbroj intervala na koje delimo x u y osu, ovde 25

plt.figure(figsize=(15,4))

plt.subplot(1,2,1)
plt.hist2d(x = nedzezmuzika['energy'],y = nedzezmuzika['valence'],bins=broj_intervala);
plt.title('Песме 50их без џез музике')
plt.xlabel('Енергичност')
plt.ylabel('Позитивност')
plt.colorbar()

plt.subplot(1,2,2)
plt.hist2d(x = dzezmuzika['energy'],y = dzezmuzika['valence'],bins=broj_intervala);
plt.title('Џез песме педесетих')
plt.xlabel('Енергичност')
plt.ylabel('Позитивност')
plt.colorbar()

plt.show()

Ови хистограми нам помажу да боље видимо регионе у којима има највише песама - то су делови који су највише жути и светлозелени (видите легенду са стране). Леви график на коме су сви жанрови без џеза поново приказује да су енергичност и позитивност спрегнуте, али сада још лакше видимо да су региони са највише песама такви да за њих важи да су песме мало више позитивне него енергичне. Ово најлакше можете видети ако замислите линију на којој је позитивност једнака енергичности и приметите да су најсветлији региони углавном изнад те линије. Са десне стране видимо да је највише џез песама мале енергичности и позитивности,односно углавном су груписане доле лево, иако је највише песама са енргичношћу око 0.2 и позитивношћу нешто изнад 0.4. Иако разлика између ова два графика није драматична, свакако примећујемо да џез песме имају другачију расподелу у простору енергичности и позитивности у односу на песме осталих жанрова.

Шта је са осталим жанровима и другим временским периодима?

plt.figure(figsize=(15,4))
podaci2010ih = podaci[podaci.release_date>=2010]

plt.subplot(1,2,1)
plt.hist2d(x = podaci2010ih[podaci2010ih.genre!='hip hop']['danceability'],y = podaci2010ih[podaci2010ih.genre!='hip hop']['valence'],bins=broj_intervala);
plt.title('Песме 2010их без хип хопа')
plt.xlabel('Плесозовност')
plt.ylabel('Позитивност')
plt.colorbar()

plt.subplot(1,2,2)
temp = plt.hist2d(x = podaci2010ih[podaci2010ih.genre=='hip hop']['danceability'],y = podaci2010ih[podaci2010ih.genre=='hip hop']['valence'],bins=broj_intervala);
plt.title('Хип хоп песме 2010их')
plt.xlabel('Плесозовност')
plt.ylabel('Позитивност')
plt.colorbar()

plt.show()

Када се изузме хип хоп (леви график), највише песама 2010их се налази у средишњем региону у простору позитвности и плесозовности. Нема пуно песама које нису плесозовне а позитивне су (горе лево), ни оних које су изузетно плесозовне а нису позитивне (доле десно). Са десне стране, хип хоп песме највише су груписане у региону велике плесозовности и велике позитивности, чиме се прилично разликују од осталих песама последње декаде. Интересантно је и да су готово све хип хоп песме у десној половини гарфика, тј са плесозовношћу изнад 0.5. Специјално, обратите пажњу овде на скале приказане са десне стране ових графика - како хип хоп песама има мање, скала боја иде само до 9, док иста боја на левом графику означава преко 30 песама. То значи да треба опрезно тумачити график ако на пример хоћете директно да поредите број песама у истом квадратићу на левој и десној страни, међутим оно што смо ми радили, оцењивали регионе највеће густине песама можемо сасвим добро урадити и упркос чињеници да је број песама у једној и другој групацији различит.

Слично као што смо код хистограма у једној димензији могли да варирамо број интервала на које делимо регион могућих акустичности и бројимо песме у сваком од интервала, тако и овде можемо варирати број квадратића на које је подељен простор и тако чинити слику више или мање детаљном (пробајте да промените аргумент `bins`).

Начин да повежемо ове визуализације са онима које смо правили у претходној лекцији је да додамо и одговарајуће једнодимензионалне хистограме, на примеру хип хопа то изгледа овако:

hiphop10s = podaci2010ih[podaci2010ih.genre=='hip hop']
g = sns.JointGrid(data=hiphop10s,x="danceability", y="valence",marginal_ticks=True)
g.plot_joint(sns.histplot, cmap="light:#11a579")
g.plot_marginals(sns.histplot, element="step", color="#11a579",bins=broj_intervala)
g.set_axis_labels('Плесозовност', 'Позитивност',fontsize=12)
plt.show()

На овај начин поред тога што видимо како колико песама има истовремено и високу плесозовност и позитивност - што видимо посматрајући колико су тамни квадратићи у средишњем простору - можемо видети и расподелу хип хоп песмама само по позитивности (десни хистограм) или плесозовности (горњи хистограм). Тако на пример лако можемо сагледати претходно констатовано да су плесозовности махом изнад вредности 0.5 и можемо видети да је највише песама са вредношћу око 0.8. 

Такође, као што смо и у једној димензији видели да постоји могућност да се нацрта апроксимативна глатка расподела, исто можемо урадити и у две димензије. Тако уместо претходно приказане пикселизоване слике густине, можемо видети процењене линије густине, на пример на овај начин:

rok_hiphop_2010ih = podaci2010ih[(podaci2010ih.genre.isin(['rock','hip hop']))]
g = sns.jointplot(
    data=rok_hiphop_2010ih,
    y="valence", x="danceability", hue="genre",palette=['#7f3c8d','#11a579'],
    kind="kde"
)
g.set_axis_labels('Плесозовност', 'Позитивност',fontsize=12)
plt.show()

На претходном графику приказали смо хип хоп и рок 2010их у простору позитивности и плесозовности. Иако вам ови графици могу деловати привлачније, и даље стоји наше упозорење на опрез када користите ове апроксимативне методе да добијете глатке пределе густине, те препоручујемо да увек погледате како изгледају одговарајући хистограми и колико их адекватно криве линије сумирају (у погледу позиције максимума, ширине дистрибуције и слично). Међутим, једна предност коришћења ових апроксимативних метода у две димензије је што можете лако упоредити две дистрибуције, као на овом примеру, у једној слици. Овако лакше можемо осмотрити да постоје региони у којима су само рок песме (не баш добре за игру и негативније) или региони у којима су претежно хип хоп песме (велика плесозовност). Што је ово раздвајање веће можемо лаше (и са већом сигурношћу) говорити о томе да постоје дистинкције између жанрова (или група података у ширем смислу). А уколико желите да идентификујете појединачне песме које се налазе у региону који је заједнички за оба жанра, или напротив, оне песме које су типичније присутне у једном од жанрова, за то је опет најзгоднији интерактивни график:

fig = px.scatter(rok_hiphop_2010ih, # skup podataka na osnovu kog crtamo grafik
                 x='danceability',y="valence", # biramo muzicke atribute za x i y osu
                 size='loudness',color="genre", # biramo kolone koje ce se koristiti za velicinu i boju kruzica
                 hover_name='author_track', # kolona koju cemo koristiti za ispis kada se misem predje preko kruzica
                 color_discrete_sequence=px.colors.qualitative.Bold, # paleta boja
                labels={'danceability':'Плесозовност', # promena imena x i y ose
                       'valence':'Позитивност'})
fig.update_xaxes(range=[0, 1]) # definisemo opseg na x osi
fig.update_yaxes(range=[0, 1]) # definisemo opseg na y osi
fig.update_layout(
    autosize=False,
    width=700, # velicina slike
    height=600,
    template= 'plotly_white' # boja pozadine
)
fig.show()

И на овом графику видимо делимично раздвајање ових жанрова са могућношћу да идентификујемо песме које су на прелазу, али и оне које се више издвајају, али изгубили смо могућност да проценимо број песама у деловима у којима виидмо гужву кружића. Искористили смо и гласност песама да означимо њоме величину кружића. Како смо раније закључили да је данашња музика углавом гласнија него музика раније и да је расподела гласности прилично уска дистрибуција, сви кружићи су сличне величине (што нам и помаже да их лепо видимо и пређемо преко њих мишем и очитамо вредности које нас занимају).

<div class="alert alert-block alert-info"><img src="muzika slike/zad.png" align="left"/> Искористите визуализације са контурама и интерактивне тачкасте дијаграме да истражите промене у оквиру једног жанра у две различите музичке декаде. Упоредите на пример музички жанр по избору седамдесетих и две хиљаде десетих. Испробајте различите музичке карактеристике на х и у осама.</div> 


# #resenje

# podskup_podataka = podaci[(podaci.genre=='reggae')&(podaci.muzicka_dekada.isin(['1970s','2010s']))]
# g = sns.jointplot(
#     data=podskup_podataka,
#     x="loudness", y="valence", hue="muzicka_dekada",palette=['#7f3c8d','#11a579'],
#     kind="kde"
# )
# g.set_axis_labels('Гласност', 'Позитивност',fontsize=12)
# plt.show()
## 6. Извођачи музичких нумера

Можда сте читајући претходно све време на уму имали један бенд или једну певачицу или певача кога сте желели да истражите, па хајмо да се за крај осврнемо на појединачне ауторе. Хајде да пробамо да видимо како су распоређени извођачи песама. На овај начин такође покушавамо да уклонимо вишак варијабилности који постоји међу различитим песмама истог аутора, али претпостављамо да постоји неки лични печат сваког од аутора.

За почетак, оне ауторе који имају пуно песама у скупу података, можемо покушати да представимо истим типом дијаграма који смо користили у претходној лекцији за истраживање музичких жанрова. Ево једне комбинације аутора чије се песме разликују у простору енергичности и валентности музичких нумера.

## ucitavanje neophodnih biblioteka
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

podaci = pd.read_csv('muzika podaci/music_data.csv') # učitavanje prethodno pripremljenog skupa podataka i cuvanje u promenljivoj podaci

izdvojeni_autori = ['nina simone','green day'] # imena odabranih autora
izdvojeni_podaci = podaci[podaci.artist_name.isin(izdvojeni_autori)] # izdvajamo podatke kod kojih se vrednost u koloni imena autora nalazi u listi izdvojenih koju smo pripremili
izdvojeni_podaci.info() # pregled velicine izdvojene tabele

g = sns.jointplot(
    data=izdvojeni_podaci, # podaci na osnovu kojih crtamo
    x="valence", y="energy", hue="artist_name", # izbor kolona za x, y osu i boju
    kind="kde",fill=True, # kljucnom reci 'kde' signaliziramo da hocemo aproksimativne glatke linije(povrsine), dok arugmentom fill oznacavamo da hocemo da obojimo povrsine
    palette=['#fd570b','#64062a'] # biramo dve boje kojima cemo prikazati rezultate
)
g.set_axis_labels('Валентност','Енергичност',fontsize=12) # imena osa 
plt.show()

Гледајући само горње графике (расподеле по валентности музичких нумера) видимо да се најпопуларније вредности, тј. модови дистрибуција не поклапају, али постоји велика заједнична површина, тј. оба аутора имају и више и мање валентне песме. Ако бисмо анализирали ове ауторе само у погледу валентности, не бисмо били пуно сигурни у постојање разлика међу њима. Са десне стране ако погледамо дистрибуције по енергичности, раздвајање је јасније, врло мало песама има енергичност о којој би се двоумили којој од дистрибуција припада, тј. пресецање ова два аутора у овој димензији је веома мало. Коначно, када погледамо у дводимензионалне расподеле песама, раздвајање аутора је врло јасно. Тамније површине означавају да у оквиру њихових контура има највише песама - упоредите позиције тих најтамнијих контура са њиховим позицијама у оквиру једнодимензионалних дистрибуција са десне стране и горе и приметите поклапања.
Група *Green day* има претежно енергичне и позитивне песме, док су песме ауторке *Nina Simone* у већем броју мање позитивне и мање енергичне иако има изузетака. 

Иако су ови резултати интересантни и можемо се задовољити визуелном привлачношћу овог графика, он је добар пример да поново тестирамо адекватност овог (често називаног и контурног) графика насупрот пикселизованим дводимензионалним хистограмима или тачкастим дијаграмима које смо цртали у претходној лекцији. Један од проблема који треба да нас забрине на горњем дијаграму је чињеница да обојене површине излазе из очекиваних граница варијабли - и валентност песама Нине Симон има негативне вредности, и енергичност Грин деја има вредности преко један.

Иако можемо искористити и дводимензионални хистограм са контурама преко, како смо видели да ово двоје аутора има мање од 150 песама можемо погледати и тачкасту верзију горњег дијаграма заједно са контурама које је алгоритам одредио:

plt.figure(figsize=(6,6))
sns.scatterplot(data=izdvojeni_podaci,x='valence',y='energy',hue='artist_name',palette=['#fd570b','#64062a'])
sns.kdeplot(data=izdvojeni_podaci,x='valence',y='energy',hue='artist_name', linewidths=1,palette=['#fd570b','#64062a'])
plt.xlabel('Валентност',fontsize=12)
plt.ylabel('Енергичност',fontsize=12)
plt.show()

Сада јасно видимо да контуре које излазе из греница могућих вредности нису последица грешке у нашим подацима - све тачкице су енергичности мање од 1 иако пуно контура излази из тог опсега. Овај проблем можете решити и додавањем следећег аргумента `clip=(0,1)` у функцији `kdeplot` (испробајте!), мада ће он практично само исећи простор видљивог графика, неће променити облик процењених контура у оквиру региона од интереса (између 0 и 1).
Иако и посматрањем тачкица видимо да су различити аутори прилично раздвојени (осим 2 песме Грин деја које су **аутлајери** тј. доста одскачу од осталих њихових песама и које су доста сличније типичним песмама Нине Симоне), али за овај број тачкица број и детаљност контура делују далеко компликованије од онога што подаци сугеришу. Ова оцена да ли је детаљност апроксимативног дијаграма добра или не ће доћи са вежбом и пуно погледаних графикона, али нека основна сугестија је да избегавате превише компликоване криве. У овом случају, ако погледате по две највеће криве код оба аутора, обе су превише пуне завијутака и детаља иако имају само по 2-3 тачкице у том простору који описују. Те две три песме могу бити **аутлајери** или просто нетипичне песме, случајне варијације и излети аутора у неке новине и није неопходно да наша апроксимативна густина песама постане значајно компликованија фунцкија на основу њих. Ово је пример нечега што се у статистици и машинском учењу често назива и оверфитовање, у циљу да објасните све податке, нацртаћете изузетно компликовану линију која пролази кроз све или у близини свих, иако ћете тако изгубити на једноставности, разумевању и често предиктивности модела. Још мало о машинском учењу погледајте у видеу у ком уз помоћ ових података илуструјемо класификацију података.

Већ на самом почетку видели смо и да постоје аутори који су изузетно продуктивни и чијих пуно песама се налази у нашем скупу података, али и они који су у скупу представљени само једном песмом. 

artist_counts = podaci.artist_name.value_counts() # kao i prethodno broj pesama autora dobijamo korišćenjem funkcije value_counts
artist_counts.sort_values(ascending=False)[:10] # prikazujemo 10 autora sa najvise pesama

Али сада када смо се упознали са хистограмима, хајде да погледамо колико има аутора са различитим бројем песама:

plt.hist(artist_counts,bins=100,color='#ccb5fd')
plt.yscale('log')
plt.xlabel('Број песама')
plt.ylabel('Број аутора са истакнутим бројем песама')
plt.show()

Када смо функцију `hist` применили на број песама сваког од аутора присутних у скупу података, добили смо информацију о томе колико аутора има означени број песама (као и претходно, дефинисано интервалима бројева песама, које овде нисмо задали тачно, већ смо само нагласили да хоћемо 100 интервала да бисмо приметили фину структуру). Видимо да су аутори са великим бројем песама изузетно ретки, највише је аутора са једном песмом, затим са две-три и број аутора опада са бројем песама. Овај број заправо опада далеко брже него што вам се чини - обратите пажњу на у осу! Овде смо у осу трансформисали тако да сада један означенени подеок није за 10 већи од претходног, већ 10 пута већи од претходног (погледајте како график изгледа ако закоментаришете линију `plt.yscale('log')`).

Како у наставку планирамо да тражимо карактеристике различитих аутора, фокусираћемо се само на оне ауторе који имају 10 и више песама. Ова граница од 10 је прилично арбитрарна зато што је наш циљ да мало умањимо скуп података и закључујемо само о ауторима за које постоји довољно различитих песама, али ништа нам не каже да је боље узети ауторе са бар 10 или са бар 5 или 15 песама, испробајте како се разликују резултати које добијате уколико направите ове промене.

artist_names = artist_counts[artist_counts>9].index #biramo samo one autore koji imaju više od 9 pesama i njihova imena čuvamo u novoj promenljivoj

Можете проверити постојање аутора по избору у овом скупу:

podaci[podaci.artist_name=='adele'] # prikaz svih pesama i karakteristika autorke po izboru

Можемо проверити колико песама има одабрана ауторка у нашем скупу:

len(podaci[podaci.artist_name=='adele'])

Како је број већи од изабраног граничног, можемо проверити да ли се њено име налази у листи аутора које смо издвојили:

'adele' in artist_names

Садa кад смо издвојили ауторе од интереса, издвојићемо податке који садрже само њихову музику, а затим ћемо груписати податке (функцијом [groupby](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html)) по њиховим именима и уместо да чувамо карактеристике свих песама сачуваћемо само медијалне вредности (функцијом [median](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.median.html)):

podaci_izabranih_autora = podaci[podaci.artist_name.isin(artist_names)] #izdvajamo tabelu koja sadrzi samo odabrane autore i cuvamo podatke u novoj promenljivoj
muzicki_atributi = ['acousticness','danceability','instrumentalness','loudness','valence','energy'] # lista muzickih karakteristika koje cije medijalne vrednosti cemo izdvojiti
podaci_autora = podaci_izabranih_autora.groupby('artist_name')[muzicki_atributi].median() # grupisemo autore po imenu i za svaku grupu cuvamo samo medijalne vrednosti o muzickim karakteristikama

У дискусији претходно видели смо да се код симетричних расподела попут нормалне просечна и медијална вредност поклапају, међутим, уколико је расподела асиметрична или има јако велике и удаљене вредности, просечна вредност ће се значајно померити од најчешћих вредности и неће бити добар опис за велики број података. У таквим случајевима, медијална вредност, може бити бољи избор пошто се тачно пола вредности налази и изнад и испод ње. Погледајмо како изгледају последњи уноси припремљених података:

podaci_autora.tail(2)

Коначно, за визуализацију ових аутора биће нам згодно и да имамо информацију о жанру музике коју најчешће певају. И то се може урадити уз помоћ груписања по имену аутора, само што овај пут нећемо искористи рачунање просечне вредности (зато што су у питњу низови карактера), већ ћемо тражити најчешћу вредности, применом функције [mode](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html) библиотеке `pandas`:

zanr_umetrnika = podaci_izabranih_autora.groupby('artist_name')['genre'].agg(pd.Series.mode)
zanr_umetrnika.tail(2)

Спојићемо ове податке у једну табелу користећи функцију [merge](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html) која спаја табеле користећи податке из једне заједничке колоне, овде имена аутора који су индексна колона у оба скупа података:

podaci_autora = pd.merge(left = podaci_autora,right = zanr_umetrnika,left_index=True,right_index=True).reset_index()
podaci_autora.tail()

Овако припремљене податке можемо илустровати на различите начине као и раније, ево на пример интерактивног тачкастог дијаграма:

zanrovi = ['rock','reggae']

fig = px.scatter(#artists_data,# ovako nacrtamo sve zanrove a onad koristimo legendu da neke ugasimo/upalimo posto ce biti guzva
                 podaci_autora[podaci_autora.genre.isin(zanrovi)], # ili odmah ogranicimo samo na neke zanrove
                 x="valence", y="energy",color="genre",size ='acousticness', hover_name="artist_name",
                 color_discrete_sequence=['#64062a','#fd570b'])
fig.update_xaxes(range=[0, 1])
fig.update_yaxes(range=[0, 1])
fig.update_layout(
    autosize=False,
    width=800,
    height=600,
    template= 'plotly_white'
)
fig.show()

Преласком миша преко кружића можете наћи имена аутора који се издвајају или оних који су близу осталим жанровима. Величином круга смо означили акустичност, па тако можете видети где се групишу аутори које су више ослоњени на електрични/акустични звук и да ли су они ближи другом жанру. 

Можемо приметити да се у оквиру рок музике издвајају јако мали кружићи (електрични инструменти) који имају и високу вредност енергичности и ниже вредности валентности (међу којима су често метал бендови), док су на другом крају дијаграма већи кружићи који одговарају акустичним рок бендовима и извођачима. Међу реге извођачима видимо мањи распон у погледу акустичности (величине круга), али су свеукупно извођачи на високим вредностима по параметру валентности.

Можете нацртати исти график и користећи све жанрове, овде су изабрана два која се више разликују и са којима је читљивост графика мало боља, али експериментишите и генеришите своја питања и тестирајте их.

За крај један подсетник да смо свођењем аутора на медијалне вредности њихових песама одстранили значајан варијабилитет који постоји међу њиховим песмама. Ово је наравно у реду пошто се не могу све информације искомуницирати одједном и приликом анализе и представљања података је увек битно одабрати пар кључних порука да читалац не би био затрпан. Међутим, битно је освестити и каква поједностављења су направљена да би закључивање било адекватно. На пример, овде можете видети како изгледају све тачкице које одговарају песмама Мадоне у нашем скупу података, и једна истакнута тачка коју користимо изнад када поредимо Мадону са осталим ауторима:

podaci_madonna = podaci_izabranih_autora[podaci_izabranih_autora.artist_name=='madonna']
sns.scatterplot(data = podaci_madonna, x ='valence',y ='energy',color='#ccb5fd',s=100)
plt.scatter(podaci_autora[podaci_autora.artist_name=='madonna']['valence'],podaci_autora[podaci_autora.artist_name=='madonna']['energy'],color='#64062a',s=100)
plt.xlim([0,1])
plt.ylim([0,1])
plt.xlabel('Валентност')
plt.ylabel('Енергичност')
plt.show()
## 1. Питања о Олимппијским играма и подаци у којима се крију одговори

За нама су још једне Летње олимпијске игре. Иако је пандемија учинила организацију и протоколе далеко компликованијим, о последњим Летњим олимпијским играма се прича са великим дивљењем у погледу нових постављених рекорда, великог уплива технологије у спорт, о различитим државама које су доминирале победничким постољима, али и о новим улагањима у спорт и слично. Пуно новинских чланака, репортажа и дискусија о Олимпијским играма, обилује и статистичким подацима о овим догађајима. Неке информације тог типа, можете прочитати на званичном сајту Олимпијских [игара](https://olympics.com/en/), на веома детаљним чланцима на енглеској Википедији, нпр. овде за последње Олимпијске [игре](https://en.wikipedia.org/wiki/2020_Summer_Olympics) и на бројним другим местима. Међутим, често нас популарни чланци подстакну да наставимо да се питамо, али није увек јасно како потражити одговоре на питања попут ових:
- Колико спортиста се такмичи за медаље? У којим спортовима је конкуренција највећа?
- Који спортови су најпопуларнији? Да ли се листа такмичарских спортови у оквиру Олимпијских игара мењала током година?
- Да ли државе победнице имају нешто заједничко? Да ли богатије земље освајају више медаља? Како и ви да нацртате мапу на којој су обележене земље са највише златних медаља?
- Да ли је држава у којој су се одржале Олимпијске игре добила више медаља него иначе, тј. да ли се и у спортском смислу "исплати" организовати Олимпијске игре?

На ова и слична питања, није увек једноставно одговорити читајући чланке или већ припремљене анализе. Стога, заједно ћемо тражити одговоре у подацима и цртати наше верзије илустрација које сте имали прилике да видите али нисте могли лако да промените ако сте имали мало другачије питање.

<details>    
<summary>
    <font color="darkgreen"><b>Какве податке бисте тражили ако желите да одговорите на питање о популарности различитих спортова током година?</b>
</font>
</summary>
Слике спортских екипа током различитих Олимпијских игара, аудио записе репортажа, табеле података о броју такмичара по различитим спортовима и годинама...?
Иако су наши алгоритамски алати све јачи у декодирању слика, звука и текста, идеално, желите нумеричке поадтке попут последње наведене табеле. Некада на жалост такви подаци нису доступни па се приступа прикупљању бројева на основу других извора, али у овом случају, имамо среће зато што је историја Олимпијских игара добро документована.

На нека од питања која смо поставили одговорићемо у низу лекција у наставку користећи следеће податке (који ће у одговарајућим одељцима биће детаљније прегледани и описивани):
- [историја Олимпијских игара](https://www.kaggle.com/heesoo37/120-years-of-olympic-history-athletes-and-results). На основу овог скупа података, припремили смо два фајла - податке о Зимским и Летњим олимпијским играма до 2014 године. Овај скуп података садржи информације о учесницима Олимпијских игара, њихово име, пол, висину, масу, старост, име тима који представљају, спорт и дисциплину на којој су учествовали и медаљу ако су је добили. Овај скуп података нам је значајан за сва питања о променама у току дуге историје Оимпијских игара. Оригинални фајл можете преузети и са линковане адресе, где можете видети и неке примере употребе ових података и детаље о настанку скупа података који су прикупљени користећи [sports-reference.com сајт](www.sports-reference.com).
- Податке о броју становника и богатству држава преузели смо са сајта [*gapminder*](https://www.gapminder.org/data/) где можете интерактивно визуализовати разне интересантне информације о државама света. Подаци које смо преузели настали су на основу података које прикупљају и/ли процењују на основу других показатеља Уједињене Нације и Светска банка.

Приметићете да смо код описаних спортских подтака, поред линка ка веб страни на којој их можете преузети, дали и адресу веб стране која је коришћена за припрему ових података. Табеле података које ћемо користити настале су аутоматизованим прикупљање података са веба. Аутори ових скупова података су на основу различитих статистичких података излистаних у различитим одељцима веб страна направили табеларан скуп података погодан за даље истраживање. То значи да подаци које имамо често нису званични подаци, нити постоји нека контрола њиховог квалитета и стога треба да будемо додатно пажљиви. Ово није необично, званични подаци попут оних које прикупља Пепублички завод за статистику и њему аналогне институције у другим државама, покривају само део тема које су нам интересантне, стога ће нас потреба да доносимо закључке на основу података често наводити на податке који долазе из других и другачијих извора. Битно је само да смо свестни да код ових података постоји могућност грешке и да у складу са тиме опрезно доносимо закључке и када год је могуће проверимо и/ли укрстимо информације са још извора зарад провере.

<details>    
<summary>
    <font color="darkgreen"><b>Какве проблеме са подацима очекујете?</b>
</font>
</summary>
Погрешне вредности, погрешан формат података, недостајући уноси, недовољно документоваи уноси...

Одабрани алат за употребу података у наставку курса се сигурно разликује од метода које сте до сада практиковали. На пример, садржај фолдера са подацима можемо урадити овако:
<img src="sport_slike/sport_podac_folder.jpg"
     width='400' />
     
Или користећи библиотеку `os` у оквиру јупитер радних свесака:
```
import os

for tabela in os.listdir('sport_podaci'):
    print (tabela)
```
чији ће резултат бити:
```
letnje_olimpijske_igre_do_2014.csv
mapa_sveta.xlsx
oi2012_medalje_po_zemljama.csv
populacija_gdp_2012.csv
zimske_olimpijske_igre_do_2014.csv
```

# import os

# for tabela in os.listdir('sport_podaci'):
#     print (tabela)

Који год начин да сте искористили видите да у фолдеру са подацима постоје неки фајлови које можете повезати са претходно дискутованим (`letnje_olimpijske_igre_do_2014` и `zimske_olimpijske_igre_do_2014` садрже податке о спортистима, а `populacija_gdp_2012` о државама). Ту су и неки подаци који ће нам служити за цртање мапе света `mapa_sveta`, али и `oi2012_medalje_po_zemljama.csv` који ћемо кроз лекције креирати заједно, а овде је за случај да кренете да читате лекције различитим редоследом од планираног.

Пре него што кренете да петљате са спортским подацима, охрабрујемо вас и да пробате да их погледате у неком од алата са којим сте већ упознати, на пример, подаци о летњим олимпијским играма:

<img src="sport_slike/letnje_igre_excel.jpg"
     width='600' />
     
Ако сте пробали да отворите овај фајл, вероватно сте сачекали мало док се табела није учитала. То је зато што је у питању фајл са преко 200 хиљада редова и свако прегледање скроловањем кроз табелу није претерано практично (ни забавно ;)). Уместо тога, у наставку курса ми ћемо табеле учитавати користећи библиотеку `pandas` на следећи начин:
```
import pandas as pd

letnje_igre = pd.read_csv("sport_podaci/letnje_olimpijske_igre_do_2014.csv")
letnje_igre.head()
```

<img src="sport_slike/pandas_head_letnje_igre.jpg"
     />

# import pandas as pd

# letnje_igre = pd.read_csv("sport_podaci/letnje_olimpijske_igre_do_2014.csv")
# letnje_igre.head()

Који год начин отварања табеле да сте искористили видите првих пар редова и колоне које садрже имена, пол, године, висину, масу, тим и слично за све учеснике олимпијских игара. У наставку ћемо на различите начине трансформисати ову табелу и на основу података из ње одговарати на питања и визуелно представљати наше закључке, па хајдемо!
## 2. Раст популарности и конкуренције на Олимпијским играма

Пре него што се упустимо у специфичнија питања која се тичу медаља, спортисткиња и спортиста, проверићемо како су се Олимпијске игре мењале кроз време. На основу података које имамо, можемо истражити како се мењао број земаља учесница игара, а затим и како се мењао број такмичарки и такмичара, број спортова и спортских дисциплина, број додељених медаља и слично.

Да ли имате неке претпоставке о овим бројевима? Да ли мислите да је број земаља опадао, растао, остао исти? А спортови? Да ли мислите да се списак спортова мењао током олимпијске историје? Слично, да ли очекујете да се број такмичарки и такмичара мењао?
*Размислите пар тренутака о овим питањима и одговорима који вам можда падају на памет на основу праћења медијских натписа или претходног интересовања за олимпијске игре.*

import pandas as pd # biblioteka za učitavanje i manipulaciju tabelarnih podataka
import matplotlib.pyplot as plt # biblioteka za vizuelizaciju podataka

<details>    
<summary>
    <font color="darkgreen"><b>На основу описа података у претходном поглављу, коју од табела очекујете да учитамо?</b></font>
</summary>
Учитаћемо табелу о историји летњих олимпијских игара која садржи податке о учесницима на олимпијадама почев од 1896 године.

Ову анализу ћемо спровести на летњим олимпијским играма (зимске игре можете анализирати на исти начин, чак користећи исту радну свеску са изменом овог дела кода при учитавању података), класичним учитавањем `.csv` фајла уз помоћ [pd.read_csv](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html) функције:

letnje_igre = pd.read_csv('sport_podaci/letnje_olimpijske_igre_do_2014.csv') #učitavanje podataka iz lokalnog foldera
letnje_igre.head(2) #pregled prva dva reda

Табела садржи уносе са појединачним такмичарима, учесницима игара, а нека од наших питања тичу се неких групних податаке, на пример колико је било укупно спортиста или држава у одређеној години, видећемо како то да решимо. За почетак погледајмо једну годину, нпр. 1988. Из тебеле можемо издвојити само део података који се тиче тих игара. То радимо коришћењем услова (нпр. `letnje_igre.Year==1988`) у угластим заградама табеле, хајде да видимо прво шта је резултат овог услова:

letnje_igre.Year==1988

Као што смо можда претпоставили, резултат ове команде је низ вредности тачно/нетачно зависно од тога да ли се у том реду табеле у колони године `Year` налази вредност 1988 (када је резултат `True`) или нека друга (када је резултат извршене операције `False`). Када се овај услов нађе у угластим заградама које прате име табеле (нпр. `letnje_igre[letnje_igre.Year==1988]`) резултат је исечак из табеле, тј. они редови из табеле за које је услов тачан:

# letnje_igre[letnje_igre.Year==1988] # cela tabela za koju je uslov tacan, probajte i ovo
letnje_igre[letnje_igre.Year==1988].head(5) # prvih pet redova izdvojene tabele da ne bismo zatrpali svesku ogromnom tabelom

Када је табела коју сте издвојили условом велика као ова, добијете само део приказа а ако скролујете до дна можете видети број редова.

Када издвајате делове табеле, типично користите синтаксу попут ове наведене изнад `ime_tabele[uslov]` где услов може бити једноставан као у претходном примеру (тачан садржај неке колоне), а може бити и низ услова за различите колоне. На исти начин може се издвојити и једна колона, тада у угластим заградама уместо услова користимо име колоне (нпр. `letnje_igre['Sport']`). Међутим у претходном примеру, колони смо приступали без угластих заграда тј. користећи `letnje_igre.Year`, што је мало краћи начин који је доступан када год у имену колоне нема неких недозвољених карактера (нпр. размак или други карактери које не бисте могли ставити ни у [име пајтон променљиве](https://petlja.org/biblioteka/r/lekcije/TxtProgInPythonSrLat/02_console-02_console_02_programs)).

Издвојене податке можемо сачувати у нову променљиву ако планирамо да истражимо још нешто за исту годину, на пример да видимо колико има вредности у свакој од колона користећи функцију [info](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.info.html):

letnje_igre1988 = letnje_igre[letnje_igre.Year==1988] # izdvajamo samo one redove kojima je vrednost u koloni godina (Year) jednaka 2016
letnje_igre1988.info(5) # prikaz informacija o sadržaju kolona nove tabele

Да бисмо сазнали колико тимова се такмичило, из ове табеле можемо издвојити различитe државe учеснице користећи функцију [unique()](https://pandas.pydata.org/docs/reference/api/pandas.unique.html) на колони `NOC`, тј. издвајамо јединствене вредности (енг. unique) националних организационионих комитета (енг. National Olympic Committee) који су послали своје представнике на олимпијске игре:

letnje_igre1988.NOC.unique() # jedinstvene vrednosti u koloni NOC letnjih igara 1988

Функције попут претходно примењене `unique` можете примењивати и овако `pd.unique(letnje_igre1988.NOC)` (где смо на почетак имена функције додали и скраћено име библиотеке `pandas` које смо додали при учитавању `pd`), форма коју смо искористили изнад ће бити чешће коришћена у наставку зато што је редослед примењивања функција прегледнији поготово када користимо више функција.

Док уопотребом фунције `len()` можемо добити дужину ове листе различитих националних комитета, тј. сазнати колико се различитих тимова такмичило на олимпијади 1988:

len(letnje_igre1988.NOC.unique())

Овај податак можемо потврдити интернет претрагом  или на [википедији](https://en.wikipedia.org/wiki/1988_Summer_Olympics) коју ћемо и у наставку често користити за додатну проверу информација или занимљивих чињеница о Олимпијским играма. Одабрали смо као извор википедију зато што су догађаји попут олимпијских игара такви да генеришу пуно интересовања и стога сваки чланак о играма има пуно независних аутора и уредника чланака па сматрамо да је веродостојност информација често вишестрано потврђена. Свакако када вас нека тема посебно заинтригира, истражите и листу извора на крају вики чланка или наставите даље са интернет претрагом.

Сада бисмо волели да видимо овај број (различитих нок тимова) за све године које имамо у подацима. То се може урадити тако што ћемо нпр. [`for` петљом](https://petlja.org/biblioteka/r/lekcije/TxtProgInPythonSrLat/02_console-02_console_10_scripting) пролазити кроз све доступне године и понављати претходни поступак и чувати резултате. Међутим, овде ћемо искортистити други метод који је својственији табеларним подацима и `pandas` библиотеци. У питању је функција груписања [groupby](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html) коју ћемо искористити да на основу табеле `letnje_igre` направимо низ подтабела које у свим својим редовима имају исту вредност године одржавања. То радимо овако `letnje_igre.groupby(['Year'])`. Међутим, ми не желимо да само групишемо податке по годинама, већ желимо да у оквиру сваке од тих подгрупа нађемо колико има јединствених националних комитета, што можемо и урадити:

letnje_igre.groupby(['Year'])['NOC'].unique() # na ovaj način dobijamo za svaku godinu listu jedinstvenih NOK-ova

Добили смо сада за сваку годину, листу јединствених националних олимпијских комитета, међутим, то нам је превише информација, ми заправо хоћемо само да знамо колико их је, не и који су. То можемо урадити уз помоћ функције [len](https://petlja.org/biblioteka/r/lekcije/TxtProgInPythonSrLat/02_console-02_console_13_list), али зато што хоћемо да знамо дужину листе за сваку годину, тј. у свакој ћелији ове мале табеле, то у оквиру `pandas` библиотеке можемо урадити функцијом [`apply`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.apply.html). Ова функција је моћан алат зато што нам дозвољава да разне друге функције које смо или ми написали или знамо да већ постоје применимо на сваку ћелију у колони табеле (или шире). Не брините ако вам ово сад звучи као да је превише, лако ћете се навићи на то, за сад можете само прочитати ове команде као низ инструкција - издвоји листу јединствених комитета и примени (енг. *apply*) функцију која рачуна дужину - и то је управо то што радимо:

broj_nok = letnje_igre.groupby(['Year'])['NOC'].unique().apply(len) # korišćenjem apply(len) komuniciramo da u svakom redu treba nad listom u ćeliji primeniti funkciju len
broj_nok.head()

Резултат `groupby` фунције је увек табела индексирана по колони која је задата за груписање, у овом случају пошто поред индекса постоји само једна колона са подацима у питању је тип података [серија](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html) (практично табела која има само једну колону), што можете видети овако:

type(broj_nok)

Хаје да већ ове податке које смо пребројали нацртамо и кренемо у дискусију о визуализацији података од једноставнијих графика. За цртање у наставку користићемо олимпијске боје из логоа:
<img src="sport_slike/Olympic_flag.svg" alt="alt text" width="200"/>
За увод о коришћењу боја у пајтону, можете погледати [овај линк](https://petlja.org/biblioteka/r/lekcije/pygame/crtanje-cas1), али типично ћемо боје задавати или користећи њихова имена (попут `red`, `grey`, али и `tomato`, `оlive`, листу именованих боја у оквиру `matplotlib` библиотеке можете пронаћи [овде](https://matplotlib.org/stable/gallery/color/named_colors.html)) или користећи хексадекадни код (шест карактера од 0 до F који једнозначно указују на жељену боју) боја који можете пронаћи на пример [овде](https://g.co/kgs/fRV97K). Олимпијске боје које смо пронашли ћемо сачувати у променљиве за даље коришћење:

#definišemo boje koje ćemo koristiti u nastavku:
olimpijska_plava='#0286c3'
olimpijska_zuta='#fbb22e'
olimpijska_crna='#000000'
olimpijska_zelena='#168c39'
olimpijska_crvena='#ee2f4d'

Број земаља које су се такмичиле сваке олимпијске године можемо и представити линијским дијаграмом у оквиру `pandas` библиотеке функцијом [plot](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html). Подразумевани график, када се користи ова функција, је линијски дијаграм који повезује све податке:

# osnovna slika
broj_nok.plot() # funkcija plot crta linijski dijagram, a dodatno smo definisali oblik markera i boju linije i markera
plt.show() # prikaz dobijenog grafika

Када су подаци само спојени није лако схватити који су то били тренуци у којима је дошло до њиховог бележења (у овом случају године одржавања Олимпијских игара). То није згодно зато што заваравамо читаоца који може помислити да се Олимпијске игре одржавају сваке године, а можда и чешће!
Зато је згодно да на линијским дијаграмима (поготово када немате пуно тачака) истакнете кружићима (или другим ознакама) тачне позиције забележених податка. Свака истакнута тачка је пар из наше табеле - година (х координата) и број држава које су се такмичиле (у координата). Истицање дефинишемо прослеђивањем жељене ознаке кроз аргумент функције `marker`. Све остале тачке (дуж нацртане линије) нису део података, већ линије које спајају наше податке:

# dodavanje boje i oznaka
broj_nok.plot(marker='o',color=olimpijska_crvena) # funkcija plot crta linijski dijagram, a dodatno smo definisali oblik markera i boju linije i markera
plt.show() # prikaz dobijenog grafika

Додали смо и олимпијску црвену боју овој линији! Предност функције `plot` у оквиру `pandas` библиотеке је што на основу података већ закључује неке ствари и тако иако нисмо дефинисали име х осе, на основу имена колоне смо добили ознаку 'Year'. Међутим, ми бисмо волели да су имена оса на српском језику, па ћемо именима х и у осе дати мало описнија имена уз помоћ функција [xlabel](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.xlabel.html) и [ylabel](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.ylabel.html) библиотеке `matplotlib.pyplot` (чије смо име при учитавању скратили на `plt` па је сада само то име потребно написати испред функција):

broj_nok.plot(marker='o',color=olimpijska_crvena) # funkcija plot crta linijski dijagram, a dodatno smo definisali oblik markera i boju linije i markera
#dodavanje naziva x i y ose
plt.xlabel('Година одржавања Олимпијских игара')
plt.ylabel('Број земаља учесница Олимпијских игара') # dodajemo ime u ose
plt.show() # prikaz dobijenog grafika

Иако нам се чини да већ на овом графику вредности на у оси почињу од 0 (или барем од вредности врло близу 0), често је згодно експлицитно обезбедити да је то тачно, тј. да је 0 на у оси део приказаног графикона. Обезбедићемо то у наставку функцијом [ylim](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.ylim.html) и додати усправне линије на позицији пар важних година:

broj_nok.plot(marker='o',color=olimpijska_crvena) # funkcija plot crta linijski dijagram, a dodatno smo definisali oblik markera i boju linije i markera
plt.xlabel('Година одржавања Олимпијских игара')
plt.ylabel('Број земаља учесница Олимпијских игара') # dodajemo ime у ose

plt.ylim(0) # biramo da u osa počinje od 0

# dodajemo uspravne linije za godine kada znamo da su Olimpijske igre otkazane zbog svetskih ratova
plt.axvline(1916,color=olimpijska_crna) 
plt.axvline(1940,color=olimpijska_crna)
plt.axvline(1944,color=olimpijska_crna)

plt.show() # prikaz dobijenog grafika

Видимо да је током већег дела историје Олимпијских игара број држава учесница растао, што је можда и очекивано што због раста популарности игара, што због настајања нових држава током двадесетог века. Међутим, видимо и пар тачака када се одступа од овог тренда а ради се о Олимпијским играма 1976 и 1980 када је било значајно мање земаља учесница. Ово може бити сигнал да нешто није у реду са нашим подацима. Mеђутим, верни пратиоци и познаваоци Олимпијских игара ће знати да нема проблема у подацима - из различитих политичких и економских разлога је преко двадесет (1976) и преко шездесет (1980) земаља бојкотовало учешће у Олимпијским играма, више о томе можете прочитати [овде](https://en.wikipedia.org/wiki/1980_Summer_Olympics_boycott).

Усправне црне линије су додате за године када су планиране олимпијске игре али се нису догодиле због светских ратова.

<details>    
<summary>
    <font color="darkgreen"><b>На сличан начин можемо истражити како се мењао број такмичарки и такмичара на олимпијским играма. Ако испратимо логику груписања по години и бројања уникатних уноса у овом случају користећи колону име, наићи ћемо на проблем, имате ли идеју који?
        </b>
</font>
</summary>
Иако то није превише често, дешава се да више различитих особа има исто име и презиме. 

Издвојимо све уносе у табели који у колони име `Name` имају вредности "Иван Иванов". Зарад лакшег прегледа, овај сегмент табеле сортирамо по колони година користећи функцију [sort_values](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html):

letnje_igre[letnje_igre.Name =='Ivan Ivanov'].sort_values(by='Year') 

Видимо у подацима више уноса који садрже податке о спортисти Ивану Ивановом. Користећи остале информације на располагању (попут висине, масе, година, припадности тиму) видимо да је у случају Олипијских игара у Сиднеју, у питању једна иста особа која се такмичила у више категорија, док на пример у случају Олипијских игара 1972. године видимо да су у питању две особе. Када бисмо спровели груписање по години и бројали јединствена имена, за сваку од ових година (1972,2000,2008) бисмо издвојили само једног Ивана Иванова и тиме бисмо заборавили на једну особу која се такмичина 1972 године. Видите то у овом малом примеру:

ivan_ivanov = letnje_igre[letnje_igre.Name =='Ivan Ivanov'] # izdvajamo podatke o sportistima koji se zovu Ivan Ivanov i čuvamo ih u novoj promenljivoj
ivan_ivanov.groupby('Year')['Name'].unique().apply(len) # grupišemo po godini i brojimu jedinstvena imena, što bi nam bila prva ideja da izbrojimo učesnike igara 

Међутим, у примеру табеле са подацима о спортистима који се зову Иван Иванов, можемо приметити постојање колоне `ID` која је јединствени идентификатор за особе које су учествовале на Олимпијским играма. Видимо да две различите особе које смо идентификовали са истим именом Иван Иванов имају различиту вредност у овом пољу, док уноси које смо идентификовали као оне који одговарају истој особи (користећи податке о маси, годинама и слично) имају исте `ID` вредности.
Стога ћемо за бројање спортиста учесника Олимпијских игара избројати груписањем по колони `ID`:

broj_osoba_na_oi = letnje_igre.groupby(['Year'])['ID'].unique().apply(len) # grupisanje na osnovu godine i prebrojavanje razlicitih ID vrednosti
plt.stem(broj_osoba_na_oi.index,broj_osoba_na_oi, linefmt='k',markerfmt='ko',basefmt='k') # crtanje stem (lizalica) dijagrama
plt.xlabel('Година одржавања летњих олимпијских игара') # ime x ose
plt.ylabel('Број такмичарки и такмичара на ОИ') # ime y ose
plt.show()

Видимо да је и број такмичарки и такмичара на олимпијским играма током већег дела времена растао. Чак пад у броју различитих земаља учесница који смо видели у годинама 1976 и 1980 изгледа далеко мање у овим подацима (вероватно је број учесника по земљама био већи, како бисмо то проверили?).

На претходном графику (на коме смо приказали број држава учесница олипијских игара) спајањем тачкица могла вам је промаћи информација о томе колико често се дешавају летње олимпијске игре. Са овом врстом визуализације која се популарно зове и "лизалица" (енг. *lollipop*) доста лакше примећујемо да су свака две уноса (два одржавања олимпијских игара) једнако удаљена (што ако пратимо ОИ већ знамо да износи 4 године), али и лакше примећујемо периоде кад се игре нису одржале, или када су се одржале нешто пре него што је "требало". Ако погледате сам почетак 20. века, видимо да је густина лизалица нешто већа него касније, хајде да видимо када су се одржавале олимпијске игре тада:

data_segment = letnje_igre[(letnje_igre.Year>1900)&(letnje_igre.Year<1920)] # izdvajamo samo OI između 1900 i 1920 god
data_segment.Year.unique() # u izdvojenom segmentu podataka, tražimo jedinstvene vrednosti u koloni godine:

Видимо да постоје олимпијске игре одржане 1906 године, које нарушавају четворогодишњу периодичност. Ово опет може бити извор дилеме да ли су подаци веродостојни, али википедија нам опет може помоћи да научимо да су се [олимпијске игре заиста одржале и 1906 године](https://en.wikipedia.org/wiki/1906_Intercalated_Games) у Атини.

Претходно искоришћени лизалица график ([`plt.stem`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.stem.html)) је заправо доста сличан стубичастом дијаграму који бисте такође могли нацртати (користећи функцију [`plt.bar`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.bar.html)). Оно што је различито је постојање маркера на врху стубића који помажу да испратимо евентуални тренд међу подацима (за шта смо претходно користили спајање тачкица). Дијаграми који комбинују линије и тачкице попут лизалица графика су често корисни и да прикажемо како се разлика између неке две вредности повећава или смањује тако што ћемо цртати дужи са маркерима на обе стране. Подаци о такмичарима и такмичаркама су баш такви подаци, хајде да их нацртамо и видимо како то изгледа.

За почетак ћемо направити одговарајуће подскупове користећи вредност у колони пол (енг. *Sex*), а затим применити исто груписање и бројање јединствених учесника по колони `ID`:

takmicari = letnje_igre[letnje_igre.Sex=='M'] # izdvajamo redove tabele u kojima je u koloni pol M
broj_takmicara_oi = takmicari.groupby(['Year'])['ID'].unique().apply(len) # primenjujemo grupisanje po godini i brojanje jedinstvenih takmičara

takmicarke = letnje_igre[letnje_igre.Sex=='F'] # izdvajamo redove tabele u kojima je u koloni pol F
broj_takmicarki_oi = takmicarke.groupby(['Year'])['ID'].unique().apply(len) # grupisanje po godini i brojanje jedinstvenih takmičarki

Ове податке ћемо сада представити користећи комибинацију функција [vlines](https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.pyplot.vlines.html) (за цртање усправних линија) и [scatter](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.scatter.html) (за цртање тачкастих дијаграма). Усправне линије ћемо нацртати тако да им х координата одговара години одржавања олимпијских игара, а крајње у координате одговарају броју такмичарки, односно такмичара. Коначно, на крајеве ових дужи ћемо додати кружиће (чије х и у координате одговарају годинама и бројевима такмичара, односно такмичарки) да бисмо разлику учинили још уочљивијом:

# crtamo uspravne linije za sve održane olimpijske igre 
plt.vlines(x=broj_takmicarki_oi.index, ymin=broj_takmicarki_oi, ymax=broj_takmicara_oi.loc[1900:], color='grey', alpha=0.4)
# broj takmičara crtamo tačkicama (h osa godina, u osa njihov broj te godine)
plt.scatter(x = broj_takmicara_oi.index, y = broj_takmicara_oi, color=olimpijska_zuta, alpha=1, label='такмичари') 
# broj takmičarki crtamo tačkicama druge boje (h osa godina, u osa broj takmičarki te godine)
plt.scatter(x = broj_takmicarki_oi.index, y = broj_takmicarki_oi, color=olimpijska_zelena, alpha=1, label='такмичарке') 

# dodajemo imena x i y ose i legendu
plt.xlabel('Година одржавања Олимпијских игара')
plt.ylabel('Број учесника ОИ по половима')
plt.legend()
plt.show()

Зависно од тога шта желите да комуницирате као главну поруку података ову исту информацију можете нацртати и било којим од претходних графика - број такмичара и такмичарки можете представити линијским дијаграмом, или стубићима (или лизалицама). Међутим овај избор поред тога што приказује како се број појединачних група мењао кроз време, што видимо пратећи кружиће одговарајуће боје, нам јасније истиче њихову разлику (сиве линије) и приказује како се она мењала кроз време.

Анализирајући претходне податке, видимо да су у првој години одржавања Летње олимпијске игре биле намењене само мушкарцима, док је са наредним догађајем број жена почео да расте. На графику видимо да је број жена с почетка врло споро растао, то јест иако су игре брзо почеле да расту (и као што смо видели привлаче све више држава учесница), значајно више је растао број мушких учесника. Интересантно је такође приметити да је пораст броја такмичарки доста стабилнији, док је број такмичара некад растао а некад опадао - видите на пример значајан пад броја такмичара на олимпијадама 1932 и 1956 године, то може бити у вези са ратовима који су претходили или другим историјским дешавањима попут Велике депресије (1932) и Суецке кризе (1956). 

Предност овог графика је што истовремено видимо и тачан број такмичара и такмичарки и линијом истакнуту њихову разлику. Међутим, разлика између учесника два пола од 1000 нема исто значење када је укупан број учесника 1002 (тј. такмиче се једна жена и 1001 мушкарац), и када их је 10000 (тј. такмичи се 4500 жена и 5500 мушкараца). За ово је погодније уместо бројева мушкараца и жена погледати проценуалне заступљености једне и друге групе. Тако ћемо далеко јасније сагледати да ли се јаз између броја мушких и женских учесника олимпијаде смањује.

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Израчунати који проценат учесника олимпијаде су мушког, а који женског пола и репродукујте график у наставку.</div> 

# resenje zadatka, uklonite znake za komentar

# procenat_takmicara = 100*broj_takmicara_oi/broj_osoba_na_oi
# procenat_takmicarki = 100*broj_takmicarki_oi/broj_osoba_na_oi

# plt.vlines(x=procenat_takmicarki.index, ymin=procenat_takmicarki, ymax=procenat_takmicara, color='grey', alpha=0.4)
# plt.scatter(x = procenat_takmicara.index, y = procenat_takmicara, color=olimpijska_zuta, alpha=1, label='такмичари')
# plt.scatter(x = procenat_takmicarki.index, y = procenat_takmicarki, color=olimpijska_zelena, alpha=1, label='такмичарке')

# plt.axhline(y=0,color='grey',alpha=0.2)
# plt.axhline(y=50,color='grey',alpha=0.2)
# plt.axhline(y=100,color='grey',alpha=0.2)
# plt.xlabel('Година одржавања Олимпијских игара')
# plt.ylabel('Порценат учесика мушког и женског пола')
# plt.legend()
# plt.savefig('sport_slike/OI_procenat_zm.png',dpi=300)
# plt.show()

<img src="sport_slike/OI_procenat_zm.png" width="500" align='left'/>

На овом графику сада далеко јасније можемо видети да се током последњих пар деценија проценат такмичарки и такмичара значајно приближио. Графику смо додали и сиве водоравне линије да означимо минималне и максималне вредности и једнаку заступљеност такмичарки и такмичара. Како проценат такмичарки и такмичара у збиру мора бити једнак 100%, могли смо приказати само једну од категорија података, она друга је имплицитно срачуната, то се на овом графику види и на основу симетричног распореда тачкица - што се више проценат мушкараца удаљава од вредности 100% то се проценат жена повећава. Истичући процентуалну разлику сивом усправном линијом додатно смо послали визуелну поруку о смањењу јаза међу заступљеностима група.

Овде је битно напоменути да ми нисмо гледали награђене учеснике и учеснице, већ број особа оба пола који су уопште имали прилику да се такмиче што говори о системским баријерама које су постојале и даље постоје да се и жене такмиче на олимпијским играма. 

Много је различитих разлога заслужно за овакав однос међу бројевима, од тога да у старту олимпијске игре нису биле отворене за жене (попут првих), преко тога да се у неким спортовима тек много касније појавила женска категорија (тек од 2012. године у свим спортовима постоји и женска категорија, али не и у свим дисциплинама), до тога да и када постоје могућности за такмичење за оба пола неке државе нису имале своје представнице (тек 2012. године су све државе које су део интернационалонг олимпијског комитета имале и представнике и представнице на олимпијским играма). Неке од ових ствари можете наставити да истражујете у овом скупу података (нпр. када је који спорт додао и женску категорију, како је мењао број дисциплина у којима се додељују медаље а које су само за мушкарце или само за жене), а неке су дубље културолошки обрасци које морамо испитивати на другим местима. Више о овој теми и повезаним питањима на које можете потражити одговоре у овим подацима можете прочитати [овде](https://en.wikipedia.org/wiki/Participation_of_women_in_the_Olympics).

# resenje o brojevima Menonly i Womenonly eventova

# broj_disciplina = letnje_igre.groupby(['Year'])['Event'].unique().apply(len)
# plt.plot(broj_disciplina.index, broj_disciplina, drawstyle='steps-mid',color=olimpijska_crna)

# broj_disciplina_za_muskarce = letnje_igre[letnje_igre.Event.str.contains('Men')].groupby(['Year'])['Event'].unique().apply(len)
# plt.plot(broj_disciplina_za_muskarce.index, broj_disciplina_za_muskarce, drawstyle='steps-mid',color=olimpijska_zuta)

# broj_disciplina_za_zene = letnje_igre[letnje_igre.Event.str.contains('Women')].groupby(['Year'])['Event'].unique().apply(len)
# plt.plot(broj_disciplina_za_zene.index, broj_disciplina_za_zene, drawstyle='steps-mid',color=olimpijska_zelena)

Сличним методама груписања и бројања можемо истражити и број такмичарских догађаја (колона `Event`, енг. за догађај) у којима се такмичари боре за медаље. Овим бројањем добићемо практично и информацију о броју медаља, ако о кошаркашкој медаљи (или било ком тимском спорту) размишљамо као о једној медаљи за тим, а не као о 5 индивидуалних медаља које сви чланови тима добијају.
То радимо бројећи јединствене вредности у колони `Event`, погледајмо прве вредности ове колоне:

letnje_igre['Event'].head() # ovde smo kolonu pozvali koriscenjem uglastih zagrada, isto radi i letnje_igre.Event

Понављамо исти метод груписања и бројања, а затим ћемо нацртати податке, овај пут користећи `plt.bar`:

broj_disciplina = letnje_igre.groupby(['Year'])['Event'].unique().apply(len) # broj jedinstvenih takmicarskih dogadjaja u okviru olimpijskih igara

plt.bar(broj_disciplina.index, broj_disciplina, color=olimpijska_plava) # crtamo stubicasti dijagram
plt.xlabel('Година одржавања Олимпијских игара') # ime x ose
plt.ylabel('Број такмичарских дисциплина') # ime y ose
plt.show()

На последњем графику смо испробали још једну опцију визуализације ових временски променљивих података - стубичасти дијаграм. Функцији `bar` проследили смо 2 аргумента (слично као и код претходних функција за цртање), међутим за разлику од `plot` или `scatter` функције код које х координате морају бити нумерчког типа, овде је могуће искористити и категоричке податке на х оси. Међутим, у нашем случају х координате су године одржавања ОИ, стога их и функција за цртање стубића смешта на бројевну праву и поставља одговарајући размак између њих. Због чињенице да имамо преко 20 стубића који су удаљени углавном по 4 године, ширина стубића у овој основној верзији је јако мала, па је мала разлика између овог дијаграма и лизалица које смо цртали раније. Ако међутм искористимо стубичасти дијаграм са `plot` функцијом у оквиру `pandas` библиотеке коришћењем аргумента `kind='bar'` можемо видети да су стубићи шири и једнако удаљени један од другог:

broj_disciplina.plot(kind='bar', color=olimpijska_plava) # crtamo stubicasti dijagram
#i ovo je jedna moguca opcija za prakticno isti dijagram, samo sa drugom bibliotekom plt
#plt.bar(broj_disciplina.index.astype(str), broj_disciplina) 
#plt.xticks(rotation='vertical') # ako iskoristite plt.bar za crtanje, morate iskoristiti i ovu funkciju za rotaciju naziva podeoka na x osi da biste mogli da ih procitate 
plt.xlabel('Година одржавања Олимпијских игара') # ime x ose
plt.ylabel('Број такмичарских дисциплина') # ime y ose
plt.show()

То је зато што у овом случају индексна колона, тј. година одржавања није интерпретирана као број који треба сместити на бројевну праву, већ као назив стубића који је обележен испод сваког стубића. И ово може бити ок приказ ако желимо само да демонстрирамо да је број медаља, тј. дисциплина из којих се додељују медаље, углавном растао током историје олимпијских игара. Треба само бити опрезан око тога да смо на овај начин изгубили информацију о томе да се олимпијаде нису одржавале током ратних година (само ће врло пажљив читалац загледати да ли су вредности година на х оси увек удаљене 4 године једна од друге).

Интересантно је да број дисциплина, односно спортских такмичење у којима се додељују медаље правилније расте и од броја такмичара и од броја држава учесница. Обратите пажњу овде нема толико наглих падова попут година 1980 када је забележен пад држава учесница, или у непосредној близини ратних година као што смо видели у бројевима такмичара. Разлог томе лежи у чињеници да се спортске дисциплине и медаље планирају у организацији Олимпијских игара, независно од тога колико ће се држава појавити у такмичењу (да ли ће неке бојкотовати или не) и колико ће такмичара различите земље послати. Можемо видети да се број медаља стабилизовао тек у последњих пар летњих олимпијских игара које разматрамо у овој анализи.

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Претходно смо пребројали дисциплине у којима се додељују медаље, али у неким дисциплинама то значи да само једна особа добија златну медаљу (нпр. маратон), док у некима то значи да цео тим (нпр. тим одбојкашица) добија по медаљу. Како бисте израчунали колико тачно медаља (нпр. само златних) су припремили организатори сваких летњих олимпијских игара?</div> 

# # resenje

# zlatne_medalje = letnje_igre[letnje_igre.Medal=='Gold']
# zm_god = zlatne_medalje.groupby('Year').size()
# plt.plot(zm_god,marker='o', color=olimpijska_plava)
# plt.show()

# # izgleda da je 20ih bilo dosta vise grupnih sportova, to se moze proveriti i koliko je vise medalja u odnosu na discipline
# #zm_god2 = zm_god/broj_disciplina
# #plt.plot(zm_god2,marker='o')

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Користећи исте методе груписања и бројања, како бисте издвојили 10 спортиста који су освојили највише (златних) медаља?</div> 

# # resenje
# # lista id-jeva
# letnje_igre[letnje_igre.Medal.isin(['Gold','Silver','Bronze'])].groupby("ID").size().sort_values(ascending=False)[:10]

# #resenje
# #pregled jednog od id
# letnje_igre[letnje_igre.ID==67046]

# # resenje
# # grupisanje po dve kolone, ali to objasnjavamo tek u sledecoj lekciji
# letnje_igre[letnje_igre.Medal.isin(['Gold','Silver','Bronze'])].groupby(["ID",'Name']).size().sort_values(ascending=False)[:10]
## 3. Како се популарност спортова мењала кроз време?

Бројали смо колико је укупно било такмичара и такмичарки сваке године и слично колико је спортских дисциплина било сваке године, хајде да закомпликујемо бројање тако што ћемо видети колико је било такмичара у сваком спорту сваке године. Можда сте приметили или чули од старијих и вернијих пратилаца олимпијских игара да се неки спортови додају, неки одузимају, приметили сте можда и да нису сви једнако популарни - негде је конкуренција врло велика, а негде се свега пар такмичара бори за медаљу. Стога можемо поставити питања који су то све спортови били (и који су и даље) у оптицају на летњим олимпијским играма, колико такмичара се бори за медаље у сваком од спортова, и како се та популарност спортова мењала кроз време. 

Наставићемо да радимо користећи податке за летње олимпијске игре, али вас охрабрујемо да исти код тестирате и на фајлу са подацима о зимским играма и упоредите добијене резултате.

import pandas as pd # biblioteka za učitavanje i manipulaciju tabelarnih podataka
import matplotlib.pyplot as plt # biblioteka za vizuelizaciju podataka
import seaborn as sns # biblioteka za vizuelizaciju podataka
import plotly.express as px # biblioteka za interaktivnu viz podataka

letnje_igre = pd.read_csv('sport_podaci/letnje_olimpijske_igre_do_2014.csv') #učitavanje podataka iz lokalnog foldera, ovu liniju treba izmeniti za preuzimanje podataka o zimskim igrama

Да бисмо избројали спортисте по годинама и спортовима, искористићемо као и пре функцију груписања [groupby](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.groupby.html), али овај пут групишемо по 2 колоне, по години и спорту (`'Year','Sport'`):

broj_takmicara_po_sportu = letnje_igre.groupby(['Year','Sport']).size()
broj_takmicara_po_sportu.head()

Као и у случају груписања по једној колони, и сада се за сваку комбинацију вредности (нпр. година 1896 и спорт гимнастика, или година 2012 и спорт атлетика) прави једна група, подтабела, за коју је важи да сви редови те подтабеле имају исту вредност у колонама година и спорт. Овај пут смо из тих подтабела уместо једиствених вредности само тражили величину подгрупе, функцијом [size](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.size.html). Алтернативно, могли смо као и у претходној лекцији да бројимо јединствене такмичаре (користећи колону `ID`) и на тај начин бисмо избегли дупло бројање једног такмичара који се можда такмичи и у трчању на 100m и у трчању на 200m. Овде смо одлучили да избројимо све учеснике свих догађаја у оквиру спортова да бисмо на тај начин оценили величину и конкуренцију у догађајима и у том смислу нам је ок да бројимо такмичаре више пута. Једно оправдање за то видимо и на пример из улоге организатора такмичења који мора да припреми догађај за одређен број људи и организатору није претерано битно да ли се дати такмичар такмичи на још једном догађају. Друга алтернатива је и да за сваки спорт избројите колико различитих држава се такмичило у оквиру датог спорта, чиме ћете занемарити чињеницу да се неке државе такмиче у пуно под дисциплина, или да некад шаљу више тимова у оквиру истог спорта.

Резултат груписања као и претходно је један низ вредности, који овај пут има 2 индексне колоне (оне које смо користили за груписање). Међути, често нам је за рад згодније да баратамо табелом а не колоном са 2 индекса ([pandas.DataFrame](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html) насупрот [pandas.Series](https://pandas.pydata.org/docs/reference/api/pandas.Series.html)) и то можемо решити ресетовањем индекса ([reset_index](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.reset_index.html)):

broj_takmicara_po_sportu = broj_takmicara_po_sportu.reset_index()
broj_takmicara_po_sportu.head()

Сада индексна колона садржи бројеве од 0, док су година и спорт постали колоне са којима можемо даље да баратамо. Колона која чува наше пребројане вредности (спортисте који су се дате године такмичили у датом спорту) има назив 0 тако да хајмо то прво да променимо уз помоћ функције [rename](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.rename.html). Обратите пажњу да функција `rename` као и неке друге функције којима вршите замене у табели, очекује да су вредности прослеђене у облику пајтон речника, тј. у формату `{sta_treba_zameniti : cime_zameniti}`, више о речницима видите [овде](https://petlja.org/biblioteka/r/lekcije/TxtProgInPythonSrLat/02_console-02_console_16_dict).

broj_takmicara_po_sportu = broj_takmicara_po_sportu.rename(columns={0:'Broj_sportista'})
broj_takmicara_po_sportu.head()

Супер, добили смо мању табелу која садржи све информације које смо хтели - за сваку годину, имамо све тада активне спортове и број такмичара у сваком од њих. Међутим, оваква табела у колонама има пуно поновљених вредности - то видите већ у првих 5 редова које смо приказали, година 1896 се понавља, док се спортови смењују. Слично, и у колони спорт се нпр. атлетика појављује сваки године када је атлетика била на олимпијским играма. Некада је овај формат згоднији (доста функција тако лакше искористи једну од колона за бојење тачкица или других објеката на графицима) и често се зове дуги формат (енг. *long data*) зато што има мало колона са пуно вредности. Насупрот њему, некад, као сада, је згодније представити податке у широком (енг. *wide data*) формату, тако што препознамо да је за сваки број спортиста битно да знамо која година и који спорт су у питањју. То значи да уместо да се неке године понављају у колони, можемо колоне индексирати годинама, а редове спортовима. Tако ће свака ћелија у новој табели бити јединствено одређена комбинацијом спорта и године и у ту ћелију уносимо број спортиста из одговарајуће колоне.

Овај процес, пребацивања дуге табеле са поновљеним вредностима у широку табелу која две дате колоне користи да индексира врста и колоне зове се пивотирање табеле и то можемо урадити функцијом [pivot](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pivot.html).

broj_takmicara_po_sportu_p = broj_takmicara_po_sportu.pivot(index='Sport',columns='Year',values='Broj_sportista') #pivotiranje tabele i cuvanje u novu promenljivu
broj_takmicara_po_sportu_p.head() #prikaz pivotirane tabele

Аргументима функције `pivot` одабрали смо које податке ћемо користити за редове наше широке табеле (аргумент `index`), а које за колоне (аргумент `columns`), a које вредности ће се наћи у одговарајућим ћелијама када се укрсти права вредност колоне и врсте дефинисали смо аргументом `values` (вредности на енглеском). У првих 5 редова ове нове табеле које смо приказали можете приметити да има пуно непостојећих вредности, означених са `NaN` (енг. *not a number*). 
<details>    
<summary>
    <font color="darkgreen"><b>Шта мислите зашто је то тако?</b>
</font>
</summary>
Као што сте можда претпоставили, одређени спортови нису постојали на неким летњим олимпијским играма. То је било ок у дугом формату података, зато што су редови у табели постојали само када је одређен спорт био присутан на одређеним летњим олимпијским играма. Међутим када смо направили широки формат табеле, све комбинације спорта и године добиле су своју ћелију табеле, те су све оне комбинације године и спорта које нису могле бити попуњене вредностима из колоне `Broj_sportista` добиле вредност `NaN`. Из овог разлога су подаци чувани у дугом фомату меморијски ефикаснији зато што се чувају само одреднице које имају вредност, не и све могуће комбинације.

Сада ћемо нашу широку табелу података и нацртати. За то ћемо искористити функцију [heatmap](https://seaborn.pydata.org/generated/seaborn.heatmap.html) библиотеке [seaborn](https://seaborn.pydata.org/) (чије смо име при учитавању скратили у `sns`):

sns.heatmap(broj_takmicara_po_sportu_p)
plt.show()

У основном облику, ова функција нам је визуелно представила табелу података - вредности које су светлије одговарају комбинацијама године и спорта када је било пуно такмичара, док су тамне вредности оне комбинације за које је било јако мало такмичара (видите стубић са легендом са стране). Додатно, све вредности које не постоје су овде представљене белом бојом, што је коректно зато што тако обавештавамо гледаоца да није у неким периодама било јако мало такмичара у неком спорту, већ да тај спорт није постојао током тих година. 

Међутим, главна мана овог основног прегледа података је што не видимо ни све године, ни све спортове на осама. Такође, ни овај подразумевани избор боја није сјајан зато што не можемо лако разликовати нијансе, а и бела боја која одговара непостојећим вредностима је превише близу нијанси која одговара максималним вредностима. Стога ћемо кренути у поправљање овог графика да бисмо боље представили прикупљене податке. Прво ћемо повећати простор за цртање користећи фунцкију [plt.figure](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.figure.html) и дефинишући димензије слике аргументом `figsize` (претпостављене јединице датих димензија су у инчима):

plt.figure(figsize=(8,10)) # velicina slike
sns.heatmap(broj_takmicara_po_sportu_p)
plt.show()

Сада видимо све колоне и врсте присутне у табели коју цртамо. Следећи проблем који поправљамо је одабир друге палете боја која ће учинити визуализацију мало пријатнијом. 

Додатно ћемо зарад лакшег сагледавања информација додати водоравне и усправне линије да још лакше испратимо популарност спорта кроз време:

plt.figure(figsize=(8,10))
sns.heatmap(broj_takmicara_po_sportu_p,cmap='Oranges',linewidths=1, linecolor='lightgrey')
plt.show()

Сада су бели региони они за које нема података, док су бојом различитих интензитета означени популарнији (тамнијом бојом) и мање популарних (светлијим нијансама) спортови у одређеним годинама. Листу доступних палета можете видети [овде](https://matplotlib.org/stable/tutorials/colors/colormaps.html). *Опрезно са овим изменама боје којим смо драстично ублажили истицање непостојећих података. Кад год доносите одлуку овог типа обратите пажњу да ли гледаоца доводите у заблуду. У овом случају, визуализацију ћемо користити да уочимо популарне спортове и периоде када су више популарни, тако да немамо потребу да правимо јаку разлику између периода кад спортови постоје са врло мало такмичара или не постоје на олимпијским играма.* 

На овом графику видимо да су најинтензивније боје везане за спортове попут атлетике, гимнастике и пливања. Неки спортови су присутни готово све време (то можда лакше видимо на претходном дијаграму) попут бициклизма, рвања, ватерпола... Међутим, на овим графицима видимо и један изненађујући "спорт" који је привукао доста такмичара током тридесетих година прошлог века - уметничка такмичења (на енглеском *art competitions*). Ако нисте велики познаваоци историје олимпијских игара (као ауторка овог текста) у овом тренутку сте сигурни да су подаци потпуно погрешни, међутим, [википедија](https://en.wikipedia.org/wiki/Art_competitions_at_the_Summer_Olympics) је још једном ту да нас разувери. Уметничка такмичења су постојала у 5 области (музика, књижевност, сликарство, архитектура и скулптура), а уметници су креирали дела на теме инспирисане спортом. Током историје Олимпијских игара, постојале су само две особе које су биле награђене и у спортским и у уметничким такмичењима (како бисте нашли њихова имена?).

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Како бисте истражили број учесника у појединачним догађајима у оквиру уметничких такмичења?.</div> 

# # resenje
# umetnici = letnje_igre[letnje_igre.Sport=='Art Competitions'].groupby(['Year','Event']).size().reset_index()
# umetnici = umetnici.rename(columns={0:'Broj_takmicara'})
# umetnici_p = umetnici.pivot(index='Event',columns='Year',values='Broj_takmicara') 
# sns.heatmap(umetnici_p,cmap='Oranges',linewidths=1, linecolor='lightgrey')
# plt.show()

Овакве визуализације, помажу нам да заједно сагледамо различите спортове. Сваки ред ове шарене табеле може се представити различитим графицима које смо дискутовали раније (линијски, тачкицама, лизалицама или стубићима), међутим ако бисмо више линија за све ове спортове ставили заједно добили бисмо један хаотичан график са превише линија једних преко других са којима је тешко било шта закључити. Насупрот томе, на овај начин се можемо видети да је атлетика имала најмање такмичара у истој години када су уметничка такмичења имала највише такмичара, да је стрељаштво имало своје успоне и падове, да је тенис у једном тренутку потпуно нестао а затим се вратио и слично.

Међутим, овакви графици имају и своје проблеме - на пример, јако је тешко гледајући график оценити да ли је на олимпијским играма било више бициклиста или веслача. То је зато што је наши механизми перцепције боја зависе од окружења, сигурно сте видели оптичке илузије попут [ове](https://en.wikipedia.org/wiki/Checker_shadow_illusion). Стога овакве графике не треба користити ако желите да читалац процени тачне вредности или упореди вредности врло удаљених квадратића, они су добри за оцене генералних трендова, идентификацију популарнијих и мање популарних спортова и година, али треба бити свестан и њихових лимита.

Један начин да превазиђемо проблем очитавања вредности је да овај график нацртамо у интерактивном фомату и тако дозволимо да корисници преласком миша преко одређеног поља провери вредности које их занимају. Библиотека коју користимо за интерактивне садржаје је [plotly.express](https://plotly.com/python/plotly-express/) (коју учитавамо са скраћеним именом `px`), а конкретно за приказ табеле података користимо функцију [px.imshow](https://plotly.com/python/imshow/) на следећи начин:

fig = px.imshow(broj_takmicara_po_sportu_p, # podaci koje crtamo, tabela vec pripremljena i koriscena u heatmap funkciji
                labels=dict(x="Godina", y="Sport", color="Broj takmicara"), # imena osa i legende
                )
fig.update_layout( # na ovaj nacin dodatno definisemo velicinu slike
    width = 800, height = 1000,
    autosize = False,
    template= 'plotly_white') # obrazac za izgled, pre svega zbog bele pozadine, probajte bez ovog argumenta
fig.update_xaxes(side="top") # pomeramo da oznake na x osi budu na vrhu a ne dnu tabele
fig.show()

Преласком миша преко одговарајућих поља можете сазнати број такмичара за сваки спорт и годину. Истражите на пример колико је такмичара било на ритмичкој гимнастици, триатлону или другим дисциплинама чије бисте бројеве тешко уочили без интерактивне визуализације.

Независно од тога да ли смо цртали интерактивну или статичну верзију овог дијаграма, постоји још један "проблем" који би било згодно решити. Наиме, неки изузетно популарни спортови имају тако јарке боје да се у њиховој сенци теже могу уочити промене које постоје у времену код осталих спортова. Да бисмо то решили, можемо **скалирати** све вредности у врстама. Тако можемо лакше да поредимо спортове ако је наше главно питање да ли интересовање за спортове увек расте или има периодичне успоне и падове. То скалирање ћемо урадити тако што ћемо за сваки спорт наћи максималне вредности. Обратите пажњу примена функције `max` без аргумента ће подразумевати да тражите максималне вредности у свакој колони, а прослеђивањем аргумента `axis=1` добићемо максималне вредности у сваком реду (сваком спорту) што нам је у овом случају потребно:

maksimalne_vrednost_sportovi = broj_takmicara_po_sportu_p.max(axis=1)
maksimalne_vrednost_sportovi.head()

А затим целу табелу поделити максималним вредностима, тако да је врста атлетика подељена максималном вредношћу у атлетици, све вредности тениса су подељене максималним вредностиам за тенис и тако даље:

broj_takmicara_po_sportu_skaliran = broj_takmicara_po_sportu_p.divide(maksimalne_vrednost_sportovi,axis=0)
broj_takmicara_po_sportu_skaliran.head()

На овај начин смо добили табелу у којој су све вредности између 0 и 1 (где се јединица налази на оном месту када је дати спорт доживео максимално интересовање), хајде да видимо како изгледа такав график:

plt.figure(figsize=(8,10))
sns.heatmap(broj_takmicara_po_sportu_skaliran,cmap='Greens',linewidths=1, linecolor='lightgrey')
plt.show()

На овом графику сада има много више квадратића са тамнијим нијансама и можемо лакше запажати промене у времену. Видимо да је велики број спортова максимално интересовање доживео у последњим олимпијским играма (све врсте у којима можете детектовати најтамнију боју на крају, нпр. одбојка, ватерполо...), то је негде и очекивано зато што смо видели да је глобални тренд да је број такмичара на олимпијадама растао, те је очекивано и да појединачни спортови бележе раст и максимална интересовања на крају посматраног периода. Далеко занимљивији су спортови и такмичарске дисциплине које одступају од овог тренда (где у врсти можете видети тамније кватратиће раније, праћене светлијим, или белим (нестанком ових спортова), такви су на пример мачевање, бокс, стрељаштво... Такође, на овој визуализацији далеко лакше уочавамо који су то спортови који су имали епизодно појављивање након чега су нестали (после једних или пар олимпијских игара), на пример поло, голф, аеронаутика (још једно изненађење у олимпијској прошлости).

Не смемо заборавити да смо на овом графику скалирали приказане вредности па иако је боја квадратића поменуте аеронаутике и атлетике иста, максимални бројеви такмичара у ове две категорије се драстично разликују. Можемо приказати и максималне вредности које смо израчунали за припрему овог графика:

plt.figure(figsize=(3,10)) # zato što znamo da imamo puno sportova pravimo visok, a uzak prostor za crtanje
ax = maksimalne_vrednost_sportovi.plot(kind='barh') # podatke predstavljamo horizontalnim stubićima da bismo lakše sa strane čitali imena
ax.invert_yaxis()
ax.set_ylabel('')
plt.show()

Један коректан начин да ове две информације искомуницирамо, је и да их спојимо на један график. Тако ћемо са једне стране понудити читаоцима да виде како се интересовање за поједини спорт мењало до достизања максималног инетресовања, док ће са друге стране видети колико се максимална интересовања разликују по спортовима:

f, (a0, a1) = plt.subplots(1, 2, gridspec_kw={'width_ratios': [3, 1]},figsize=(12,10))
sns.heatmap(broj_takmicara_po_sportu_skaliran,cmap='Greens',linewidths=1, linecolor='lightgrey',ax=a0)
maksimalne_vrednost_sportovi.plot(kind='barh',ax=a1,color='Grey')
a1.invert_yaxis()
a1.set_ylabel('')
plt.tight_layout()
plt.show()

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Нацртајте исти график интересовања по спортовима али за зимске олипнијске игре. 
Такође, уместо бројања учесника у сваком спорту, можете пребројати колико националних комитета је послало тим за тај спорт, то нам још директије говори о конкуренцији у том спорту.</div> 

# # resenje
# zimske_igre = pd.read_csv('sport_podaci/zimske_olimpijske_igre_do_2014.csv')
# broj_noc_po_sportu = zimske_igre.groupby(['Year','Sport'])['NOC'].unique().apply(len)
# broj_noc_po_sportu = broj_noc_po_sportu.reset_index()
# broj_noc_po_sportu = broj_noc_po_sportu.rename(columns={'NOC':'Broj_nokova'})
# broj_noc_po_sportu_p = broj_noc_po_sportu.pivot(index='Sport',columns='Year',values='Broj_nokova')

# plt.figure(figsize=(8,6))
# sns.heatmap(broj_noc_po_sportu_p,cmap='Greens',linewidths=1, linecolor='lightgrey')
# plt.show()
## 4. Земље са највише (златних) медаља

Тешко је замислити да вам током олимпијских година (било зимских било летњих) промакне информација о одржавању олимпијских игара. Када је једна овако велика међународна манифестација у јеку, референце на олимпијске игре налазе се свуда, од реклама и билборда који најављују спортски догађај, бодре репрезентацију, преко ТВ преноса, до дневних пресека стања који нас обавештавају о (не)успесима. Из дана у дан током трајања игара, може се чути о томе колико медаља је која држава освојила, коме је која медаља умакла, којој медаљи се надамо сутра. Наравно, све се заврши неком бомбастичном информацијом попут "Србија је на 45. месту по броју освојених медаља!" нужно испраћена и коментаром од кога смо све у региону боље прошли. Сјајне спортисткиње и спортисти убрзо бивају заборављени и сви се враћамо својим типичним свакодневницама.

Наш циљ је да у наставку истражимо број медаља (златних, а и осталих) по државама, да видимо како да те податке визуелно комуницирамо и видимо да ли можемо закључити нешто више од тога која земља је која на ранг листи. За пример ћемо користити олимпијске игре 2012 године, али исту анализу можете поновити за било коју годину по вашем избору.

# ucitavanje neophodnih biblioteka

import pandas as pd # učitavanje i obrada tabelarnih podataka
import matplotlib.pyplot as plt # crtanje podataka

Користићемо као и претходно податке о летњим олимпијским играма:

letnje_igre = pd.read_csv('sport_podaci/letnje_olimpijske_igre_do_2014.csv') # citanje lokolne verzije podataka o letnjim olimpijske igre

Кренућемо у истраживање успешности земаља у освајању (златних) медаља на примеру једне манифестације летњих олимпијских игара, на пример за 2012. годину, тако што ћемо издвојити само податке који одговарају тој години:

oigre2012 = letnje_igre[letnje_igre['Year']==2012] # selektujemo samo one redove kojima je u koloni godina broj 2012 i čuvamo tu tabelu kao novu promenljivu
oigre2012.head(2) # pregled prva 2 reda

Сада ће нам највише од користи бити колона о медаљама (`Medal`). За почетак можемо пребројати колико је којих медаља подељено:

oigre2012['Medal'].value_counts()

Постоје 2 необичности у овим бројевима:
- број златних, сребрних и бронзаних медаља није исти 
- број медаља је доста већи од броја који смо видели у прошлоj лекцији.

Видели смо да је на овим олимпијским играма било 303 догађаја у оквиру којих се додељују медаље, међутим, број који смо горе избројали је далеко већи. То је последица тога да ми у табели имамо све добитнике и добитнице медаља, дакле уколико је у питању тимски спорт, сви чланови тима су побројани. То ћемо морати да коригујемо када будемо бројали медаље које је освојила нека држава, нећемо да дајемо предност земљама које освајају медаље у екипним спотовима, већ се победа на сваком догађају броји једнако. Да бисмо то лашке урадили, издвојићемо прво табелу података која садржи само добитнике златних медаља, и ту можемо видети ово о чему смо причали када излистамо почетак табеле која садржи кошаркаше:

zlatne_medalje = oigre2012[oigre2012['Medal']=='Gold'] # selektujemo deo tabele koji sadrži "Gold" u koloni medalja i čuvamo rezultat u novoj promenljivoj
zlatne_medalje[zlatne_medalje.Sport=='Basketball'].head() # izlistavamo prvih 5 redova tavele koja sadrži zlatne medalje, ali i za koje važi da je sport košarka

Претходно нам илуструје да није могуће да само групишемо податке по земљи (националном организационом комитету `NOC`) и проверимо величину подтабеле пошто ћемо тако пројати све појединце који су се вратили кући са медаљом. Такође, не можемо ни само груписати по комитету и бројати различите спортове пошто бисмо тако само једном бројали кошарку, иако у горњем примеру видимо да су САД освојиле медаљу и у мушкој и у женској конкуренцији. 
Стога ћемо као и претходно груписати податке (`groupby`) по држави, а затим у свакој групи избројати различите догађаје. 

zlatne_medalje_po_drzavi = zlatne_medalje.groupby('NOC')['Event'].unique().apply(len) # grupisanje po državi i brojanje jedinstvenih događaja, čuvamo rezultat u novoj tabeli
zlatne_medalje_po_drzavi = zlatne_medalje_po_drzavi.reset_index() # resetujemo indeks da bismo koristili i kolonu sa državama koja je pre ove komande bila indeksna
zlatne_medalje_po_drzavi.head()

Зато што смо бројали јединствене вредности у колони `Event` резултати нашег груписања и бројања су у колони са тим именом па ћемо пре наставка то променити: 

zlatne_medalje_po_drzavi = zlatne_medalje_po_drzavi.rename(columns={'Event':'Broj_zlatnih_medalja'}) # promene imena se prosledjuju u formi recnika {sta_menjamo:cime_menjamo}

Можемо проверити да ли је претходно бројање прошло како треба тако што ћемо излистати 5 земаља са највише златних медаља и упоредити то са подацима које можемо пронаћи на [википедији](https://en.wikipedia.org/wiki/2012_Summer_Olympics_medal_table). То радимо сортирајући податке функцијом `sort_values` наглашавајући по којој колони уз помоћ аргумента `by`. Подразумевани начин сортирања је растући па ако хоћемо само да видимо првих 5 земаља, згодније нам је да користимо опадајуће сортирање `ascending=False` и одаберемо првих 5 вредности:

zlatne_medalje_po_drzavi.sort_values(by='Broj_zlatnih_medalja',ascending=False).head()

Mожемо проверити и колико уноса има ова наша нова табела, тј. колико земаља је освојило бар једну златну медаљу на посматраним олимпијским играма:

zlatne_medalje_po_drzavi.info() 

Где видимо да има 54 земље са бар једном златном медаљом. 

Ако сте пробали да неке од ових података упоредите са подацима на википедији или званичном сајту олимпијских игара вероватно сте наишли на мала неслагања (нпр. Русија је освојила ипак 20 златних медаља по [википедији](https://en.wikipedia.org/wiki/2012_Summer_Olympics_medal_table)). Иако и нас муче та неслагања, уместо одлуке да одустанемо од анализе олимпијада и прогласимо податке непогодним, одлучили смо да наставимо анализу уз објашњење узрока неслагања. Табеле које анализирамо, настале су у аутоматском преузимању података из једне од веб архива историјских успеха на олимпијским играма ([*Sports reference*](https://www.sports-reference.com/)). Међутим, оно што аутори скупа података нису узели у обзир је чињеница да резултати олимпијских игара нису финални, већ су наставили да се "мењају" и након што су табеле података сакупљене и објављене за даљу употребу. Како то да се подаци о прошлим олимпијадама мењају, питаћете се сигурно. Заправо, спортисти могу изгубити своје медаље и више година након одржаних олимпијских игара ако се утврди да су прекршили неко од правила, најчешће у вези са коришћењем недозвољених супстанци. На [овој адреси](https://olympics.com/ioc/news/fight-against-doping) можете видети сапштења о одузимању медаља са олимпијаде из 2012 и додељивању истих другим спортисткињама и спортистима које су се дешавале чак и прошле године! Листу свих одузетих медаља можете наћи [овде](https://en.wikipedia.org/wiki/List_of_stripped_Olympic_medals). Наши подаци садрже имена и остале податке о учесницима олимпијских игара укључујући и информацију да ли су добили одређену медаљу, али скуп података није коригован уколико је више година касније дошло до прерасподеле медаља. Стога ће се неретко дешавати да видите да број медаља неке државе који нађемо у овој радној свесци неће бити потпуно исти као број који можете сада наћи на сајтовима о олимпијским играма. Ово значи да ћемо при извођењу закључака понекад морати да будемо пажљивији, али нам се чинило да процес анализе података и њихове визуализације неће бити мање занимљив упркос "застарелости" неких од података.

Хајде да ову нашу табелицу која садржи само 2 колоне (трословни код државе и број медаља) допунимо и пуним именом државе пошто није увек лако сетити се која комбинација слова представља коју државу. То можемо уз помоћ функцијe [merge](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.merge.html) и нове табеле која садржи само имена држава и њихове трословне кодове националних комитета. Ту нову табелу правимо тако што одаберемо само колоне `NOC` и `Team` и обришемо сва непотребна понављања функцијом [drop_duplicates](https://pandas.pydata.org/docs/reference/api/pandas.Series.drop_duplicates.html):

drzave_kodovi = oigre2012[['NOC','Team']].drop_duplicates() # pravimo novu tabelu koja sadrzi samo jedinstvene kombinacije NOC i imena drzave
drzave_kodovi = drzave_kodovi.groupby('NOC').first().reset_index() # neke zemlje imaju vise timova sa dodatim brojem 1,2, tako da obako obezbedjujemo da samo jedan par NOC i Team postoje za svaku zemlju
drzave_kodovi.head()

Сада ову табелу можемо искористити да је спојимо (`merge`) са табелом која садржи `zlatne_medalje_po_drzavi`. Функцији прослеђујемо информације које две табеле спајамо и коју колону користимо да спојимо одговарајуће редове. У нашем случају то је колона `NOC` која је заједничка обема табелама:

zlatne_medalje_po_drzavi = pd.merge(zlatne_medalje_po_drzavi,drzave_kodovi,on='NOC') # spajanje dve tabele po koloni 'NOC'
zlatne_medalje_po_drzavi.head()

Како ми не желимо да дискутујемо само о златним медаљама, хајде да сличне табелице направимо и са бројевима освојених сребрних и бронзаних медаља. Не желимо да копирамо код три пута (то јесте релативно мало пута, али ћете можда желети то да поновите и за неке друге податке) па ћемо претходне кораке убацити у једну функцију која ће као улаз користити табелу података и низ карактера који означава који тип медаље хоћете да издвојите `Gold`, `Silver`, `Bronze`, a резултат функције ће бити табела са бројем одабраних медаља по држави:

def prebroj_medalje_po_drzavi(podaci_za_jednu_godinu,tip_medalja):
    """
    podaci_za_jednu_godinu je tabela podataka koji u svakom redu sadrze informacije o sportistima ucesnicima olimpijskih igara
    tip_medalja je string "Gold","Silver","Bronze" tj. govori nam koje medalje hocemo da izdvojimo
    
    ova funkcija kao rezultat vraca tabelicu koja ima kolonu sa troslovnim kodom drzave NOC i kolonu sa brojem medalja "tip_medalja" koje je drzava osvojila
    """
    medalje = podaci_za_jednu_godinu[podaci_za_jednu_godinu['Medal']==tip_medalja]  # selektujemo deo tabele koji sadrži odredjeni tip medalaj u koloni Medal i čuvamo rezultat u novoj promenljivoj

    medalje_po_drzavi = medalje.groupby('NOC')['Event'].unique().apply(len) # grupisanje po državi i brojanje jedinstvenih događaja, čuvamo rezultat u novoj tabeli
    medalje_po_drzavi = medalje_po_drzavi.reset_index() # resetujemo indeks da bismo koristili i kolonu sa državama koja je pre ove komande bila indeksna
    medalje_po_drzavi = medalje_po_drzavi.rename(columns={'Event':tip_medalja}) # menjamo ime kolone u tip medalje koji smo odabrali
    
    return medalje_po_drzavi

У функцију нисмо ставили спајање са колоном која садржи пуне називе држава зато што ћемо сада направити табелице за сваку од медаља па ћемо тек када све то спојимо додати и пуна имена држава. Хајде да проверимо рад функције на примеру првих пет уноса табеле са златним медаљама које смо приказивали и изнад:

prebroj_medalje_po_drzavi(oigre2012,'Gold').head()

Супер, добили смо исте резултате као и претходно. Хајде да сада резултате функције за златне, сребне и бронзане медаље да сачувамо у појединачним табелама:

zlato = prebroj_medalje_po_drzavi(oigre2012,'Gold') # da dobijemo zlatne medalje koristimo string "Gold"
srebro = prebroj_medalje_po_drzavi(oigre2012,'Silver') # za srebro koristimo "Silver" i cuvamo podatke u promenljivoj srebro
bronza = prebroj_medalje_po_drzavi(oigre2012,'Bronze') # za bronzane medalje koristimo "Bronze"

<details>    
<summary>
    <font color="darkgreen"><b>Како бисте проверили да ли постоје неки бројеви у новонасталим табелама? </b>
</font>
</summary>
Као и до сада, можете искористити фунције `head` (на пример `srebro.head()`) или `info` (на пример `bronza.info()`) да видите број редова и тип података у различитим колонама.

Сада када имамо све три табеле, можемо их спојити у једну заједничку која ће садржати једну колону која одређује државу (трословним кодом) а затим у осталим колонама има број златних, сребрних и бронзаних медаља. То ћемо опет урадити уз помоћ функције `merge`:

sve_medalje = pd.merge(zlato,srebro, on ='NOC') #kao i prethodno, znamo da je kolona NOC zajednicka i nju koristimo da spojimo tabele
sve_medalje.head()

Судећи по првих пет редова, делује да смо добили тип табеле који смо желели, недостаје само да додамо још податке о бронзаним медаљама. Пре додавања бронзаних медаља, хајде да проверимо нову табелу користећи и функцију `info`:

sve_medalje.info()

Ово је необично! Раније смо видели да има 54 земље које су освојиле бар једну златну медаљу, и чак да се десило да је мање земаља освојило сребрну медаљу, очекивали бисмо да се у заједничкој табели налазе барем све земље које имају злато, дакле бар 8 земаља нам недостаје. Када налетите на овако неки проблем, добар алат је враћање на документацију функције коју сте искористили, у овом случају [merge](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html), и потражите извор проблема. Један добар метод је да обратите пажњу на подразумеване вредности параметара које нисте искористили. 
Читањем документације можемо приметити да смо ми искористили најосновнију верзију функције, тј. покренули смо је са минималним бројем аргумената, а сви остали аргументи су остали подразумевани. Кључни међу њима, аргумент `how` који дефинише *како* се табеле спајају нам је проузроковао проблем. Подразумевани тип спајања је да се у новонасталој табели нађу само они редови код којих држава по којој спајамо (односно `NOC`) постоји и у једној и у другој табели. То значи да је овај први покушај спајања креирао листу земаља које имају бар једну златну и бар једну сребрну медаљу, док све оне које имају или само златне или само сребрне медаље не постоје. То је начин спајања који ће нам бити од користи за неке од примена, али овде није адекватан зато што желимо да бројимо све земље које су биле успешне на олимпијади и то ћемо постићи тако што аргумент `how` добије вредност `outer`. На овај начин државе које су се појавиле у бар једној од табела морају бити и у заједничкој, што је управо оно што одговара нашим питањима.

sve_medalje = pd.merge(zlato,srebro, on ='NOC',how='outer') # spajamo tabele uz pomoc zajednicke kolone NOC ali tako da se sve zemlje (iako postoje samo u jednoj tabeli) nadju u novoj tabeli
sve_medalje.info() # provera velicine novonastale spojene tabele

Ово већ више одговара нашим очекивањима - колона са златним медаљама има 54 бројчана уноса, колона са сребрним медаљама има 66, а укупно табела има 74 реда, односно државе.

<details>    
<summary>
       <font color="darkgreen"> <b> Број медаља које је земља освојила мора бити целобројан тј. очекивали бисмо да тип података у колони буде `int` али видимо тип  `float`, да ли знате зашто је то тако?</b>
</font>
</summary>
Када колона садржи не бројчане вредности, тј. `NaN` вредности, библиотека `pandas` такву колону аутоматски третира као `float` тип података. Тако да не брините, није се десило да смо у бројању доделили некој држави 3.2 медаље, већ се просто дешава да су неке земље без златних или сребрних медаља, што поред горње провере можете видети и користећи `sve_medalje.head()`.

На исти начин ћемо сада у табелу `sve_medalje` додати и податке о бронзаним медаљама:

sve_medalje = pd.merge(sve_medalje,bronza, on ='NOC',how='outer') # spajamo tabele uz pomoc zajednicke kolone NOC ali tako da se sve zemlje (iako postoje samo u jednoj tabeli) nadju u novoj tabeli
sve_medalje.info() # provera velicine novonastale spojene tabele

sve_medalje.head() # prvi redovi nove tabele

Попуњавање непостојећих вредности је веома важна тема и у овом курсу ћете се сусретати са њом на различитим местима (видите на пример и у [темату о јавном здрављу]()) где ће се примењивати различите стратегије. Некад је битно оставити `NaN` вредности као подсетник да тај податак не постоји, а некад се подаци допуне уз адекватне претпоставке. Овде на пример је потпуно адекватно све `NaN` вредности заменити 0 зато што знамо да те земље нису освојиле одговарајућу медаљу и `NaN` ознака се појавила само као последица спајања а не губљења или заборављеног уноса податка. Замена `NaN` података може се урадити уз помоћ [fillna](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html) функције:

sve_medalje = sve_medalje.fillna(0) # sve NaN vrednosti menjamo sa nulom
sve_medalje.head()

Сада када смо решили постојање `NaN` података можемо променити тип колона натраг на очекиване целобројне вредности користећи функцију [astype](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.astype.html) са аргументом `int`. Додаћемо такође и колону која садржи укупан број медаља користећи функцију [sum](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sum.html) да саберемо вредности у колонама `Gold`,`Silver` и `Bronze`. Обратите пажњу да смо искористили додатни аргумент `axis=1` да бисмо сабрали вредности табеле у хоризонталном правцу, без овог аргумента, сумирање се врши вертикално тако да бисмо само добили укупан број златних, сребрних и бронзаних медаља за све земље (сетите се, у претходној лекцији смо слично радили са функцијом `max`).

sve_medalje[['Gold','Silver','Bronze']] = sve_medalje[['Gold','Silver','Bronze']].astype(int) # menjamo tip podataka u kolonama u int
sve_medalje['Total'] = sve_medalje[['Gold','Silver','Bronze']].sum(axis=1) # dodajemo novu kolonu 'Total' cija vrednost je zbir brojeva u kolonama 'Gold', 'Silver' i 'Bronze'
sve_medalje.head()

Можемо да сортирамо ову табелу на пример по укупном броју медаља и видимо почетак такве табеле, тј првих 5 или 10 земаља које су освојиле највише медаља:

sve_medalje = sve_medalje.sort_values(by='Total',ascending=False)
sve_medalje.head(10)

Видимо да је распоред земаља на табели сада мало другачији него када смо гледали само број освојених златних медаља. Прве две државе су и даље исте - Америка и Кина имају и највише златних и највише медаља укупно - али се распоред осталих мења. На пример, Кореја која је пета земља по броју златних медаља је тек 10 на листи ако се посматрају све укупно медаље.

Међутим, људи нису претерано добри у сагледавању информација кроз велике табеле, стога ћемо ове податке и визуелизовати. Једна од погодних могућности за цртање података категоричког типа какви су подаци о државама (колона `NOC`) је да искористимо стубичасти дијаграм тако што ће свакој држави одговарати један стубић, а његова висина ће бити нумеричка колона (број златних или укупни број медаља) коју желимо да представимо.

sve_medalje = sve_medalje.set_index('NOC') # postavljamo NOC kolonu za indeksnu
plt.figure(figsize=(15,2)) # biramo velicinu prostora za crtanje 
sve_medalje.Gold.plot(kind='bar') # crtamo kolonu sa zlatnim medaljama
plt.show()

<details>    
<summary>
       <font color="darkgreen"> <b> Шта бисте све поправили код овог графика?
       </b>
</font>
</summary>
Неке од очигледних замерки су: (1) Нема потребе за државама које нису освојиле злато, ако цртамо само график са златним медаљама. (2) Потребно је сортирати податке по колони која ће бити цртана зато што на тај начин и позиција државе у низу (поред висине стубића) комуницира гледаоцу неке информације, нпр. позицију на ранг листи. (3) Само 3 слова по земљи су ок зато што стају лепо испод стубића, али за пуно земаља та три слова нису довољна да се сетимо која земља је у питању, можда би било боље да постоје читава имена држава. (4) Недостаје име у осе, а и име х осе би могло бити боље, и тако даље.
Покушајте да "поправите" овај график уз ове смернице.

Предлажемо да "поравите" горњи график у складу са вашим идејама и замеркама, а ми ћемо кроз цртање у наставку понудити још нека визуелна решења која вам могу помоћи када цртате овакве или сличне податке. На пример, трословни код за сваку земљу очекује да читаоци знају све кодове, што је превелико очекивање и згодније је стубиће означавати са пуним именима држава. Додаћемо колону са именима:

sve_medalje = sve_medalje.reset_index()# da bi kolona 'NOC' opet postala obicna kolona da je iskoristimo za spajanje
sve_medalje = pd.merge(sve_medalje,drzave_kodovi,on='NOC') # spajanje tabela po zajednickoj koloni NOC
sve_medalje.head()

Додатно, није увек неопходно да нацртате баш све податке, можда је згодно фокусирати се на сличности и разлике првих 10 или више држава. Пробаћемо овде са првих 30 (по укупном броју освојених медаља):

top30 = sve_medalje[:30] # izdvajamo prvih 30 zemalja zato što je tabela sve_medalje već sortirana u opadajućem redosledu
top30 = top30.sort_values(by='Total',ascending=True) # okrećemo prvih 30 zemalja da budu u rastućem redosledu zbog crtanja u nastavku
top30.head()

Уместо да цртамо само укупан број медаља, или само један тип, на следећем графику, приказаћемо збирно златне, сребнре и бронзане медаље, тако што ћемо на стубићу сваке државе један сегмент обојити у златно и та дужина стубића одговараће броју златних медаља (и слично за све остале) док ће дужина целог стубића одговарати укупном броју медаља одређене државе.

plt.figure(figsize=(4,12)) # dimenzije slike
plt.barh(top30.Team,top30.Total,color='#AA7042',label='Bronzane medalje') # bronzani stubici
plt.barh(top30.Team,top30.Gold+top30.Silver,color='#A8A9AD',label='Srebrne medalje') # srebrni stubici
plt.barh(top30.Team,top30.Gold,color='#D4Af37',label='Zlatne medalje') # zlatni stubici 
plt.grid(axis='x') # dodajemo uspravne sive linije (mrezu da nam pomogne oko ocitavanja duzina stubica)
plt.xlabel('Broj osvojenih medalja') # ime x ose
plt.legend() # dodajemo legendu
plt.show()

Када је сортиран, стубичасти график комуницира са нама као и ранг листа (државе које читамо са леве стране су у оном распореду који одговара њиховом пласману по укупном броју медаља), али уз додатне, визуелне информације. Тако можемо лакше оценити да је Америка освојила више од пет пута више медаља од Холандије или Украине и сл. Додатно, боје делова стубића нам помажу да уочимо да су неке земље освојиле више златних него других медаља (нпр Казакстан), док су неке друге освојиле значајно више сребрних (нпр Шпанија), а неке бронзаних (нпр Канада).

Од додатних поправки које смо искористили да овај график буде бољи, излистаћемо само неке које често могу помоћи у комуникацији:
- Искористили смо хоризонталне стубиће да бисмо лакше могли да читамо имена држава
- Сортирали смо државе по укупном броју медаља
- Фокусирали смо се на део држава 
- Искористили смо стубиће различитих боја који се надовезују један на други да искомуницирамо више информација на графику
- Додали смо усправне линије да још мало помогну у процени дужине стубића

Предност коју добијамо сортирањем у овом случају од користи је само када поредимо државе по њиховом укупном успеху, ако желимо да поредимо државе по питању броја појединачних медаља, то нам је мало теже. Златне медаље можда и најлакше можемо поредити, пошто им је свима почетак поравнат са левом страном. Међутим, када је потребно упоредити број сребрних или бронзаних земаља 2 земље које се не налазе једна поред друге или немају драстично различите вредности то може бити теже. Ако је циљ комуницирати ту инфомацију, згодни су стубичасти дијаграми код којих се сва три типа стубића налазе једни до других а не настављајући се један на други (видите на пример лекцију о ризичним понашањима у сегменту о здрављу), али код њих гледалац у глави треба да сабира дужине стубића тако да постаје недоступна информација о укупном броју медаља.

Надовезујуће стубиће изнад нисмо нацртали користећи надовезујуће стубиће (као што је то урађено аргументом `stacked=True` у лекцији о јавном здрављу) већ смо искористили трик да свако ново цртање додаје објекте једне *преко* других. Тако смо прво нацртали бронзане стубиће чија дужина одговара укупном броју освојених медаља једне земље. Затим смо преко тих стубића нацртали сребрном бојом обојене стубиће у дужини која одговара збиру златних и сребрних медаља. Ови сребрни стубићи тако су прекрили већину претходно нацртаних бронзаних, и остала је тачно дужина која одговара броју освојених бронзаних медаља. Коначно, преко сребрних стубића нацртали смо златне чија дужина одговара броју златних медаља, а непрекривени део дужине сребрних стубића одговара сребрним медаљама.

Можемо додати још мало конктекста који ће нам помоћи да схватимо податке о броју освојених медаља. Наиме, није исто да ли је земља добила једну златну медаљу а послала је на олимпијске игре само репрезентацију која се бори у том једном спорту, или када земља добије једну златну медаљу а опробала се у свим олимпијским дисциплинама. Ово су наравно две екстремне ситуације да нам дочарају специјализовану стратегију "такмичимо се у једној дисциплини и јако смо у њој добри" и "испробавамо све, па шта прође, прође". Хајде да видимо какво је заправо стање међу државама освајачицама медаља, да ли су ближе једној или другој страни.

За то нам је потребно да избројимо тимове тј. различите догађаје на којима се држава такмичила. До сада смо савладали да се то једноставно и лако решава груписањем и бројањем:

broj_timova = oigre2012.groupby('NOC')['Event'].unique().apply(len) # broj jedinstvenih dogadjaja u tabelama sa istim NOC
broj_timova.head()

Сада ћемо и овај податак придружити табели са медаљама:

sve_medalje = pd.merge(sve_medalje,broj_timova,on='NOC')
sve_medalje.head(2)

Већ у ова прва 2 реда, видимо да су две најуспешније земље (када се гледа укупан број златних, или укупан број медаља) врло добри представници стратегије о којој смо причали - слање пуно тимова из различитих дисциплина (сетимо се, раније смо видели да је укупан број медаља које је могуће освојити, тј. такмичења на овој олимпијади био 303). Да бисмо проверили успешност државе у освајању медаља, можемо увести колону у којој ће сместити израчунат проценат тимова једне земље који се вратио кући са медаљом:

sve_medalje = sve_medalje.rename(columns={'Event':'Broj_timova'}) # menjamo ime kolonе
sve_medalje['Uspesnost_timova'] = 100*sve_medalje['Total']/sve_medalje['Broj_timova'] # dodajemo kolonu o uspesnosti

Можемо упоредно представити визуелно податке о укупном броју медаља, укупном броју златних медаља и успешношћу на још један начин:

<img src="sport_slike/Medalje_2012.png" width="600"/>

Поредећи леви и средњи график, видимо да опадајући редослед у укупном броју медаља врло често одговара и опадајућем редоследу држава у броју освојених златних медаља. Постоје земље које би да смо табелу сортирали по златним медаљама прекочиле које место изнад, али разлике нису превише драматичне (најлакше те државе можете пронаћи пратећи тачкице на средњем дијаграму и обратите пажњу на државе код којих је доња тачкица десно од горње, или горњих тачкица).
Међутим, још много интересантнији је десни низ тачкица на коме видимо државе које су далеко ниже од апсолутних победника у броју медаља или броју златних медаља, али имају далеко већу успешност. Видите на пример Јамајку, Кенију, Етиопију, код којих је скоро сваки други тим (или појединац) који се пласирао на олимпијаду освојио медаљу.

Погледајмо за крај која држава има највећу успешност и који су то тимови и спортови који су тој земљи донели медаље:

maxuspesnost = max(sve_medalje.Uspesnost_timova) # izdvajamo najvecu uspesnost
sve_medalje[sve_medalje.Uspesnost_timova==maxuspesnost] # izdvajamo red tabele koji govori o timu koji je imao najvecu stopu uspesnosti

oigre2012[(oigre2012.NOC=='ETH')&(oigre2012.Medal.isin(['Gold','Silver','Bronze']))] # izdvajamo dobitnije medalja iz Etiopije

Видимо да је свих 7 медаља Етиопије у атлетским дисциплинама, од којих је за две заслужна иста особа **Tirunesh Dibaba Keneni**, импресивно!

На крају ове лекције, сачуваћемо податке које смо прикупили анализом у овој лекцији за даљу употребу:

sve_medalje.to_csv('sport_podaci/oi2012_medalje_po_zemljama.csv',index=False)

**Задатак**: Репродукујете последњи график користећи код доступан на [овој адреси](https://seaborn.pydata.org/examples/pairgrid_dotplot.html).

# resenje
# jos malo cu ga uprostiti i izkomentarisati, sad je prilicno bazirano na linku sa minormim izmenama za nase podatke

# # Make the PairGrid
# g = sns.PairGrid(sve_medalje.sort_values(by='Total',ascending=False),
#                  x_vars=['Total','Gold','Uspesnost_timova'], y_vars=["Team"],
#                  height=12, aspect=.2)

# # Draw a dot plot using the stripplot function
# g.map(sns.stripplot, size=10, orient="h", jitter=False,
#        palette="flare_r",linewidth=1, edgecolor="w")

# # # Use the same x axis limits on all columns and add better labels
# # g.set(xlabel="Medalje", ylabel="")

# # Use semantically meaningful titles for the columns
# titles = ["Ukupan broj medalja","Zlatne medalje", "Uspešnost"]

# xlabels = ['Broj medalja','Broj medalja','% timova sa medaljama']

# for ax, title,xlab in zip(g.axes.flat, titles,xlabels):

#     # Set a different title for each axes
#     ax.set(title=title)
    
#     ax.set_xlabel(xlab)

#     # Make the grid horizontal instead of vertical
#     ax.xaxis.grid(False)
#     ax.yaxis.grid(True)

# sns.despine(left=True, bottom=True)
# plt.savefig('sport_slike/Medalje_2012.png',dpi=300,bbox_inches='tight')
## 5. Представљање података на мапи света

Претходно смо видели пар начина да неке од података о успешности на олимпијским играма представимо графички. Међутим, у свим тим начинима информацију о држави сводили смо на име, "категорију" података и тим именом смо обележавали одговарајуће стубиће или тачкице. Тако смо заборављали на разна друга знања која ми имамо о државама, тако и на пример где се оне налазе на мапи света. У наставку ћемо видети како можемо да истакнемо државе добитнице медаља на мапи уз помоћ библиотеке [geopandas](https://geopandas.org/docs.html). 

Ова библиотека нам је од користи када год учитварамо или манипулишемо подацима у којима очекујемо да ће се наћи геометријски подаци, а облик држава је управо такав податак. Иако у пајтону можемо читати податке из фајлова на много различитих начина, предности коришћења библиотека попут библиотеке `pandas` или `geopandas` леже у томе што је са подацима аутоматски учитан и препознат и њихов формат, као и чињеница да обе библиотеке садрже прегршт функција оптимизованих за податке са којима знају да баратају. Тако када у подацима који су нам на располагању имамо податке о геометрији, `geopandas` је одличан избор. Сличност ове две библиотеке није само у имену, као што ћемо видети и логика коришћење и манипулација података у оквиру геопандас библиотеке је доста слична свему на шта смо навикли код панда. У локалном фолдеру са подацима, поред података о спорту имамо припремљене податке о мапи света, тј. контурама држава. Учитаћемо те податке уз помоћ функције [read_file](https://geopandas.org/en/stable/docs/reference/api/geopandas.read_file.html) библиотеке `geopandas`:

# ucitavanje neophodnih biblioteka za rad sa podacima u nastavku

import pandas as pd # manipulacija tabelarnim podacima
import geopandas as gpd # manipulacija tabelarnim podacima koji sadrze geometrijske informacije
import matplotlib.pyplot as plt # data vizualizacija

svet = gpd.read_file('sport_podaci/mapa_sveta.xlsx') # učitavanje fajla koji sadrži geometrijske podatke o svetskim državama
svet.head() # prikaz prvih 5 redova

Првих 5 редова смо проверили на исти начин као што смо то радили до сада и на први поглед нам делује као да је у питању још једна табела слична онима које смо до сада користили. Видимо да колона са називом `iso_a3` садржи скраћено име земаља у виду три слова, на која смо наилазили и у до сада анализираним олимпијским подацима (тамо у колони `NOC`), ова скраћеница у називу колоне упућује на [стандард](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) по коме су трословне скраћенице имена држава настале. Једна колона делује необичније него остале, па хајде да проверимо да ли има више информација о колонама и типовима података у њима (то је такође исто као у `pandas` библиотеци):

svet.info()

Видимо да колона чији су први уноси садржале кључне речи "полигон" садржи геометријски тип података. Више на ту тему можете прочитати у [документацији](https://geopandas.org/docs/reference/api/geopandas.GeoSeries.html), а ми ћемо у наставку практично приказати тај садржај.
Као што смо најавили подаци садрже "мапу света" тако да поред имена сваке земље имамо неке информације о томе како нацртати контуре те земље. То можемо тестирати тако што искористимо функцију [plot](https://geopandas.org/mapping.html) над целим скупом података или на земљама по избору. Ево на пример једне од земаља карактеристичног облика:

svet[svet.name=='Italy'].plot() # selektujemo red tabele koji u koloni ime sadrzi rec "Italy" i crtamo red plot funkcijom
print(svet[svet.name=='Italy']) # stampamo selektovani red tabele koji smo i nacrtali

Поред цртања облика Италије (које функција обавља на основу података у колони геометрија, енг. *geometry*) одштампали смо и саджај датог реда у подацима да се уверимо да у њему није постојало ништа друго што би могло подстаћи цртање овог карактеристичног облика осим поља у колони геометрија. Видимо да је у питању више полигона (енг. *MULTIPOLYGON*), односно изломљених затворених линија, што видимо и на цртежу (Италија међу територијама поред полуострва има и 2 острва, тако да је то 3 полигона). За потребе које ћемо ми користити у наставку, размишљајте о овој колони као о низу координата тачака које треба спојити да би се на мапи добио облик земље коју хоћете да нацртате (што је практично све што се налази у нашем скупу података), али ова библиотека има далеко више могућности за цртање које вам препоручујемо да наставите да истражујете.

Гледајући слику Италије сигурно примећујете и да она није превише детаљна. Ако сте гледали неке друге мапе или сателитске слике видели сте много мање оштрих ивица, али ово је ниво детаљности који нам је потребан када цртамо цео свет. Када за који тренутак на истом цртежу видимо све земље, неће бити потребе да свака појединачна земља буде нацртана детаљније ни прецизније од овога што видимо на примеру Италије. Као што смо применили функцију `plot()` на један ред података, тако је можемо искористити да видимо све земље у скупу података `svet`:

svet.plot() # crtamo mapu sveta

Иако су све једнако грубо нацртане као Италија, једноставном функцијом добили смо одличну мапу света, али је ипак можемо још мало прилагодити за наше потребе. 

Зато што нам је фокус на представљање држава добитница медаља на олимпијадама, није потребно да тако велики део слике буде Јужни пол који је ненасељен. Стога ћемо искључити ред посвећен Антарктику из података и нацртати још једном ову мапу пре него што кренемо да је бојимо.

svet = svet[(svet.name!="Antarctica")] # slektujemo redove tabele svet, tako da ime teritorije NIJE Antarktik i to čuvamo ponovo u promenljivoj svet
svet.plot() # crtamo ovaj izmenjeni svet

Као што сте видели, када имате одговарајући фајл са геометријским подацима, цртање неме карте је врло једноставно. Кључно је дакле доћи до геометријских података, али су и они лако доступни, нпр. [овде](https://opendata.geosrbija.rs/) можете наћи податке о Србији са поделом на општине и  округе, а један пример њихове употребе можете наћи [овде](https://petlja.org/biblioteka/r/lekcije/jupyterRadneSveske_srb/srednjo%C5%A1kolci-u-republici-srbiji-3). 

Једна ствар на коју додатно треба обратити пажњу је [тип пројекције](https://en.wikipedia.org/wiki/List_of_map_projections), односно увек освестити чињеницу да се свет настанио на облику сличном лопти и да када покушавамо то да нацртамо на дводимензионој површини попут нашег дисплеја, неке ствари ће изгледати издуженије него што су стварно, или веће/мање него што су стварно, те зависно од тога на шта желите да се фокусирате треба одабрати одговарајућу пројекцију.

Сада је време да различите државе обојимо тако да истакнемо оне које су освојиле више медаља. И то ће бити прилично једноставно, али је пре цртања неопходно у једну исту табелу сместити и податке о геометрији земаља (управо дискутована табела `svet`) и податке о медаљама које смо претходно припремили. 

<details>    
<summary>
    <font color="darkgreen"><b>Да ли се сећате којом функцијом спајамо табеле?</b>
</font>
</summary>
У питању је функција merge, можете се подсетити о њеним особинама у документацији овде https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html.

Учитавамо претходно припрељене податке са бројем медаља по земљама:

sve_medalje = pd.read_csv('sport_podaci/oi2012_medalje_po_zemljama.csv') 
sve_medalje.head(2)

Спајамо табеле са информацијама о медаљама са табелом у којој се налазе географски подаци. Зато што се колоне које садрже податке по којима ћемо спајати табеле (име државе) не зову исто у различитим табелама, користићемо мало другачији формат у функцији `merge`. Коришћењем аргумената `left` и `right` обележићемо 2 табеле као леву и десну табелу за спајање, а затим ће и претходно коришћени аргумент `on`(колона по којој спајамо табеле) добити своју леву и десну верзију у виду аргумената `left_on` и `right_on`. Ово значи да ћемо на пример спајајући податке о Кини, у табели `sve_medalje` тражити име `China` у колони `Team`, а у табели `svet` тражити исто име у колони `name`. Када нађемо одговарајуће редове, њих ћемо спојити и тај процес ћемо наставити за све земље. Сетите се, ако не искористимо аргумент `how`, процес спајања направиће табелу која садржи само државе чија се имена налазе и у једној и у другој листи. У овом случају, ми желимо да нађемо географске податке за све земље за које имамо податке о медаљама, зато ћемо искористити `how='left'`.

svet_medalja = pd.merge(left = sve_medalje, right = svet, left_on = 'Team', right_on = 'name',how='left') # spajanje tabela i cuvanje rezultata u novoj promenljivoj
svet_medalja.head()

Већ у првим редовима, видимо примере држава код којих није дошло до спајања (нпр. Америка, Велика Британија), да би видели колико је таквих примера, погледајмо попуњеност табеле:

svet_medalja.info()

Овде видимо да у табели постоји 9 држава код којих спајање није успело, тј. вредности колона из табеле свет нису попуњене у 9 редова (колона `NOC` има 85 уноса, док колона `geometry` има 76 уноса). Можемо направити нову табелу у којој ће бити само они редови у којима није дошло да спаривања, и исте редове избрисати из новокреиране табеле где желимо сачувати потпуне податке из обе табеле. Погледајмо којих је то 9 земаља и покушајмо да схватимо шта се десило:

drzave_koje_nisu_sparene = svet_medalja[svet_medalja['name'].isna()] # u posebnu tabelu izdvajamo redove kod kojih nije došlo do spajanja geometrijskih i podataka o medaljama
svet_medalja = svet_medalja.dropna() # iz kolone svet_medalja izbacijume te redove
drzave_koje_nisu_sparene # pregled posebne tabele sa nesparenim vrednostima

Неке од ових земаља смо сигурно видели у табели свет, тј. на мапи света (нпр Америка, она је тешка за заобићи, да подаци о њој недостају доста другачије би изгледала мапа света којом смо били прилично задовољни), хајде да проверимо још једном да ли постоје можда под другачијим именом:

svet[svet.name.str.contains('America')] # trazimo redove tabele kod kojih kolona name sadrzi rec America

Видимо да географски подаци о Америци постоје у табели свет, али да је у колони `name` име *United States of Americа*, док је у тебели која садржи податке о медаљама име тима *United States* те није могло доћи до спајања по овим колонама зато што се име у потпуности не поклапа. На срећу, обе колоне имају трословни код и на пример у случају Америке видимо да се у тим колонама код поклапа. Можемо да пробамо спајање држава које још нисмо спарили, али уместо имена користећи трословне кодове за спајање. Пре тога, обрисаћемо колоне које су настале неуспешним спајањем:

# zato što se u kolonama o geometriji ne nalazi ništa, izbacićemo te kolone da bi ponvoo probali spajanje na drugi način
drzave_koje_nisu_sparene = drzave_koje_nisu_sparene.drop(columns={'continent','name','iso_a3','geometry'})
drzave_koje_nisu_sparene

А затим пробати спајање поново, овај пут користећи друге колоне `NOC` и `iso_a3`. Нећемо вршити спајање целих табела, већ само сегмента који је остао неспарен:

drzave_dodatak = pd.merge(left = drzave_koje_nisu_sparene, right = svet, left_on = 'NOC',right_on='iso_a3',how='left')
drzave_dodatak

Одлично, овако смо успели да још пар земаља спаримо са њиховим геометријским облицима, али нам нажалост остајu 4 земље које намамо међу подацима у овом тренутку, па ћемо наставити са цртањем без њих, само ћемо пробати да их не заборавимо у закључивању. Видимо да су у питању земље са мало медаља, тако да треба да се сетимо и њих уколико будемо доносили било који закључак о земљама које имају мало медаља.

Две табеле које смо направили спајањем (једну коју смо добили успешно спајајући државе по именима, и другу у којој смо део преосталих земаља спојили по трословном коду) надовезаћемо једну на другу тако да у једној табели имамо све податке о медаљама и геометријским облицима држава. Надовезивање табела вршимо функцијом [concat](https://pandas.pydata.org/docs/reference/api/pandas.concat.html) којој прослеђујемо листу табела, а ако искористимо и аргумент `ignore_index=True` новодобијена табела биће индексирана целим бројевима почев од 0.

svet_medalja = pd.concat([svet_medalja,drzave_dodatak],ignore_index=True) # nadovezivanje tabele drzave_dodatak na tabelu svet_medalja, rezultat ponovo cuvamo pod imenom svet_medalja
svet_medalja.tail() # pogledajmo poslednje redove tabele da budemo sigurni da su dodatne drzave tu

Погледајмо опет за проверу попуњеност нове табеле:

svet_medalja.info()

Овде примећујемо да табела `svet_medalja` иако садржи геометријску колону, није препозната као `geopandas` већ као `pandas` објекат. То је последица спајања табела, зато што је резултат коришћења функције `merge` табела, тј. `pandas` `DataFrame`, што још једном можемо проверити и користећи функцију `type`.

type(svet_medalja)

Иако вам се ово може учинити небитним, чињеницом да је наша табела променила тип под којим је пајтон схвата, чини да се неке функције другачије понашају. На пример, ако сада пробате да искористите функцију `plot` надајући се да ћете добити плаву мапу као раније, добићете заправо линијски график, што је подразумевани график када се `plot` функција примени над панда табелама. Зато што ми у наставку желимо да цртамо мапе, променићемо тип тебеле из панда у геопанда формат на следећи начин и уверити се да је то прошло успешно:

svet_medalja = gpd.GeoDataFrame(svet_medalja)
type(svet_medalja)

После дугог увода, сада је време за цртање! Ако поново само позовемо функцију `plot` иако наша нова табела има више података, опет ћемо добити само плаву мапу свих земаља (појавиће се бели простори уместо земаља које нису део овог скупа), али остали подаци, осим геометријских неће никако бити искоришћени (пробајте `svet_medalja.plot()`).

Да би искомуницирали да желимо да се колона са укупним бројем медаља `Total` искористи за бојење мапе, у функцији ћемо то демонстрирати кроз `column` аргумент. Најосновнија верзија коју тиме добијамо је:

svet_medalja.plot(column = 'Total')

Добили смо шарену мапу, али има још пуно посла да је упристојимо. На пример, не знамо које боје одговарају којим вредностима, да ли су плавичасто обојене државе боље од жутих и зелених? (Ми наравно знамо пошто већ неко време баратамо овим олимпијским подацима, али било ко коме желимо да покажемо наш учинак неће знати.) Додатно, имамо пуно белог простора на местима где знамо да постоје државе - то је зато што те државе нису освојиле медаље па нису део нашег скупа, али и њих желимо некако да прикажемо. Коначно, за приказ ове мапе нам не требају х и у осе, тј. оквир око мапе и то ћемо искључити у наставку:

fig, ax = plt.subplots(figsize=(10, 8)) # definisemo sliku malo vecih dimenzija da lepo sagledamo mapu

svet.plot(ax=ax,color='lightgrey',alpha=0.6) # crtamo ceo svet sive boje da bi i zemlje bez medalja postojale na mapi
#preko crtamo prethodno prikazanu mapu
svet_medalja.plot(column = 'Total', # kolona po cijim vrednostima bojimo drzave
                  cmap='cividis', # paleta boja
                  ax=ax, # na ovaj nacin definisemo da se i ova mapa nalazi na istom mestu ao i prethodna 
                  legend=True, # hocemo da imamo legendu da bi znali koja boja odgovara kom broju medalja
                  legend_kwds={'label': "Ukupan broj medalja osvojen na OI 2012",'orientation': "horizontal"}) # ime i pozicija legende
plt.axis('off') # izbacijume x/y ose
plt.show()

Видимо да је велики део света истакнут неком живахнијом бојом од сиве, што значи да је велики број држава освојио бар једну медаљу на олимпијским играма. Видимо да сивих региона (држава које се или нису такмичиле или нису освојиле ни једну медаљу) има много више у јужним деловима света, док су државе најближе жутој боји углавном у северним деловима и означавају типично развијенији и богатији део света (Кина, Русија, Америка, земље западне Европе).

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Обојите државе по броју освојених златних медаља.
Помоћ, пре коришћење истог кода, издвојите само оне редове табеле у коме је број златних медаља већи од 0 да не бисте плавом бојом добили истакнуте и оне земље које постоје у скупу података али имају 0 златних медаља. Пробајте и неку другу палету боја: https://matplotlib.org/stable/tutorials/colors/colormaps.html</div> 

# # resenje
# fig, ax = plt.subplots(figsize=(10, 8)) # definisemo sliku malo vecih dimenzija da lepo sagledamo mapu

# svet.plot(ax=ax,color='lightgrey',alpha=0.6) # crtamo ceo svet sive boje da bi i zemlje bez medalja postojale na mapi
# #preko crtamo prethodno prikazanu mapu
# svet_medalja[svet_medalja.Gold>0].plot(column = 'Gold',
#                   ax=ax, # na ovaj nacin definisemo da se i ova mapa nalazi na istom mestu ao i prethodna 
#                   cmap='copper',
#                   legend=True, # hocemo da imamo legendu da bi znali koja boja odgovara kom borju medalja
#                   legend_kwds={'label': "Broj zlatnih medalja osvojen na OI 2012",'orientation': "horizontal"}) # ime i pozicija legende
# plt.axis('off') # izbacijume x/y ose
# plt.show()

У претходним визуелизацијама, поред броја медаља цртали смо и успешност држава у погледу процена тимова који су се са олимпијских игара вратили са медаљом, хајде да видимо да ли се земље са великом успешношћу некако групишу на мапи света:

fig, ax = plt.subplots(figsize=(10, 8)) # definisemo sliku malo vecih dimenzija da lepo sagledamo mapu

svet.plot(ax=ax,color='lightgrey',alpha=0.6) # crtamo ceo svet sive boje da bi i zemlje bez medalja postojale na mapi
#preko crtamo prethodno prikazanu mapu
svet_medalja.plot(column = 'Uspesnost_timova',
                  cmap='cividis',
                  ax=ax, # na ovaj nacin definisemo da se i ova mapa nalazi na istom mestu ao i prethodna 
                  legend=True, # hocemo da imamo legendu da bi znali koja boja odgovara kom borju medalja
                  legend_kwds={'label': "Procenat državnih timova koji se vratio sa medaljom",'orientation': "horizontal"}) # ime i pozicija legende
plt.axis('off') # izbacujemo x/y ose
plt.savefig("sport_slike/Mapa_uspesnih_timova_OI2012.svg")
plt.show()

Задржали смо исте боје као на слици са укупним бројем медаља да бисмо лакше уочили прерасподелу победничких земаља. Сада видимо да је пар земаља са највећом успешношћу груписан у Африци, иако је претходн тај регион био обојен тамнијим бојама зато што свеукупно нису освојили пуно медаља. Видимо такође да државе које су освојиле највише медаља (првих пар) свакако има и велику процентуалну успешност, док је за велики број осталих земаља карактеристичније да се тек сваки десети тим који учествује, врати са медаљом кући.

Последњу слику смо и сачували да демонстрирамо употребу функције `savefig` потражите сачувану слику у локалном фолдеру.

Мапе су генерално атрактиван тип визуелизација зато што смо се кроз образовање највише сретали са њима на часовима географије, сви користимо апликације са мапама, стога су доста природан начин комуникације информација. Међутим, треба и са њима, као и са другим визуелизацијама бити опрезан и разумети шта су им предности и мане. Поред поменуте фамилијарности, предност мапа је и у томе што можемо на основу њих генерисати нова питања и хипотезе ако видимо да се државе (или градови или региони ако тако нешто цртамо) које имају сличне показатеље групишу и на основу тога можемо наставити даљу анализу.

Са друге стране, овакве мапе (које на енглеском можете наћи као *choropleth* мапе) као и раније коментарисане табеле нацртане уз помоћ функције *heatmap* нису добар избор ако је ваш циљ да посматрачи прочитај тачан број освојених медаља или тачан проценат успешности на олимпијским играма. Додатно, површина на мапи, односно репрезентација државе везана је за величину државе, али то није нужно квалитет који је кључан за вашу анализу. На пример, и у нашем случају видимо да неке од Европских држава имају упечатљивије боје, али због њихових мањих димензија оне нису тако јако уочљиве као Аустралија или неке друге државе.
Компромисно решење је да у комбинацији са визуелизацијом на мапи, којом комуницирате један део приче на атрактиван начин, кључне вредности које желите да читаоци виде комуницирате поред и неком једноставном а ефектном визуализацијом, на пример, стубићима.

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Нацртати мапу са бројем послатих тимова на ои 2012.</div> 

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Нацртати мапу на којој су земље обојене "бинарно" тј ако су освојиле бар једну медаљу имају неку боју, а ако нису имају другу.</div>

# # resenje zadatka 2

# svet_medalja['Ima_medalju'] = (svet_medalja['Total']>0)

# fig, ax = plt.subplots(figsize=(10, 8)) # definisemo sliku malo vecih dimenzija da lepo sagledamo mapu

# svet.plot(ax=ax,color='lightgrey',alpha=0.6) # crtamo ceo svet sive boje da bi i zemlje bez medalja postojale na mapi
# #preko crtamo prethodno prikazanu mapu
# svet_medalja.plot(column = 'Ima_medalju',
#                   cmap='cividis',
#                   ax=ax) # na ovaj nacin definisemo da se i ova mapa nalazi na istom mestu ao i prethodna) 
# plt.title('Države koje su osvojile bar jednu medalju na OI 2012')
# plt.axis('off') # izbacujemo x/y ose
# plt.show()

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Нацртати мапу укупног броја добијених медаља на зимским олимпијским играма 2014 године (за ово је потребно поновити и анализе из претходне лекције којим припремате податке о медаљама за сваку земљу).
</div> 
## 6. Да ли су богате државе успешније на олимпијадама?

У претходним лекцијама видели смо да неке земље шаљу врло мали број тимова на олимпијаду, али су у њима изузетно успешнe (нпр. Етиопија је освојила 7 медаља а послала 14 тимова, а Јамајка 12 медаља на 25 тимова, на ОИ 2012). Са друге стране, неке земље имају изузетно велики број представника у различитим олимпијским дисциплинама, али се не враћају кући са пуно медаља (нпр. Португал и Венецуела су имали по преко 70 тимова, а вратили су кући по једну медаљу, на ОИ 2012). 

А када смо приказивали ове податке на мапи, могли смо да уочимо и неке географске правилности у овим стратегијама. На пример, када смо посматрали само број тимова који представљају земљу на олимпијади, видели смо да су истакнутије биле земље које се углавном налазе у северним деловима света. Слично и када смо посматрали укупан број добијених медаља. Међутим, када смо погледали освојен број медаља у односу на могућ број медаља које је земља могла да освоји (тј. број освојених медаља нормиран бројем дисциплина у којима се држава такмичила) видели смо како се истичу и неке земље са такозваног "глобалног југа". Ова запажања могу нас подстаћи да упоредимо успех земаља на олимпијским играма и са неким другим карактеристикама земљама које се такмиче. Можемо се запитати:
- да ли је број медаља у вези са бројем становника државе? Може бити да су земље које имају већи број становника имале веће шансе да међу становницима пронађу златне олимпијце и олимпијке.
- да ли је број медаља у вези са богатством државе? Тренирање за олипијске игре, али и учествовање на њима, су скупа забава, стога може бити да земље које имају више новца могу послати више тимова, могу освојити више медаља и слично.

Хајде да проверимо ове идеје укрштајући олимпијске податке са подацима о богатству и броју становника различитих држава. 

# ucitavanje biblioteka koje su nam potrebne za rad

import pandas as pd # biblioteka za manipulaciju tabelarnim podacima 
import matplotlib.pyplot as plt # biblioteka za vizualizaciju podataka
import seaborn as sns # biblioteka za vizualizaciju podataka
import plotly.express as px # biblioteka za interaktivnu vizualizaciju podataka

# ucitavanje pripremljenih podataka o medaljama na OI 2012

sve_medalje = pd.read_csv('sport_podaci/oi2012_medalje_po_zemljama.csv')
sve_medalje.info(2)

Поред до сада коришћених и припремљених података о олимпијском успеху држава, учитаћемо податке о богатству држава и броју становника. Оба скупа података издвојили смо за исту, 2012 годину, из података са сајта [Gap minder](https://www.gapminder.org/data/). Подаци о броју становника базирани су на подацима Уједињених нација, док су подаци којима меримо богатство државе, подаци о бруто националном дохотку по глави становника (**овде ћу додати неки разумљив чланак о томе шта је то**) који су базирани на подацима Светске банке.

sve_medalje = pd.read_csv('sport_podaci/oi2012_medalje_po_zemljama.csv') # ucitavanje tabele o medaljama na oi2012
podaci_drzave_2012 = pd.read_csv('sport_podaci/populacija_gdp_2012.csv') # ucitavanje tabele o stanovnistvu i bogatstvu drzava 
podaci_drzave_2012.head() # pregled prvih 5 redova nove tabele

За анализу и цртање нам је као и до сада згодно да ове податке спојимо у исту табелу са подацима о медаљама, тако да крећемо од спајања табела и овог пута:

podaci_za_crtanje = pd.merge(left=sve_medalje,right=podaci_drzave_2012,left_on='Team',right_on='country',how='left') # spajamo tabele
podaci_za_crtanje.info() # informacije o spojenoj tabeli

Након спајања смо функцијом `info` проверили попуњеност и тип података у колонама. Видимо да нисмо за свих 85 држава које су освојиле неку од медаља пронашли податке о бруто дохотку и броју становника. Непотпуни подаци су честа ствар и генерално се трудимо да их има што мање, али пар процената изгубљених података може бити сасвим ок. Погледаћемо које земље су у питању (користећи функцију [isna](https://pandas.pydata.org/docs/reference/api/pandas.isna.html) чија вредност је `True` када ћелија не садржи податак) и наставићемо анализу без њих:

podaci_za_crtanje[podaci_za_crtanje.gdppercapita2012.isna()] # izdvajamo deo tabele u kome su ćelije BDP kolone NaN

podaci_za_crtanje[podaci_za_crtanje.population2012.isna()] # izdvajamo deo tabele u kome su ćelije stanovništvo kolone NaN

Видимо да за 2 земље немамо ни број становника ни БДП и обе земље су имале врло мало медаља. Како се наша анализа више фокусира на особине земаља које им можда доприносе да се број медаља повећа, изостанак ове две земље неће нас превише омести. Уколико на пример дођемо до неких закључака који се специјално односе на земље са малим бројем медаља, ваљало би потражити друге изворе података за број становника или БДП да би се проверило да ли ти евентуални закључци стоје и у случају ове две земље.

У потрази за узајамном повезаношћу неке две колоне података, први корак је често визуелни. За то обично користимо тачкасте или *scatter* дијаграме (користећи функције [scatter](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.scatter.html) или [scatterplot](https://seaborn.pydata.org/generated/seaborn.scatterplot.html) зависно од тога коју библиотеку користимо, *matplotlib.pyplot* или *seaborn*). Да илуструјемо тај метод, испитајмо у каквој су вези број тимова који држава шаље на олимпијске игре и број медаља које дата земља освоји. Дијаграмом ћемо то представити тако што ће свака држава бити тачкица, а њене х и у координате вредности из колона `Broj_timova` и `Total`:

sns.scatterplot(data = podaci_za_crtanje, # tackasti dijagram koji za izvor podataka koristi tabelu  podaci_za_crtanje
                x ='Broj_timova', y = 'Total') # prosledjujemo imena kolona koje ce se koristiti za x i y koordinate
plt.plot([0,100],[0,100],color='grey') # crtamo i liniju x=y sive boje
plt.show() # prikaz grafika

Видимо да постоји нека узајамна веза између ове две колоне - то видимо тако што су тачкице нису насумично распоређене по простору, већ су груписане у један издужен регион који се речима може описати као да тачкице (тј. појединачне државе) што су више десно (тј. што имају више тимова), то су више горе (тј. имају више медаља). Ова "веза" између колона коју смо визуелно оценили, није неочекивана. Са једне стране, није могуће да држава има више медаља него што има тимова који се за медаље такмиче, што значи да све тачкице на овом дијаграму морају по природи ствари да буду десно од сиве линије коју смо доцртали. Та линија означава максималан (и немогућ) број медаља сваке државе, тј. ситуацију у којој је укупан број медаља једнак броју тимова. Са друге стране, није неочекивано да државе које на олимпијаду шаљу пуно тимова имају и неки други квалитет - нпр. јаку традицију спорта, пуно новца и слично - што је можда узрок великом броју медаља.

Визуелна оцена повезаности две колоне података може бити и квантификована мером која се зове **коефицијент корелације**, и можете је израчунати користећи функцију [corr](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.corr.html). Пре рачунања вредности корелације, хајде прво да нацртамо праву линију која најбоље описује нацртане податке. То можете урадити користећи фунцкију [regplot](https://seaborn.pydata.org/generated/seaborn.regplot.html) која црта линију која је најмање удаљена од свих нацртаних тачака.

sns.regplot(data = podaci_za_crtanje, x ='Broj_timova',y = 'Total',ci=None) # prava linija koja je najmanje udaljena od svih tacaka datih x i y klonama
plt.xlabel('Укупан број тимова на олимпијади')
plt.ylabel('Укупан број освојених медаља')
plt.show() # prikaz grafika

Више о корелацијама можете прочитати у речнику статистичких појмова на крају курса (и у другим темама, нпр. у лекцијама о јавном здрављу), а интуитивно о њима можете мислити као о мери повезаности и што су тачке ближе правој линији то је апсолутна вредност корелације ближа јединици. Вредности корелације крећу се између -1 и 1, позитивна корелација говори да је пораст једне варијабле, праћена порастом друге (као на пример на горњем графику). Варијабле код којих је пораст једне праћен падом вредности друге имају негативну корелацију. Корелацију блиску 0 можете лако препознати на графицима када све тачкице делују насумично распређене, без могућности да нацртате било коју линију за коју можете да кажете да добро описује ваше податке. 

У случају горњег графика, иако нацртана линија није идеалан опис података, она сумира тренд који смо претходно описивали речима и делује да је велики број тачкица у њеној непосредној близини. Стога бисмо очекивали да је корелација позитивна и релативно висока, хајде да видимо:

podaci_za_crtanje[['Broj_timova','Total']].corr()

Функција `corr` враћа матрицу корелација између сваке две колоне. Природно, корелација колоне података са самом собом је максимална, тј. 1 (пробајте и графички да се уверите у то цртањем тачкица!), те је корелација која нас занима број који можете прочитати у пресеку одговарајућих колона. Ова табела има превише поновљених информација с обзиром на нашу потребу за једним коефицијентом корелације између две колоне, алтернативни начин да дођемо само до једног броја је овај (наравно, можете издвојити и одређену ћелију претходно добијене табеле):

podaci_za_crtanje['Broj_timova'].corr(podaci_za_crtanje['Total'])

Високе корелације, не значе да постоји каузална веза између посматраних варијабли, те на пример у овом случају висока корелација не значи да је довољно послати више тимова на олимпијаду и надати се да ће се они нужно вратити са више медаља. Међутим високе корелације могу отварати нове интересантне поводе за истраживање зато што је могућ узрок високих корелација између две варијабле постојање неке треће. На пример, држава која има доста новца може можда финансирати више тренинга, бољу опрему и боље тренинге, те стога послати више одличних спортиста на олимпијске игре који ће се вратити са више медаља. У наставку ћемо истраживати да ли постоји таква веза у подацима које имамо.

Пре наставка, још један коментар на претходне графике и корелације - обратите пажњу, корелације трагају само за линеарним везама, тј. правим линијама. То значи да ако видите да су ваши подаци такви да би нека компликованија линија (парабола, део кружнице, нека таласаста линија попут синусоиде) пролазила ближе тачкицама од праве линије, корелација неће детектовати постојање такве везе.

Погледајмо сада у каквој су вези БДП државе и број тимова који земљу представљају на олимпијади. Искористићемо опцију да бојом на овом тачкастом дијаграму истакнемо земље са више медаља, тако што ћемо аргументу функције `hue` проследити име колоне чије вредности треба искористити за бојење:

plt.figure(figsize=(8,5)) # velicina slike
plt.scatter(podaci_za_crtanje['gdppercapita2012'], podaci_za_crtanje['Broj_timova'],c=podaci_za_crtanje['Total']) # tackasti dijagram
plt.colorbar() # dodavanje legende za boje
plt.xlabel('БДП државе 2012 године (у америчким доларима)') # ime x ose
plt.ylabel('Број тимова представника на ОИ 2012') # ime y ose
plt.show()

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Овај график може вам послужити за мисаону и практичну вежбу утврђивања да ли постоји корелација међу нацртаним варијаблама. Нацртајте линију која је најближа тачкицама и израчунајте коефицијент корелације. </div> 

# resenje
# sns.regplot(data = podaci_za_crtanje, x ='gdppercapita2012',y = 'Broj_timova',ci=None)
# plt.show()
# print('koeficijent korelacije je %1.2f'%podaci_za_crtanje['gdppercapita2012'].corr(podaci_za_crtanje['Broj_timova']))

Веза између броја тимова и богатства мереног кроз БДП државе не делује тако јасно као на претходном графику. Највише држава има у левом доњем делу, са мањим богатством и мање од 100 тимова на олимпијади. Изван тог региона видимо да су жутом и зеленом бојом истакнуте тачкице са највише медаља које имају мањи и умерен БДП. Државе које имају највише богатствар нису ни оне које имају највише представника ни медаља са олимпијаде. 

Хајде да погледамо како изгледа сличан график, али где ћемо на у оси представити успешност тимова. Сетите се, то је проценат тимова једне државе који се вратио кући са медаљом. Већ гледајући претходни график недостајале су нам информације о томе која тачкица одговара којој држави, зато ћемо нову верзију графика нацртати у интерактивној форми да можемо лако задовољити знатижељу преласком мишем преко кружића који нас занима.

Интерактивни тачкасти дијаграм цртамо помоћу функције [`scatter`](https://plotly.com/python/line-and-scatter/) у оквиру `plotly express` библиотеке. Као и претходно, функцији прослеђујемо табелу података уз инструкције која колона да се користи за х и у координате, боју и величине кружића. Новина је што можемо дефинисати и из које колоне да се преузму подаци за приказивање преласком миша преко кружића `hover_name`.

fig = px.scatter(podaci_za_crtanje, 
                 x="gdppercapita2012", y="Uspesnost_timova",size='Broj_timova', color="Total",
                 hover_name='Team', # ime kolone koju koristimo da ispise ime zemlje pri prelasku misa preko kruzica
                 labels={ # menjamo imena x,y osa umesto imena odgovarajucih kolona napisacemo nesto malo informativnije
                     "gdppercapita2012": "Бруто домаци производ по глави становника ($)",
                     "Uspesnost_timova": "Проценат тимова који се вратио кући са медаљом",
                     "Total": "Укупан број освојених медаља"
                 }
                )
fig.update_layout(template= 'plotly_white') # definisemo template sa belom pozadinom
fig.show() # prikaz grafika

Иако вам се иницијално може учинити да можда постоји нека структура (на шта нас највише наводи чињеница да нема пуно кружића у горњем десном делу), велика густина прилично насумичних тачкица у доњем левом делу чини да је тешко уочити неку праву линију, тј. правац који се издваја. Но проверите то рачуном коефицијента корелације и цртањем линије која је најближа тачкицама. 

Са друге стране, и без јаке везе међунацртаним варијаблама, видимо неке интересантне кружиће. На пример, најмање три тачкице горе лево - три земље које нису имале пуно тимова (то је означено величином круга), али су биле најуспешније (другим анализама смо већ установили које су то земље, преласком миша преко кружића уверите се у то). Из ових земаља се практично сваки други тим који се такмичио вратио кући са освојеном медаљом и поред чињенице да су те земље међу онима са најмањим богатсвом у скупу података. Додатно можете идентификовати и остале кружиће који се издвајају, нпр. која држава је истакнута жутом бојом зато што има највише медаља, високо богатство и врло високу успешност? Највише тачкица и на овом графику има у доњем левом делу, са малим богатством и малом успешношћу тимова, иако међу њима има и већих кружића (дакле више тимова) и истакнутијих боја (дакле више медаља) - потражите их. 

# resenje pitanja o korelacijama na ovom grafiku - crtanjem linije i procenom i racunom koeficijenta korelacije

# sns.regplot(data = podaci_za_crtanje, x ='gdppercapita2012', y = 'Uspesnost_timova')
# plt.show()
# print('koeficijent korelacije je %1.2f'%podaci_za_crtanje['gdppercapita2012'].corr(podaci_za_crtanje['Uspesnost_timova']))

Односе између различитих колона података које смо видели графички, можемо сумирати матрицом корелација између сваке две од варијабли:

podaci_za_crtanje = podaci_za_crtanje.rename(columns={'gdppercapita2012':'БДП по становнику',
                                                      'Total':'Укупан број медаља',
                                                      'Broj_timova':'Број тимова',
                                                     'Uspesnost_timova':'Успешност тимова'}) # menjamo imena kolona u informativnije nazive na cirilici za buducu ilustraciju

korelaciona_matrica = podaci_za_crtanje[['БДП по становнику','Укупан број медаља','Број тимова','Успешност тимова']].corr() # matrica koeficijenata korelacije
korelaciona_matrica

Ову табелу можемо приказати и визуелно користећи функцију [heatmap](https://seaborn.pydata.org/generated/seaborn.heatmap.html) коју смо и раније користили (нпр. у лекцији о популарности различитих спортова на летњим олимпијским играма):

sns.heatmap(korelaciona_matrica, # matrica koju vizualizujemo
            annot=True, # da ne bismo elemente matrice samo poredili na osnovu nijanse, napisaćemo na svakom mestu i broj
            cmap='seismic', #izbor boja, koristimo divergentnu mapu da bismo lakše istakli pozitivne i negativne vrednosti
            vmin=-1, vmax=1) # minimalna i maksimalna vrednost
plt.show() 

Видимо да је највећа корелација (када занемаримо тривијалну корелацију варијабли самих са собом) између броја тимова и укупног броја медаља коју смо дискутовали на почетку. Такође, укупан број медаља и успешност тимова су умерено позитивно корелисане. Богатство је слабо позитивно корелисано са бројем тимвоа и укупним бројем медаља, а практично није корелисано са успешношћу тимова.
Одавде закључујемо да информације о богатству државе мереном кроз бруто домаћи производ нису јако повезане са успехом држава на олимпијадама. Може бити да неке друге информације о финансијама државе, на пример који део новца се улаже у спорт, постојање инфраструктуре за тренинг и слично могу боље описати разлике међу државама у погледу олимпијског пласмана.

<div class="alert alert-block alert-info"><img src="sport_slike/zad.png" align="left"/>Истражите визуелно и уз помоћ коефицијента корелације да ли је бројност становника државе у вези са успехом на олимпијадамa користећи колону `population2012`. </div> 

# resenja

# plt.figure(figsize=(10,5))

# plt.subplot(1,2,1)

# sns.scatterplot(data = podaci_za_crtanje, x ='population2012', y = 'Total',size='Broj_timova')

# plt.subplot(1,2,2)

# sns.scatterplot(data = podaci_za_crtanje, x ='population2012', y = 'Total',size='Broj_timova')
# plt.xscale('log')
# plt.yscale('log')


# resenja

# plt.figure(figsize=(10,5))

# plt.subplot(1,2,1)

# sns.scatterplot(data = podaci_za_crtanje, x ='population2012', y = 'Uspesnost_timova',size='Broj_timova',hue='Total')

# plt.subplot(1,2,2)

# sns.scatterplot(data = podaci_za_crtanje, x ='population2012', y = 'Uspesnost_timova',size='Broj_timova',hue='Total',legend=False)
# plt.xscale('log')

# resenja
# podaci_za_crtanje[['population2012','Total','Broj_timova','Uspesnost_timova']].corr()
# Како описати јавно здравље?
Здравствено стање неке особе је комплексан феномен чије описивање захтева прикупљање велике количине разнородних података: крвне слике, физичког прегледа, ултразвучних снимака, историје болести и сл. Када је потребно описати здравстено стање веће групе људи или чак целе нације, простор истраживачке анализе се додатно усложњава и постаје у правом смислу вишедимензионалан, односно *мултиваријатан*. То значи да је за извођење валидних и употребљивих закључака потребно измерити велики број својстава, тј. *варијабли* на великом узорку испитаника. Резултати овако опсежних истраживања су веома драгоцени, не само да би се добила повратна информација о најчешћим здравствим проблемима грађана, већ и да би се уочиле повезаности и међусобни утицаји измерених варијабли. Након тога се могу донети поуздане стратегије јавног здравља у оквиру којих би се грађани информисали о понашањима која су штетна или корисна за њихово физичко и психичко благостање.
### Пример података о јавном здрављу
У САД се у оквиру програма __[**National Health and Nutrition Examination Survey (NHANES)**](https://www.cdc.gov/Nchs/Nhanes/about_nhanes.htm)__ сваке године спроводи истраживање о здравственом стању становника и њиховим навикама у исхрани. Подаци се прикупљају интервјуисањем и физичким прегледом на *репрезентативном узорку* од 5.000 грађана. Репрезентативност је веома важна карактеристика узорка која омогућава да се закључци донети на узорку генерализују на целу популацију. То значи да узорак мора да буде формиран насумично и да укључи особе које се разликују по свим релевантним варијаблама као што су нпр. пол, старост, образовање, место живљења, начин исхране и сл. Пример који ћемо користити у овом поглављу садржи више од 1.000 различитих варијабли, а односи се на NHANES податке за 2013. и 2014. годину.

Свака статистичка обрада треба да започне *описом података*, односно прегледањем структуре табеле са подацима, њене попуњености, анализом карактеристика варијабли. На тај начин процењујемо које могућности нам свака од варијабли нуди за анализу. Најпре ћемо излистати све табеле које су доступне у оквиру поменутог скупа података у `csv` формату. Датотеке се налазе у директоријуму `podaci` чији садржај ћемо приказати уз помоћ функције `listdir` модула `os`. Уз помоћ овог модула могуће је обављати различите операције везане за рад оперативног система на корисничком рачунару као што је прављење директоријума, брисање датотека, прегледање величине датотека и сл.

import os

# Уз помоћ for петље пролазимо кроз садржај директоријума 
# Назив датотеке смешта се у варијаблу tabela и исписује командом print()

for tabela in os.listdir('podaci'):
    print (tabela)

Видимо да су варијабле груписане у шест категорија: <ol><li>демографски подаци (demogrpahics),</li><li>подаци о начину исхране (diet),</li><li>резултати медицинског прегледа (examination),</li><li>резултати лабораторијских анализа (labs),</li><li>подаци о коришћеним лековима (medications) и</li><li>упитнички подаци (questionnaire).</li></ol> Последња датотека обухвата велики број одговора на питања везана за здравствене навике становника: пушење, конзумирање алкохола, вакцинације, физичку активност и друго.

За почетак ћемо учитати демографске податке и приказати називе варијабли. На овом месту први пут учитавамо библиотеку `pandas` за рад са табелама података (engl. *dataframes*). 

import pandas as pd

podaciDem = pd.read_csv('podaci/demographic.csv')
podaciDem.info()

На основу извештаја се види да табела садржи податке о 47 својстава (варијабли) за 10.175 испитаника. Називи варијабли нису саморазумљиви што показује колико је важно да се свакој табели са подацима придружи и одговарајућа датотека у којој су описане све употребљене скраћенице, начин прикупљања података, ознаке или тзв. *кодови* за податке који недостају (нпр. *NaN*, *N/A* или празно поље), значења вредности сваке варијабле (нпр. 1 - веома лоше, 5 - веома добро) и све друго што је непходно да би се подаци из табеле на одговарајући начин употребили. Детаљне описе варијабли које се налазе у овој матрици можете пронаћи нa __[**овој адреси**](https://wwwn.cdc.gov/Nchs/Nhanes/Search/variablelist.aspx?Component=Demographics&CycleBeginYear=2013)__.

Погледајмо најпре какве су расподеле типичних демографских варијабли исцртавањем графикона доступних у оквиру библиотеке `matplotlib`. Кренућемо од варијабле *пол* (RIAGENDR).

import matplotlib.pyplot as plt

# Исцртавамо графикон (plot) типа хистограм (hist) 
podaciDem['RIAGENDR'].plot(kind='hist')
# Дајемо име x-оси
plt.xlabel('Пол')
# Дајемо име и y-оси
plt.ylabel('Број испитаника')  
# Приказујемо графикон
plt.show() 

 Сада ћемо вредности исте варијабле исцртати на мало другачији начин. Нећемо их третирати као бројеве, већ као обичне ознаке или слова. Ознаке 1 и 2 ћемо пребројати помоћу функције `value_counts()`. Пошто се након примене ове функције вредности сортирају по њиховој учесталости, употребићемо и функцију `sort_values()`. На тај начин ћемо накнадно имати бољу контролу над ознакама вредности на x-оси коришћењем функције `xticks()` јер ће вредност првог подеока бити 1 (мушко), а другог 2 (женско). То нам омогућава и да цифре заменимо словима која су разумљивија.  

podaciDem['RIAGENDR'].value_counts().sort_values().plot(kind='bar') 
plt.xlabel('Пол')
plt.ylabel('Број испитаника')
plt.xticks(ticks=[0,1], labels=['М','Ж'], rotation=0) 
plt.show()

Дистрибуцију варијабле пол исцртали смо на два начина, најпре хистограмом (hist), а потом стубичастим дијаграмом (bar). Иако су ови графикони на први поглед слични, међу њима постоји суштинска разлика. Први се обично користе за приказивање расподела *квантитаитвних* варијабли, а други за оне које су *квалитативне*. Вредности квантитативних варијабли означавају количину неког својства које поседује испитаник (нпр. висина), док вредности квалитативних означавају само припадност категорији (нпр. пол). Пошто су на горњем графикону вредности варијабле пол биле третиране као нумеричке, хистограм је био исцртан са непотебним подеоцима, односно интервалима вредности на x-оси. 

У случају да је варијабла *категоријална*, односно квалитативна (нпр. брачни статус) или квантитативна са мањим бројем вредности (нпр. школске оцене), разлика између хистограма и стубичастог дијаграма није толико очигледна. Зато увек треба обратити пажњу на значење вредности приказаних на x-оси. Илустроваћемо то примером још неких демографских варијабли. Овога пута ћемо употребити функцију `subplots()` како бисмо направили мрежу графикона којом се оптималније користи простор на екрану. Имајте на уму да смо разбили код који је доста дугачак у нареднe 3 ћелијe како би био прегледнији и како бисмо постепено објаснили шта радимо. Иначе није уобичајено да се овакве мреже праве и попуњавају парцијално.

Дакле, формирајмо најпре мрежу димензија 2 x 3 са шест "кућица" у које ћемо уметнути графиконе.

# Графички објекат (figure) смо назвали mreza, а сваку "кућицу" (axes) gr1 до gr6
mreza, ((gr1, gr2, gr3), (gr4, gr5, gr6)) = plt.subplots(2, 3, figsize=(20,10), facecolor='white')

Кућице су за сада празне тако да за сваку од њих морамо да креирамо графикон. Почећемо са варијаблом *старост* (RIDAGEYR). Графикон ћемо уметнути на прву осу формираног вишедимензионалног графичког објекта (gr1).

# Подесили смо боју оквира стубића на белу да би били визуелно раздвојени
# Подесили смо број стубића (бинс) на 20
podaciDem['RIDAGEYR'].plot(kind='hist', edgecolor='white', bins=20, ax=gr1, color='steelblue')

# У називу x-осе ће поред имена варијабле бити исписане и вредности неких описних показатеља.
# Пошто су у питању бројеви, морамо да их претворим у текст командом str()
gr1.set_xlabel('Узраст\n' # Ознаком \n умећемо прелом реда
    + 'M = ' + str(podaciDem['RIDAGEYR'].mean().round(2)) # Ознаком + повезујемо делове текста
    + ', Mdn = ' + str(podaciDem['RIDAGEYR'].median().round(2))
    + ', Q3 = ' + str(podaciDem['RIDAGEYR'].quantile(0.75).round(2))
    + ', Sk = ' + str(podaciDem['RIDAGEYR'].skew().round(2)), fontsize=12
    )
gr1.set_ylabel('Број испитаника')

# Додајемо број графикона у десни горњи угао (0.95, 0.95)
gr1.text(0.95, 0.95, '1', transform=gr1.transAxes, fontsize=20, color='steelblue', ha='right', va='top')

# Наглашавамо да не желимо да ознаке подеока буду заротиране
gr1.tick_params(labelrotation=0)

# Поново морамо да позовемо објекат mreza да би се графикони исцртали
mreza

Видите да је прва "кућица" попуњена. По истом принципу ћемо генерисати графиконе и за преосталих пет варијабли и позиционирати их у пет празних "кућица". Хоризонтални размак између њих је можда непотребно велик, а наслов x-осе првог графикона додирује четврти. У наредном коду ћемо корговати итај естетски аспект графикона.

# Степен образовања
podaciDem['DMDEDUC2'].value_counts().sort_index().plot(kind='bar', width=1, edgecolor='white', ax=gr2, color='darkorange') 

# Оператором %.2f % вредности заоукружујемо на две децимале
AS = '%.2f' % podaciDem['DMDEDUC2'].mean()
Mdn = '%.2f' % podaciDem['DMDEDUC2'].median()
Mod = '%.2f' % podaciDem['DMDEDUC2'].mode()[0]
Sk = '%.2f' % podaciDem['DMDEDUC2'].skew()
# Вредности описних показатеља умећемо у назив x-осе
gr2.set_xlabel('Степен образовања\n' + 'M = ' + AS + ', Mdn = ' + Mdn + ', Mod = ' + Mod + ', Sk = ' + Sk, fontsize=12)
gr2.text(0.95, 0.95, '2', transform=gr2.transAxes, fontsize=20, color='darkorange', ha='right', va='top')
gr2.tick_params(labelrotation=0)

# Брачни статус
podaciDem['DMDMARTL'].value_counts().plot(kind='bar', width=1, edgecolor='white', ax=gr3, color='mediumseagreen') 
gr3.set_xlabel('Брачни статус', fontsize=12)
gr3.text(0.95, 0.95, '3', transform=gr3.transAxes, fontsize=20, color='mediumseagreen', ha='right', va='top')
gr3.tick_params(labelrotation=0)

# Број чланова домаћинства
podaciDem['DMDHHSIZ'].value_counts().sort_index().plot(kind='bar', width=1, edgecolor='white', ax=gr4, color='darkgray')
AS = '%.2f' % podaciDem['DMDHHSIZ'].mean()
Mdn = '%.2f' % podaciDem['DMDHHSIZ'].median()
Sk = '%.2f' % podaciDem['DMDHHSIZ'].skew()
gr4.set_xlabel('Број чланова домаћинства\n' + 'M = ' + AS + ', Mdn = ' + Mdn + ', Sk = ' + Sk, fontsize=12)
gr4.set_ylabel('Број испитаника')
gr4.text(0.95, 0.95, '4', transform=gr4.transAxes, fontsize=20, color='darkgray', ha='right', va='top')
gr4.tick_params(labelrotation=0)

# Пошто је број деце u домаћинству наведен у две одвојене варијабле,
# за децу млађу од 6 и старију од 5 година, пре приказивања израчунавамo њихову суму 
podaciDem['DMDHHSZAiB'] = podaciDem['DMDHHSZA'] + podaciDem['DMDHHSZB']
podaciDem['DMDHHSZAiB'].value_counts().sort_index().plot(kind='bar', width=1, edgecolor='white', ax=gr5, color='orchid')
gr5.set_xlabel('Број деце у домаћинству', fontsize=12)
gr5.text(0.95, 0.95, '5', transform=gr5.transAxes, fontsize=20, color='orchid', ha='right', va='top')
gr5.tick_params(labelrotation=0)

# Ознака ~ је оператор NOT - не желимо вредности из скупа [77,99]
podaciDem[~podaciDem['INDFMIN2'].isin([77,99])]['INDFMIN2'].value_counts().sort_index().plot(kind='bar', width=1, edgecolor='white', ax=gr6, color='crimson')
AS = '%.2f' % podaciDem['INDFMIN2'].mean()
Mdn = '%.2f' % podaciDem['INDFMIN2'].median()
Mod = '%.2f' % podaciDem['INDFMIN2'].mode()[0]
gr6.set_xlabel('Укупна примања домаћинства (категорије)\n' + 'M = ' + AS + ', Mdn = ' + Mdn + ', Mod = ' + Mod, fontsize=12)
gr6.text(0.95, 0.95, '6', transform=gr6.transAxes, fontsize=20, color='white', ha='right', va='top')
gr6.tick_params(labelrotation=0)

# Мало ћемо смањити вертикални (hspace) и хоризонтални (wspace) простор између "кућица"
mreza.subplots_adjust(hspace=0.25, wspace=0.15)

# Приказујемо коначну верзију мреже, односно графички објекат који се састоји од шест (под)графикона
mreza

Погледајмо најпре зелени графикон (бр. 3) којим је приказана расподела испитаника по категоријама брачног статуса. Нисмо употребили функцију `sort_values()` јер је у питању квалитативна варијабла, па самим тим нумеричке вредности немају ознаку количине или изражености својства, већ служе само као ознака групе. Најфреквентија група је 1 (особе у браку), након чега следе групе 5 (никад нису били у брак) и 3 (разведени). Неколико испитаника није желело да да одговор (77) или није знало одговор (99). Сличне вредности су употребљене за означавање нивоа образовања на наранџастом графикону (бр. 2), али овога пута смо их сортирали јер ипак имају квантитативно значење. Наиме, бројеви нам у овом случају омогућавају да испитанике барем рангирамо по томе који степен образовања су стекли: 1 - мање од основне школе, 2 - основна школа, 3 - средња школа итд. Међутим, и овде постоје ознаке за испитанике који нису желели или нису могли да се изјасне (7 и 9). Ове вредности би у свакој наредној анализи требало избацити, најпре зато што не одговарају логици преосталих вредности (1 < 2 < 3 < 4 < 5), али и зато што их је сразмерно мало. На крају, категоризација је направљена и на основу укупних примања домаћинства: 1 - од 0 до 4.999 долара, 2 - од 5.000 до 9.999, 3 - од 10.000 до 14.999 итд. Ова дистрибуција је приказана на црвеном графикону (бр. 6). Уочите да смо графикон исцртали након што смо из скупа података уклонили вредности 77 и 79 коришћењем оператора негације `~` и функције `isin()`.

Из наведених примера смо видели да слика расподеле података пружа пуно драгоцених информација не само о томе да ли постоје атипичне вредности варијабле, већ и о самој методологији прикупљања података. На пример, на основу плавог графикона (бр. 1) могло би се закључити да је у узорку било око 500 испитаника старих 80 година, али су заправо у ову групу сврстане све особе које имају 80 или више година. То значи да би дистибуција узраста имала још издуженији "реп" са десне стране да су забележене тачне године старијих испитаника. Овакав облик дистрибуције називамо *искошеним удесно*. Постоји и статистички показатељ који показује да ли је дистрибуција симетрична и зове се *скјунис*. За дистрибуцију 2 је он већи од нуле, док је за дистрибуције *искошене улево* негативан, као нпр. на наранџастом графинону (бр. 2). Слична агрегација испитаника је обављена и у случају укупних примања где су домаћинства са више од 100.000 долара прихода смештена у категорију 12. Обратите пажњу какав је однос између *артитметичке средине* (M) различитих дисрибуција и њихове *медијане*, односно средишње вредности (Mdn) и *мода*, односно најчешће вредности (Mod). Такође обратите пажњу да је за варијабле којима су означене категорије вредности оправданије користити медијану или мод, на пример за варијаблу приказану на црвеном графикону (бр. 6).

На крају, анализирајте информативност различитих описних показатеља дистрибуције. На пример, уочите да је на плавом графикону (бр. 1) аритметичка средина већа од медијане. Због искошености расподеле, аритметичка средина није иста као и средња вредност већ је померена навише. Дакле, могли бисте да кажете да је половина испитаника у узорку млађа од 26, а не од 31.5 године. Исто тако, коришћењем тзв. *квартила*, који испитанике деле у 4 једнако бројне групе, можете да видите да је око две трећине испитаника (75%) млађе од 52 године, што је вредност трећег квартила (Q3).

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Исцртајте поново графикон за степен образовања, али претходно искључите вредности 7 и 9. Покушајте то да урадите на другачији начин од онога који смо користили, не користећи функцију <b>isin()</b>. Искористите чињеницу да су то вредности мање од неког броја.</div> 

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>На основу љубичастог графикона (бр. 5) одредите колико деце има типично америчко домаћинство. Покушајте да процените колике су вредности M, Mdn и Sk за ову дистрибуцију, а потом их израчунајте. Најједноставније је да копирате код који је дат као параметар функције <i>str()</i>.</div> 

На крају ћемо погледати и како изгледају дистрибуције типичних резултата лабораторијске анализе крви. Употребићимо кутијасти дијаграм (енгл. *boxplot*) којим се истовремено приказује и место груписања и степен распршења резултата. У првом кораку ћемо уз помоћ билиотеке `seaborn` визуализовати варијаблу LDL или тзв. "лоши" холестерол (LBDLDLSI). Паралалено ћемо приказати и хистограм за исту варијаблу да бисте лакше разумели логику кутијастог дијаграма.

# Увозимо библиотеку seaborn
import seaborn as sbrn

# Увозимо подате о лабораторијским анализама
podaciLab = pd.read_csv('podaci/labs.csv')

# Креирамо објекат figure (мрежу) са две осе ("кућице") (ax_box и ax_hist)
# "Кућице" ће делити x-осу (sahrex=True), a visine će im biti u odnosu 20% : 80%
fig, (ax_box, ax_hist) = plt.subplots(2, sharex=True, figsize=(10,6), gridspec_kw={'height_ratios': (0.15, 0.85)})
 
# У горњој "кућици" приказаћемо кутијасти дијаграм
sbrn.boxplot(data=podaciLab['LBDLDLSI'], orient="h", ax=ax_box)
# а у доњој хистограм за исту варијаблу
sbrn.histplot(data=podaciLab['LBDLDLSI'], ax=ax_hist)
 
# Уклањамо име и подеоке y-осе кутијастог дијаграма
ax_box.set(xlabel='', yticklabels='')

# Подешавамо назив x-осе хистограма 
ax_hist.set(xlabel='Ниво LDL холестерола у крви', ylabel='Број испитаника')

plt.show()

Централна линија у кутији означава медијану, а димензије кутије одговарају распону средишњих 50% резултата, односно резултата који се налазе између првог и трећег квартила. Први квартил (Q<sub>1</sub>) је вредности испод које се налази 25% испитаника, а трећи (Q<sub>3</sub>) вредност изнад које се налази 25% испитаника. Други квартил је заправо централна вредност или медијана. Распон између првог и трећег квартила је познат као *интерквартилни распон*. Обратите пажњу да је су и на хистограму највиши стубићи управо у овом распону.

Кружићима су представљени аберантни резултати који изразито одступају од централне вредности дистрибуције. Ове резултате у статистици називамо *аутлајерима*. Због њих готово трећина хистограма делује празно. Неколико издвојених вредности изнад 7 много лакше се уочава на кутијастом дјаграму. У нарденим анализама систематски ћемо избацивати ове екстремне резултате како бисмо унапредили прегледност графикона, али и поузданост просечних вредности које би биле неоправдано високе када бисмо их задржали.

Сада ћемо кутијастим дијаграмима приказати ниво триглицерида (LBDTRSI), LDL холестерол (LBDLDLSI) и HDL или "добри" холестерол (LBDHDDSI). 

# Дефинишемо величину графикона
plt.figure(figsize=(10,4))

# Искључујемо 1% екстремно високих вредности сваке варијабле 
grafikon = plt.boxplot([podaciLab[podaciLab['LBDTRSI'] < podaciLab['LBDTRSI'].quantile(0.99)]['LBDTRSI'], 
    podaciLab[podaciLab['LBDLDLSI'] < podaciLab['LBDLDLSI'].quantile(0.99)]['LBDLDLSI'],
    podaciLab[podaciLab['LBDHDDSI'] < podaciLab['LBDHDDSI'].quantile(0.99)]['LBDHDDSI']], 
    vert=False, patch_artist=True, widths=(0.5, 0.5, 0.5))

# Ово су боје које ћемо користити за кутије
boje1 = ['skyblue', 'lightsalmon', 'lightgreen']
# Ово су боје које ћемо користити за оквире кутија и "брчиће"
boje2 = ['steelblue', 'steelblue', 'tomato', 'tomato', 'darkseagreen', 'darkseagreen']

# У овој петљи за сваку кутиу у скупу од три кутије (боxес) подешавамо боју
# кутија и облик маркера преко функције setp (set parameter)
for rb, kutija in enumerate(grafikon["boxes"]):
    plt.setp(kutija, facecolor=boje1[rb], edgecolor=boje2[rb*2], linewidth=2)
    plt.setp(grafikon['fliers'][rb], markeredgecolor=boje2[rb*2], marker='.')

# У овој сређујемо "брчиће"
for rb, brcici in enumerate(grafikon['whiskers']): 
    brcici.set(color =boje2[rb], linewidth = 2)

# У овој вертикалне линије распона
for rb, raspon in enumerate(grafikon['caps']): 
    raspon.set(color =boje2[rb], linewidth = 2)  

# У овој линије којима су исцртане медијане
for rb, medijane in enumerate(grafikon['medians']): 
    medijane.set(color =boje2[rb*2], linewidth = 2)

# Подешавамо ознаке подеока на y-оси
oznakeY = plt.yticks(ticks=[1, 2, 3], labels=['Триглицериди','LDL холестерол','HDL холестерол'], rotation=0)

# Додељујемо назив x-оси
nazivX = plt.xlabel('Ниво у крви (mmol/L)')  

За почетак, на основу броја кружића видимо да је и поред искључивања 1% екстремно високих вредности остало доста испитаника којима су резултати веома високи у односу на типичне вредности. Просечна и централна вредност су највише за LDL, али то не значи да је ту и највећи потенцијални проблем за испитанике јер су можда референтне или "нормалне" вредности за тај показатељ више од осталих. LDL холестерол има и највећу варијабилност унутар 50% средњих вредности, а HDL најмању што видимо по распону "брћића" и дужини кутија.

Обратите пажњу да смо уместо линије кода `for element in skup` употребили петљу у формату `for rb, element in enumerate(skup)`. Методом `enumerate()` смо додали бројач елемената који генерише бројеве од `0` до `број елемената - 1`. На тај начин варијабла `rb` добија редни број вредности сваког елемента скупа, а варијабла `element` вредност елемента na rednom broju `rb`. 

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Potražite na internetu <a href='https://milleniummedic.rs/holesterol-trigliceridi-lipidni-status/'>referentne vrednosti</a> prikazanih pokazatelja i analizirajte distribucije u odnosu na njih.<BR>Da li ispitanici imaju generalno povišene vrednosti ili ne?</div> 

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Покушајте самостално да мењате изглед маркера аберантних резултата и линија на кутијастом дијаграму. Потражите на интернету доступне параметре функције <a href='https://matplotlib.org/stable/api/markers_api.html'><b>markers</b></a> и својства класе <a href='https://matplotlib.org/stable/api/_as_gen/matplotlib.lines.Line2D.html'><b>line2D</b></a> библиотеке <b>matplotlib</b>.</div> 
# Да ли сте гојазни?
У претходној лекцији смо описали неколико демографских варијабли из __[**NHANES**](https://www.cdc.gov/Nchs/Nhanes/about_nhanes.htm)__ скупа података. Сада ћемо се позабавити варијаблама које се тичу здравственог стања испитаника. За почетак ћемо анализирати варијаблу **BMXBMI** која садржи вредности *индекса телесне масе* испитаника (енгл. *BMI - Body Mass Index*). BMI се рачуна као однос телесне масе (тежине) особе и квадрата њене висине. 

Пошто нам је циљ да анализирамо вредности БМИ (BMXBMI) у контексту старости (RIDAGEYR) и пола (RIAGENDR), потребни су нам подаци из две табеле: *demographics.csv* и *examination.csv*. Свака од табела садржи колону под називом SEQN (енгл. *respondent sequence number*) која представља јединствену идентификацију испитаника. На основу те вредности можемо да спојимо редове из различитих табела користећи функцију `merge` модула `pandas`. Да бисмо уштедели мемориски простор, увешћемо само одабране колоне из сваке табеле, а основне скупове ћемо обрисати након формирања новог. Обратите пажењу на број записа (редова) у сваком скупу података. Резултирајући скуп има онолико редова колико има мањи од два скупа података јер резултати лекарског прегледа нису доступни за све испитаника за које су прикупљени демографски подаци. 

import pandas as pd

# Увозимо само три варијабле из матрице demographic.csv
podaciDem = pd.read_csv('podaci/demographic.csv')[['SEQN', 'RIAGENDR', 'RIDAGEYR']]
# и приказујемо број записа (редова)
print("podaciDem: ", len(podaciDem))

podaciMed = pd.read_csv('podaci/examination.csv')[['SEQN', 'BMXBMI']]
print("podaciMed: ", len(podaciMed))

# Повезујемо (merge) претходне две табеле по варијабли SEQN
podaciDemMed = pd.merge(podaciDem, podaciMed, on='SEQN') 
print("podaciDemMed: ", len(podaciDemMed))

# Бришемо привремене оквире који нам више нису потребни
del podaciDem, podaciMed

Најпре ћемо приказати дистрибуцију вредности BMI, овога пута користећи *полигон фреквенција*. Овај дијаграм је веома сличан хистограму јер приказује расподелу учесталости по разлилитим вредностима варијабле, али се уместо стубића користи линија. Полигон ћемо исцртати користећи библиотеку `seaborn`.

import seaborn as sbrn
import matplotlib.pyplot as plt

# Дефинишемо величину графикона
plt.figure(figsize = (9,5))

# Исцртавамо полигон фреквенција (element='poly') за БМXБМИ одвојено за полове (hue='RIAGENDR')
ax = sbrn.histplot(podaciDemMed, x='BMXBMI', hue='RIAGENDR', alpha=0.2, element='poly', palette='Set1')

# Подешавамо наслов графикона и називе оса
ax.set_title('Разлика у дистрибуцијама BMI по полу')
ax.set_xlabel('BMI')
ax.set_ylabel('Број испитаника')

# Учитавамо објекат legend графикона у варијаблу leg
leg = ax.get_legend()
# Да бисмо променили неколико параметара легенде
leg.set_frame_on(False)
leg.set_title('Пол')
leg.texts[0].set_text('мушки')
leg.texts[1].set_text('женски')

# Исцртавамо линије којима су представљене аритметичке средине BMI по полу
ax.axvline(podaciDemMed[podaciDemMed['RIAGENDR']==1]['BMXBMI'].mean(), linestyle='--', color='#346994', lw=1)
ax.axvline(podaciDemMed[podaciDemMed['RIAGENDR']==2]['BMXBMI'].mean(), linestyle='--', color='#c52425', lw=1)

На основу горње слике уочавамо да је БМИ код жена у просеку незнатно виши. Међутим, оно што је за наставак анализе важније, треба уочити да су дистрибуције БМИ за оба пола *искошене удесно* што значи да им је десни "реп" развучен. Оне су такође *бимодалне*. На то нам указују два очигледна "брдашца" која су настала јер се вредности гомилају око два мода, највероватније због тога што узорак чине две различите групе особа. Истраживач би требало да испита могуће узроке ове појаве тако што ће анализирати дистрибуције за различите категорије испитаника које се могу формирати на основу доступних демографских варијабли, нпр. пола, образовања, места станованја и сл. У нашем примеру ћемо исту слику приказати за испитанике различитог узраста. Напрвићемо мрежу (fig) два графикона (ax1, ax2).

# Дефинишемо објекат figure са два места за графиконе у реду
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18,6))

# Поновљен полигон из горњег кода, али за испитанике млађе од 19 година
sbrn.histplot(podaciDemMed[podaciDemMed['RIDAGEYR']<19], x='BMXBMI', hue='RIAGENDR', alpha=0.2, element='poly', ax=ax1, palette='Set1')
ax1.set_title('Разлика у дистрибуцијама BMI по полу (млађи од 19)')
ax1.set_xlabel('BMI')
ax1.set_ylabel('Број испитаника')
leg = ax1.get_legend()
# Уклањамо оквир око легенде
leg.set_frame_on(False)
# Подешавамо наслов легенде
leg.set_title('Пол')
# Подешавање назива првог (0) и другог (1) по реду елемента легенде
leg.texts[0].set_text('мушки')
leg.texts[1].set_text('женски')

# Можете да мењате боју гарфикона користећи неке од палета (palette) билбиотеке matplotlib
# https://matplotlib.org/stable/tutorials/colors/colormaps.html
sbrn.histplot(podaciDemMed[podaciDemMed['RIDAGEYR']>18], x='BMXBMI', hue='RIAGENDR', alpha=0.2, element='poly', ax=ax2, palette='Set1')
ax2.set_title('Разлика у дистрибуцијама BMI по полу (старији од 18)')
ax2.set_xlabel('BMI')
leg = ax2.get_legend()
leg.set_frame_on(False)
leg.set_title('Пол')
leg.texts[0].set_text('мушки')
leg.texts[1].set_text('женски')

Увек треба проверити да ли је оправдано објединити вредности варијабли за различите категорије испитаника, било да је у питању другачија методологија рачунања као у овом случају, или једноставно чињеница да одређена група испитаника има у просеку мање или веће вредности варијабле од друге. То нам се и десило у овој анализи јер млађи испитаници (слика лево) имају у просеку ниже вредности BMI од старијих (слика десно). Приказане дистрибуције BMI формиране на основу узрасне категорије су сада много уједначеније (хомогеније), па су самим тим и описни показатељи поузданији.

У наредном кораку упоредите вредности типичних описних показатеља за укупан узорак и за подузорке подељене по узрасту и полу (1 - мушки, 2 - женски). Обратите пажњу да је хетерогеност испитаника, односно варијабилност резултата изражена *стандардном девијацијом* (std) мања на подузорцима него на целокупном узорку. Другим речима, испитаници су међусобно сличнији у подгрупама него када се посматра обједињен узорак.

# Функција describe() израчунава основне описне показатеље
# Прво их рачунамо за варијаблу BMXBMI на целом узорку уз груписање по полу (RIAGENDR) помоћу функције groupby()  
print("СВИ ИСПИТАНИЦИ\n", podaciDemMed.groupby('RIAGENDR')['BMXBMI'].describe())

# затим за млађе од 19
print("\nMLAĐI OD 19:\n", podaciDemMed[podaciDemMed['RIDAGEYR']<19].groupby('RIAGENDR')['BMXBMI'].describe())

# и на крају за старије од 18 година
print("\nSTARIJI OD 18:\n", podaciDemMed[podaciDemMed['RIDAGEYR']>18].groupby('RIAGENDR')['BMXBMI'].describe())

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Могло би се очекивати да је артиметичка средина на укупном узорку једнака просеку аритметичких средина подузорака, односно млађих и старијих испитника.<BR>Због чега то није није тако већ је ова вредност нешто ближа вредности просека БМИ за старије испитанике?</div> 

За потребе наредне анализе формираћемо категорије испитаника с обзиром на вредност BMI и сместити их у колону `BMIKat`. Постоји више различитих критеријума за категоризацију, али ми ћемо користити ону која је употребљена и у истраживању чије податке користимо. Уочите да смо приликом позивања функције `between` употребили параметар `inclusive='left'` чиме је у распон укључена само његова доња, али не и горња граница. Ово је јако битно да се исти испитаници не би нашли у раличитим категоријама. За лакшу манимулацију низовима података употребићемо библиотеку `numpy`. 

import numpy as np

# Дефинишемо распоне вредности БМИ на основу којих ћемо формирати пет категорија
granice = [ podaciDemMed['BMXBMI'] < 18.5, 
            (podaciDemMed['BMXBMI'].between(18.5, 25, inclusive='left')), 
            (podaciDemMed['BMXBMI'].between(25, 30, inclusive='left')),
            (podaciDemMed['BMXBMI'].between(30, 35, inclusive='left')),
            podaciDemMed['BMXBMI'] >= 35
          ]
# Категорије ћемо означити бројевима
kategorije = [1, 2, 3, 4, 5]
# и дати им називе
kategorijeNazivi = ['испод', 'нормално', 'изнад', 'гојазни', 'веома гојазни']

# Функција select() пакета numpy додељује вредност категорије (1-5)
# новој варијабли (BMIkat) на основу граница у низу granice
podaciDemMed['BMIKat'] = np.select(granice, kategorije, default=np.nan)

# Правимо подскуп за мушкарце
muskarci = podaciDemMed[(podaciDemMed['RIAGENDR']==1) & (podaciDemMed['RIDAGEYR']>18)]['BMIKat'].value_counts().sort_index()
# и подскуп за жене
zene = podaciDemMed[(podaciDemMed['RIAGENDR']==2) & (podaciDemMed['RIDAGEYR']>18)]['BMIKat'].value_counts().sort_index()
# а потом два подскупа спајамо по вертикали функцијом concat()
svi = pd.concat([muskarci.rename('М'), zene.rename('Ж')], axis = 1)

# У посебан скуп ћемо сместити исте вредности, али изражене процентуално
sviProc = svi.copy()
sviProc['sum'] = sviProc['М'] + sviProc['Ж']
# Проценат мушких је број мушких подељен укупним бројем пута 100
sviProc['М'] = sviProc['М'] / sviProc['sum'] * 100
sviProc['Ж'] = sviProc['Ж'] / sviProc['sum'] * 100
# Kolona sum je bila privremena i više nam ne trena u novom skupu
sviProc = sviProc.drop('sum', axis=1)

Након што смо припремили податке у горњој ћелији, употребићемо тзв. *наслагани стубичасти дијаграм* (енгл. *stacked bar chart*). На левом графикону приказаћемо апсолутне бројеве испитаника по различитим категоријама (оквир података `svi` из горњег кода), а на десном исте вредности, али изражене пропорционалнo, тачније процентуално (оквир података `sviProc` из горњег кода). 

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18,6))

svi.plot.barh(edgecolor='white', width=0.8, stacked=True, ax=ax1)
# Параметром fontsize подешавамо величину фонта
ax1.set_yticklabels(kategorijeNazivi, rotation=0, fontsize=13)
# Параметром labelpad мало одмичемо назив осе од саме осе
ax1.set_xlabel('Укупан број (М)ушкараца и (Ж)ена по категоријама BMI', fontsize=13, labelpad=15)

sviProc.plot.barh(edgecolor='white', width=0.8, stacked=True, ax=ax2)
ax2.set_yticklabels(kategorijeNazivi, rotation=0, fontsize=13)
ax2.set_xlabel('Процентуални однос (М)ушкараца и (Ж)ена по категоријама BMI', fontsize=13, labelpad=15)

fig.tight_layout()

Обратите пажњу да на левом графикону максимална вредност на x-оси приближно одговара учесталости најфеквентније групе (особе са прекомерном тежином), док је на десном то вредност 100 (процената). Оба типа графикона имају своје предности и мане. Помоћу левог се лакше пореде учесталости по категоријама БМИ, док се на десном лакше уочава удео мушкараца и жена у свакој групи. Генерално бисмо могли да да закључимо да је међу испитаницима највише оних који имају прекомерну тежини или су гојазни, као и да је посебно велика пропорција жена у групама веома гојазних особа и особа са недовољном тежином. 
# Да ли гојазност утиче на крвни притисак?
У овој лекцији ћемо се бавити једним од најчешћих параметара здравственог стања појединца - крвним притиском. Овога пута ћемо, поред демографских, кориситити и податке о физичком медицинском прегледу (*examination.csv*) и лековима које испитаници користе (*medications.csv*).

import pandas as pd

podaciDem = pd.read_csv('podaci/demographic.csv')
podaciMed = pd.read_csv('podaci/examination.csv')
podaciLek = pd.read_csv('podaci/medications.csv')

Изглед табеле *demographic.csv* погледали смо у првој лекцији. Погледајмо сада каква је структура друге две табеле.

podaciMed.head(5)

Табела *examination.csv* има чак 224 колоне. Ми ћемо се фокусирати на оне са префиксом BPX које се тичу мерења крвог притиска испитаника (енгл. *blood pressure*)

podaciLek.head(5)

Табела *medication.csv* има много мање колона. За нас су битне варијабле које говоре о томе од чега се лечи особа (RXRSD1), односно који лек пије (RXDDRUG).

Погледајмо најпре какве су дистрибуције систолног ("горњег") и дијастолног ("доњег") притиска. Употребићемо тзв. *виолински дијаграм* који је нека врста комбинације стубичастог и кутијастог дијаграма. На основу њега можемо да закључимо око којих вредности се групишу резултати и у којој мери су распршени. У описаном истраживању притисак је мерен четири пута. Приказали смо сва мерења како бисмо за даљу анализу одабрали оно које је најстабилније и у коме резултати најмање варирају, нпр. зато што су се испитаници после првог мерења мало опустили. 

import matplotlib.pyplot as plt

# Направићемо засебне скупове за свако мерење "горнјег" крвног притиска
sis1 = podaciMed['BPXSY1'].dropna()
sis2 = podaciMed['BPXSY2'].dropna()
sis3 = podaciMed['BPXSY3'].dropna()
sis4 = podaciMed['BPXSY4'].dropna()

# Исто тако и за доњи
# При томе избацујемо редове у којима нема вредности командом dropna()
dis1 = podaciMed['BPXDI1'].dropna()
dis2 = podaciMed['BPXDI2'].dropna()
dis3 = podaciMed['BPXDI3'].dropna()
dis4 = podaciMed['BPXDI4'].dropna()

# Овде комбинујемо формиране скупове у листу скупова 
# Подаци морају тако да се припреме да бисмо исцртали виолински дијаграм
podSis = list([sis1, sis2, sis3, sis4])
podDis = list([dis1, dis2, dis3, dis4])

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(13,5))

# Подешавамо број подеока на x-оси на четири и дајемо им називе
xticklabels = ['1. мерење', '2. мерење', '3. мерење', '4. мерење']
ax1.set_xticks([1, 2, 3, 4])
ax1.set_xticklabels(xticklabels)
ax1.set_xlabel('Систолни притисак', fontsize=12)
# У левом пољу графикона исцртавамо вредности систолног притиска
ax1.violinplot(podSis)

ax2.set_xticks([1, 2, 3, 4])
ax2.set_xticklabels(xticklabels)
ax2.set_xlabel('Дијастолни притисак', fontsize=12)
# У десном пољу графикона исцртавамо вредности дијастолоног притиска
ax2.violinplot(podDis)

# Мало ћемо сабити простор између поља због прегледности
fig.tight_layout()

Изглед графикона показује да између прва три мерења нема битне разлике. Обратите пажњу да су дистрибуције систолног притиска искошене удесно, а дијастолног благо улево. Већина испитаника има нормалан "горњи" притисак (око 120) и нешто нижи "доњи" (мање од 80).  Обратите пажњу да, за разлику од кутијастог дијаграма, виолински дијаграм нема могућност приказивања аутлајера већ су они укључени у распон вертикалних дужи.  

Израчунајмо ипак и описне показатеље приказаних дистрибуција: број испитаника функцијом `len()`, аритметичку средину функцијом `mean()`, медијану функцијом `median()` и стандардну девијацију функцијом `std()`.

print("Систолни 3. мерење: N = ", len(sis3), ", M = ", sis3.mean().round(2), ", Mdn = ", sis3.median(), ", s = ", sis3.std().round(2))
print("Систолни 4. мерење: N = ", len(sis4), ", M = ", sis4.mean().round(2), ", Mdn = ", sis4.median(), ", s = ", sis4.std().round(2))
print("Дијастолни 3. мерење: N = ", len(dis3), ", M = ", dis3.mean().round(2), ", Mdn = ", dis3.median(), ", s = ", dis3.std().round(2))
print("Дијастолни 4. мерење: N = ", len(dis4), ", M = ", dis4.mean().round(2), ", Mdn = ", dis4.median(), ", s = ", dis4.std().round(2))

На основу горе приказаних описних показатеља видимо да је разлика која се јавља у четвртом мерењу последица мањег узорка, вероватно оних испитаника којима у претходна три мерења није добијена валидна мера. Због тога ћемо у даљим анализама корисити треће мерење.

У наредном кораку ћемо поделити испитанике у категорије на основу висине крвног притиска како бисмо анализирали учесталост благе или тешке хипертензије. За рад са низовима најбоље је употребити библиотеку `numpy`.

import numpy as np

# Избацујемо редове у којима су вредности пристиска сумњиво ниске
pritisak = podaciMed[(podaciMed['BPXDI3'] > 20) & (podaciMed['BPXSY3'] > 20)].copy()

# Дефинишемо границе нормалног, повишеног и високог пристиска
granice = [ (pritisak['BPXDI3'] < 80) & (pritisak['BPXSY3'] < 120), 
            (pritisak['BPXDI3'] < 80) & (pritisak['BPXSY3'] > 119) & (pritisak['BPXSY3'] < 130), 
            ((pritisak['BPXDI3'] > 79) | (pritisak['BPXSY3'] > 129)) 
          ]
kategorije = [1, 2, 3]

# Uz pomoć funkcije select() формирамо нову варијаблу са вредностима 1-3 за категорије висине пристиска
pritisak['nivo'] = np.select(granice, kategorije, default=np.nan)

# Приказаћемо пет редова табеле да бисте повезали висину притиска са категоријама које смо формирали
pritisak[['BPXSY3', 'BPXDI3', 'nivo']].head(5)

Сада ћемо употребити *дијаграм распрешења* или *скатер дијаграм* (енгл. scatterplot) помоћу кога "распршујемо" испитанике у простору две димензије. Распоред тачкица у координатном сиситему нам истовремено показује и да ли постоји повезаност између систолног и дијастолног притиска. 

plt.figure(figsize=(10, 8))

# Дефинишемо x-осу, y-осу, боју тачкица (c) и палету боја која ће се користити (cmap)
skater = plt.scatter(x=pritisak['BPXDI3'], y=pritisak['BPXSY3'], c=pritisak['nivo'], edgecolors='white', s=80, cmap='Paired')
plt.xlabel('Дијастолни притисак', fontsize=12)
plt.ylabel('Систолни притисак', fontsize=12)

# Уз помоћ функције legend_elements() позивамо елементе легенде да бисмо им променили називе
plt.legend(handles=skater.legend_elements()[0], labels=['нормалан','повишен','висок'], frameon=False)
plt.show()

Свака тачкица на горњем дијаграму представља једног испитаника који има своје вредности на x- и y-оси. Недостатак тачкица у горњем левом и доњем десном квадранту показује да су "горњи" и "доњи" притисак повезани у смислу да особе које имају виши један, имају виши и други. Плаве тачкице представљају испитанике са нормалним притиском, мада треба обратити пажњу да је приликом дефинисанја ове категорије одређена само горња граница. То може да буде проблематично јер очигледно постоје особе којима је притисак превише низак. Такође обратите пажњу да је нормалан притисак дефинисам коришћенјем комбинације два услова. То значи да постоје особе које имају нпр. нормалан систолни пристисак, али су због повишеног дијастолног сврстани у смеђу групу.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Да ли је слика представљена скатер дијаграмом сагласна са претходно приказаним виолинским дијаграмом за треће мерење?<BR>Šta može da se vidi na prvom, a ne na drugom i obratno?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
На основу скатер дијаграма можемо да закључимо колики су распон варијабли као и на основу виолинског дијаграма. Међутим, с обзиром на то да више особа може да се нађе на истом месту, тј. да тачкице могу да буду наслагане једна на другу, теже је проценити где је највећа концентрација резултата.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Да ли је варијабилност систолног притиска већа у групи оних којима је он низак или у групи којима је висок?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
Посматрамо распршење тачкица дуж y-осе. Плави кружићи су манје распршени по вертикали од смеђих. Уочавамо да има доста испитаника који се могу сматрати аутлајерима јер су им вредности систолног притиска атипично високе. 

За већину испитаника у узорку доступни су подаци о томе које лекове користе. Поред назива лека, у скупу *medications.csv* наведен је и стандардизовани назив болести (RXDRSD1) према *Међународној класификацији болести* (engl. *ICD - International Classification of Diseases*). Погледаћемо најпре коју врсту терапије испитаници најчешће користе.

plt.figure(figsize=(10,5))

# Функцијом value_counts() пребројавамо колико се пута нека болест јавља на листи
# Функцијом head() узимамо десет најчешћих болести
# Пошто се стубићи нижу од дна навише, сортираћемо их да би надужи био на врху
# Параметар barh користимо да би стубичасти дијаграм био хоризонтално постављен
podaciLek['RXDRSD1'].value_counts().head(10).sort_values().plot(kind='barh', width=1, edgecolor='white') 

plt.xlabel('Број оболелих', fontsize=12)
plt.ylabel('Обољење', fontsize=12)
plt.show()

Управо је хипертензија најучесталији здарвтсвени проблем са којим се испитаници сусрећу. Након тога следе повишен холестерол, дијабетес и астма. Интересантно је да су међу честим здравственим проблемима који се третирају медикаментима и два психичка: депресија и анксиозност. 

Сада ћемо формирати нови скуп података који садржи јединствене идентификаторе испитаника (SEQN) и податак о томе да ли он или она користи лек за смањење високог крвног пристиска (енгл. *hypertension*). 

# Уз помоћ команде str.contains() издвајамо кодове испитаника (SEQN) код којих бваријабла RXDRSD1 садржи реч hypertension
# Параметром na=False нагалашавамо да не желимо празне ћелије
podaciLekPrit = podaciLek[podaciLek['RXDRSD1'].str.contains('hypertension', na=False)][['SEQN']]

# Вредност нове варијабле prit постављамо на 1 код свих испитаника
podaciLekPrit['prit'] = 1

# Спајамо код из основне табела podaciLek са кодовима из нове табеле podaciLekPrit
# Испитаници који постоје у првој, а не постоје у другој табели добиће вредност <NA> (not available)
# Њима ћемо командом fillna() доделити вредност 0 на варијабли prit јер они не пију лек за притисак
podaciPrit = pd.merge(podaciLek[['SEQN']].drop_duplicates(), podaciLekPrit, on='SEQN', how='left').fillna(0)

Повезаност или корелација која се графички најчешће приказује скатер дијаграмом, квантитатвно се исказује коефицијентима корелације. Израчунаћемо степен повезаност између индекса телесне масе испитаника и висине њиховог крвног притискa, а у зависноссти од пола и узимања терапије коју смо евидентирали у претходно направљеном скупу `podaciLekPrit`. Степен повезаности изражава се *коефицијентом корелације*. Вредност коефицијената корелације креће се од -1 до 1, при чему вредност блиска нули означава да појаве нису повезане. Да бисмо умањили вероватноћу добијанја лажно високих корлација, уклонићемо 1% екстремно високих резултата који се могу сматрати аберантним користећи функцију `quantile(0.99)`. 

# Спајамо податке о медицинском прегледу са демографским подацима
podaci = pd.merge(podaciMed[(podaciMed['BPXSY3'] < podaciMed['BPXSY3'].quantile(0.99)) 
    & (podaciMed['BMXBMI'] < podaciMed['BMXBMI'].quantile(0.99))], 
    podaciDem[podaciDem['RIDAGEYR'] > 0], on='SEQN')

# Након тога на исти начин новом скупу додајемо и колону prit из табеле podaciPrit
podaci = pd.merge(podaci, podaciPrit, on='SEQN')

# Рачунамо корелацију индекса телесне масе и висине крвног притиска
podaci[['BMXBMI', 'BPXSY3']].corr().round(2)


У главној дијагонали горње *коелационе матрице* налазе се јединице јер варијабла корелира максимално сама са собом. Видимо да је повезаност између BMI и крвог притиска умерено висока и позитвна (r = 0.35), што значи да је већа вероватноћа да особе које имају прекомерну тежину имају и висок крвни притисак. У наредном кораку ћемо израчунати корелацију засебно за четири категорије испитаника формиране на основу пола и податка да ли особа узима антихипертензивну терапију или не.

Уочите да и овде правимо мрежу графикона, али "кућицама" нисмо давали засебне називе (ax1, ax2, ax3, ax4), већ смо их све сместили у један објекат `axis`. Тај објекат је дводимензионалан и има два реда и две колоне. То смо дефинисали командом `subplots(2, 2)`. Сваком елементу објекта приступамо преко броја реда и броја колоне. Тако је нпр. `axes[0][0]` горња лева "kućica", а `axes[1][1]` доња десна.  

Исту логику користимо и за приступање ћелијама корелационе матрице. Командом `iloc[0,1]` "лоцирамо" коефицијент који се налази у првом реду и другој колони. Обратите пажњу да нумерација увек почиње од нуле, тако да први ред или колона имају индекс 0.

На крају, треба напоменути да у статистици постоји пуно различитих коефицијената корелације. Најпопуларнији је *Пирсонов коефицијент корелације*, али њега не бисмо смели да применјујемо ако дистирбуције наших варијабли нису нормалне. Стога смо у овом примеру примениили *Спирманов коефицијент корлеације* задајући параметар `method='Spearman'`.

# Дефинишемо мрежу графикона 2 x 2 и величине 12 x 11 
fig, axes = plt.subplots(2, 2, figsize=(12,11))

# У прву кућицу уписујемо вредност другог коефицијента корлеације из корелационе матрице
# Вредност првог коефицијента је 1 јер је то повезаност варијабле BMXBMI саме са собом
priv = podaci[(podaci['RIAGENDR'] == 1) & (podaci['prit'] == 0)][['RIAGENDR', 'BMXBMI', 'BPXSY3']]
axes[0][0].scatter(priv['BMXBMI'], priv['BPXSY3'], edgecolor='black')
axes[0][0].set_title('r = ' + str(priv[['BMXBMI', 'BPXSY3']].corr(method='spearman').iloc[0,1].round(2)))
axes[0][0].set_ylabel('Не пију лек\n\nСистолни притисак', fontsize=12)
axes[0][0].set_xlabel('Индекс телесне масе', fontsize=12)

priv = podaci[(podaci['RIAGENDR'] == 2) & (podaci['prit'] == 0)][['RIAGENDR', 'BMXBMI', 'BPXSY3']]
axes[0][1].scatter(priv['BMXBMI'], priv['BPXSY3'], c='maroon', edgecolor='black')
# Назив графикона формирамо од израза "r =" на који се надовезује вредност коефицијента корелације
axes[0][1].set_title('r = ' + str(priv[['BMXBMI', 'BPXSY3']].corr(method='spearman').iloc[0,1].round(2)))
axes[0][1].set_ylabel('Систолни притисак', fontsize=12)
axes[0][1].set_xlabel('Индекс телесне масе', fontsize=12)

priv = podaci[(podaci['RIAGENDR'] == 1) & (podaci['prit'] == 1)][['RIAGENDR', 'BMXBMI', 'BPXSY3']]
axes[1][0].scatter(priv['BMXBMI'], priv['BPXSY3'], edgecolor='black')
axes[1][0].set_title('r = ' + str(priv[['BMXBMI', 'BPXSY3']].corr(method='spearman').iloc[0,1].round(2)))
# Постављамо називе x- и x-осе
axes[1][0].set_ylabel('Пију лек\n\nСистолни притисак', fontsize=12)
axes[1][0].set_xlabel('Индекс телесне масе\n\nМушкарци', fontsize=12)

priv = podaci[(podaci['RIAGENDR'] == 2) & (podaci['prit'] == 1)][['RIAGENDR', 'BMXBMI', 'BPXSY3']]
axes[1][1].scatter(priv['BMXBMI'], priv['BPXSY3'], c='maroon', edgecolor='black')
axes[1][1].set_title('r = ' + str(priv[['BMXBMI', 'BPXSY3']].corr(method='spearman').iloc[0,1].round(2)))
# На x-осу додајемо још један наслов (жене) који ће се односити и на графикон изнад
axes[1][1].set_xlabel('Индекс телесне масе\n\nЖене', fontsize=12)

fig.tight_layout()

Уочите да коефицијент корелације који је на целокупном узорку исносио 0.35 не важи за сваку од формираних категорија испитаника. Корелација између индекса телесне масе и притиска код мушкараца који не пију лекове за притисак је чак и виша (r = 0.45). Са друге стране, у групама испитаника, односно испитаница које узимају антихипертензиву терапију ова корелација је практично нулта. 

Одговор на питање из наслова ипак треба да буде одричан. Иако то звучи нелогично узимајући у обзир резултате већине медицинских студија, подаци које смо описали не пружају довољно потврде за такав закључак. Наравно, увек треба бити обазрив јер разлози неког неочекиваног закључка могу бити грешке у мерењу или специфичности узорка на коме је обавлјено истраживање. Нама је био циљ да илуструјемо одређени статистички поступак и да укажемо на кључну ствар везану за анализу повезности: чак и да је корелација коју смо рачунали много виша, то нам не даје за право да тежину посматрамо као *узрок* хипертензије. Статистичким речником речено, корелација не подразумева каузалност! Ту првенствено мислимо на податак да постоји доста особа које нису гојазне, а које имају веома висок крвни притисак. Коефицијент корелације нам говори само да се две појаве заједнички мењају, што не значи нужно да су једна другој узрок или последица. 

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Да ли је корелација телесне масе и пристиска у групи мушкараца који не пију лекове иста у свим деловима скатер дијаграма, тј. за све нивое телесне масе?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
Није. Распршеност је већа у зони високих вредности обе варијабле па је вероватно и корлација у тој зони мања. Ова различита распршеност тачкица дуж једне замишљене линије у статистици се зове <i>хетероскедастицитет</i>.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Одступање од начелне "правилности" да је тежина повезана са притиском није иста у сегменту особа које су теже и особа које имају веома висок притисак. Где је то одступање веће?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
Варијабилност тежине је већа у групи особа са високим притиском од варијабилности притиска у групи особа прекомерне тежине. Између осталог, то се најбоље види по томе што је доњи десни квадрант графикона прилично празан. То значи да нема пуно гојазних особа којима је притисак низак, али међу особама које имају висок притисак има и гојазних и готово неухрањених.
# Шта се најчешће једе (за доручак)?
У овом одељку бавићемо се подацима везанима за навике и режим исхране испитаника. Ови подаци налазе се у датотеци *diet.csv*.

import pandas as pd

podaciDem = pd.read_csv('podaci/demographic.csv')[['RIDAGEYR', 'RIAGENDR', 'SEQN']]
podaciMed = pd.read_csv('podaci/examination.csv')
podaciHrana = pd.read_csv('podaci/diet.csv')

Пошто смо у претходним лекцијама погледали који подаци се налазе у табелама *demographic.csv* и *examination.csv* сада ћемо приказати само структуру табеле *diet.csv*.

podaciHrana.head(5)

Табела садржи 84 варијабле, али њихови називи нису нарочито информативни и тешко да бисмо могли да откријемо шта подаци значе без __[детаљног упутства](https://wwwn.cdc.gov/Nchs/Nhanes/2013-2014/DR2IFF_H.htm)__ које долази са овим скупом података. Погледаћмо најпре количину типичних састојака хране коју одрасли Американци конзумирају у току дана. Табелу ћемо поново повезати са демографским подацима како бисмо могли да ограничимо анализу на одрасле испитанике. 

# Спајамо демографске податке са подацима о исхрани
podaciDemHrana = pd.merge(podaciDem, podaciHrana, on='SEQN')

# Издвојићемо само испитанике старије од 17 година - [podaciDemHrana['RIDAGEYR'] > 17
podaciSast = podaciDemHrana[podaciDemHrana['RIDAGEYR'] > 17].groupby('SEQN')[['DR2IPROT', 'DR2ICARB', 'DR2ISUGR', 'DR2IFIBE', 'DR2ITFAT', 'DR2ISODI']].sum().reset_index()
# Нејасне називе варијабли мењамо јаснијим
naziviSast = ['Протеини (g)', 'Угљени хидрати (g)', 'Шећери (g)', 'Влакна (g)', 'Масти (g)', 'Натријум (mg)']

Сада ћемо уз помоћ библиотеке `seaborn` приказати дистрибуције вредности дневног уноса различитих врста састојака. 

import seaborn as sbrn
import matplotlib.pyplot as plt

aut = 0.99          # Проценат највишихрезултата уклањамо (0.99 = 1%)
istiRaspon = False  # Да ли је распон на x-оси исти на свим графиконима?

sbrn.set_theme(style='darkgrid')
fig, ((ax1, ax2, ax3), (ax4, ax5, ax6)) = plt.subplots(2, 3, figsize=(18,7))

for rb, osa in enumerate(fig.axes):     # У овој for петљи се пролази кроз све колоне скупа podaciSast,
    kolona = podaciSast.columns[rb+1]   # али додајемо 1 да бисмо прескочили прву колону (SEQN)
    # Избацујемо веома високе разултате командом quantile(aut)
    # Функција between() nam omogućava da definišemo raspon željenih vrednosti
    sbrn.histplot(podaciSast[podaciSast[kolona].between(0, podaciSast[kolona].quantile(aut))], x=kolona, element='poly', alpha=0.5, ax=osa)
    # На x-осама ћемо исписати и вредности аритемтичких средина
    osa.set_xlabel(naziviSast[rb] + ', M = ' + str(podaciSast[podaciSast[kolona].between(0, podaciSast[kolona].quantile(aut))][kolona].mean().round(2)))
    osa.set_ylabel('Број испитаника' if (rb == 0 or rb == 3) else '')
    # Ако је варијабла istiRaspon подешена на True распони x-оса свих графикона осим последњег постављају се на 0-650
    if (rb < 5) & (istiRaspon):
        osa.set_xlim(0, 650)

# Додајемо вертикалне линије референтних вредности на шести графикон
ax6.axvline(1500, linestyle='--', color='#096925', lw=1)
ax6.axvline(2300, linestyle='--', color='#c2220a', lw=1)

# Размак између графикона (padding) подешавамо на 1
fig.tight_layout(pad=1)

Графикони нам омогућавају да закључимо колико анализираних састојака дневно уноси типичан грађанин САД. На пример, на основу првог графикона уочавамо да већина Американаца уноси између 50 и 80 грама протеина дневно. Све дистирбуције су искошене удесно иако смо функцијом `quantile()` искључили екстремно високе вредности. То значи да постоји доста испитаника који имају изузетно високе дневне уносе свих састојака, односно хране уопште. 

Испитивање разлика у статистици обично подразумева поређење две или више група на једној или више варијабли. Међутим, разлике се могу анализирати и у односу на неку унапред дефинисану вредност или стандард. На пример, *American Heart Association* препоручује максималан унос од 2.400 mg натријума дневно. На последњем графикону је ова граница означена црвеном линијом. На основу вредности M и искошености дистрибуције видимо да је унос соли код већине испитаника iznad препоручене вредности.

<div class='alert alert-block alert-info'><img src='slike/zad.png' align='left'/>Упоредите просечан унос других састојака са препорученим вредностима. Препоручене вредности можете пронаћи на паковањима већине прехрамбених производа.</div> 

<div class='alert alert-block alert-info'><img src='slike/zad.png' align='left'/>Који састојци су најзаступљенији у исхрани америчких грађана? Да ли висок унос тих састојака нужно значи и да се они прекомерно уносе?</div> 

Подеоци x-осе на горњим графиконима прилагођени су распонима сваке појединачне варијабле. Подесите вредност варијабле `istiRaspon` на `True` и поново покрените горњи код да би се распони првих пет графикона уједначили. Последњи графикон је изузет из ове операције јер се вредности односе на милиграме, а не на граме као код осталих варијабли.

Поређење дистрибуција са уједначеним распонима x-оса је лакше. Сада много јасније уочавамо нпр. да се исхрана грађана САД у највећој мери базира на угљеним хидратима или да је унос шећера много виши од уноса влакана.

На крају, још једном морамо да напоменемо да будете веома обазриви у вези са аутлајерима. У већини случајева њихово задржаванје може да направи проблем у смислу значајног повећанја просека, али то не значи да их треба уклањати по аутоматизму. Поставите вредност варијабле `aut` у горњем коду на 1 да бисте задржали 100% резултата. Посматрајте како се мења изглед графикона и како се мењају просеци варијабли.

У прошлој лекцији смо испитивали повезаност индекса телесне масе са висином крвног пристиска, а овога пута ћемо проверити да ли је код одраслих особа већи унос масти (DR2ITFAT) и угљених хидрата (DR2ICARB), односно шећера (DR2ISUGR), повезан са већом тежином.  

podaciDemMed = pd.merge(podaciDem, podaciMed[(podaciMed['BMXBMI'] < podaciMed['BMXBMI'].quantile(aut))], on='SEQN')
podaciSastDemMed = pd.merge(podaciSast, podaciDemMed, on='SEQN')

podaciSastDemMed[['DR2ITFAT', 'DR2ICARB', 'DR2ISUGR', 'BMXBMI']].corr().round(2)


Коефицијенти приказани у корелационој матрици указују на релативно неочекиван резултат: повећани унос масти и шећера није повезан са повећањем телесне масе. У овом моменту је тешко објаснити овакав резултат јер разлози могу бити бројни, укључујући дејство неких других варијабли или једноставно чињеницу да је велики број особа физички активно тако да повећан унос хране не мора нужно да води повећању телесне масе. Једина веома висока корелација је она између уноса угљених хидрата и шећера (r = 0.82), што је и очекиван резултат имајући у виду да су шећери најчешћи тип угљених хидрата у производима. Исте податке можемо да прикажемо и у тродимензионалном скатер дијаграму. 

import plotly.express as px

# Одмах ћемо променити вредности варијабле RIAGENDR из 1 и 2 у 'М' и 'Ж'
podaciSastDemMed["RIAGENDR"].replace({1: 'М', 2: 'Ж'}, inplace=True)

# Тродимензионални скатер приказује, наравно, вредности три варијабле (x, y i z)
# На наш ћемо додати и четврту (RIAGENDR) која ће бити визуализована бојом тачкица (color)
fig = px.scatter_3d(podaciSastDemMed, x='DR2ITFAT', y='DR2ICARB', z='BMXWT', color='RIAGENDR', width=800, height=600)

# Karakteristike tačkica (markera) definišemo kao rečnike (dict) koji sadrže više parametara (veličina, boja, širina...)
fig.update_traces(marker=dict(size=5, line=dict(width=1, color='white')), selector=dict(mode='markers'))

# Уклањамо маргине да би графикон испунио цело поље
fig.update_layout(margin=dict(l=0, r=0, t=0, b=0))

fig.show()

Ротирајте дијаграм тако да прикажете распршење за сваки од три односа између варијабли: DR2ITFAT x DR2ICARB, DR2ITFAT x BMXWT и DR2ICARB x BMXWT. Уочите да је распршење најмање код варијабли код којих је корелација највећа (DR2ITFAT x DR2ICARB). Такође обратите пажњу да се међу подацима налазе и аберантни резултати или тзв. *autlajeri*. Они додатно повећавају коефицијент корелације који би вероватно био мањи када бисмо их искључили као у анализи везаној за крвни притисак из претходне лекције.

У наредном кораку ћемо анализирати шта испитаници најчешће конзумирају. За потребе ове анализе употребићемо варијабле **DR2_030Z** и **DR2IFDCD** из табеле *diet.csv*. Прва варијабла је ознака оброка и има више од 15 могућих вредности, али ми ћемо ограничири преглед на доручак (1), ручак (2), вечеру (3) и ужину (6). Друга варијабла садржи стандардни код хране који се користи у САД (енгл. __[*USDA Food Code*](https://www.ars.usda.gov/ARSUserFiles/80400530/pdf/fndds/2015_2016_FNDDS_Doc.pdf#page=28)__). Потребна нам је само прва цифра овог кода која означава тип хране, а издвојићемо је командом `str[0]`.

Приказаћемо најпре *табелу контингенције* која настаје укрштањем оброка и типа хране. У питању је табела која садржи учесталости појединачних категорија. Већи број означава да испитаници чешће једу одређени тип хране у одређено доба дана.

# Издвајамо само доручак (1), ручак (2), вечеру (3) и ужину (6) командом isin(niz)
podaciObrok = podaciHrana[podaciHrana['DR2_030Z'].isin([1, 2, 3, 6])][['DR2_030Z', 'DR2IFDCD']].copy()

# Вредности варијабле оброк (DR2_030Z) претварамо у стринг
podaciObrok['obrok'] = podaciObrok['DR2_030Z'].astype(str)

# Нумеричку вредност кода хране (DR2IFDCD) претварамо у стринг и узимамо само први карактер
podaciObrok['kod'] = podaciObrok['DR2IFDCD'].astype(str).str[0]

# Правимо табелу учесталости укрштањем оброка и типа хране
pd.crosstab(index=podaciObrok['obrok'], columns=podaciObrok['kod'], colnames=[''], rownames=['Шифра']).reset_index()

Слично другим матрицама података, табеле контингенције су релативно непрегледне у смислу да се високе и ниске вредности, као и односи међу њима, тешко уочавају. Стога ћемо исте податке приказати графички уз помоћ специфичне матрице густине или тзв. *топлотне мапе* (енгл. *heatmap*). Уз мапу се приказује легенда која омогућава лако уочавање ћелија са високим учесталостима на основу скале боја. 

# Формирамо мапу густине учесталости
fig = px.density_heatmap(podaciObrok.sort_values('kod'),
    # Подешавамо редослед оброка (доручак, ручак, вечера, ужина)
    category_orders={ 'obrok': ['1', '2', '3', '6'] },
    # Мењамо називе оса
    labels={ 'kod': 'Врста хране', 'obrok': 'Оброк' },
    # Укрштамо варијабле
    x='kod', y='obrok', width=650, height=300)

# Накнадно ћемо изменити неколико параметара графикона икона као нпр. ширину маргина
fig.update_layout(margin=dict(l=50, r=100, t=20, b=30),
                  # Назив траке (легенде) са ознаком значења боја
                  coloraxis_colorbar=dict(title='Учесталост'),
                  # Ротираност и називе ознака x-осе због боље читљивости
                  xaxis=dict(tickmode = 'array', tickangle=45,
                             ticktext=['млеко', 'месо', 'јаја', 'махунарке', 'житарице', 'воће', 'поврће', 'масти', 'слаткиши'],
                             tickvals=[1,2,3,4,5,6,7,8,9]
                            ),
                  # Називе подеока y-осе
                  yaxis=dict(tickmode = 'array',
                             ticktext=['доручак', 'ручак', 'вечера', 'ужина'],
                             tickvals=[1,2,3,6]
                            )
                 )

fig.show()

На основу слике се много лакше него на основу табеле контингенције уочава да испитаници конзумирају доста слаткиша и слатких пића, посебно за ужину. Распоред боја у првом реду указује да се типичан доручак грађана САД састоји од зашећерених житарица (пахуљица) са млеком, док распоред боја у трећој колони показује да веома ретко једу јаја. Поврће се обично једе за ручак и вечеру, а ређе за доручак или као ужина.
# Колико су честа штетна и ризична понашања?
У последњем делу одељка о јавном здрављу грађана САД позабавићемо се њиховим навикама и понашањима везаним за употребу алхохола, конзумирање марихуане и сексуалне односе. Ови подаци су прикупљени помоћу упитника тако да ћемо за потребе анализе учитати табеле *demographic.csv* и *questionnaire.csv*. Структуру и садржај ових табела прегледали смо у претходним лекцијама, али ћемо ипак приказати првих пар редова како бисмо се подсетили назива неких варијабли. Уочите да су у комбинованој табели `podaciDemUpit` неке демографске варијабле као што је пол (RIAGENDR) и неке варијабле из упитничког скупа као нпр. одговори на ставке упитника о депресији (DPQ090).   

import pandas as pd

podaciDem = pd.read_csv('podaci/demographic.csv')[['SEQN', 'RIDAGEYR', 'RIAGENDR']]
podaciUpit = pd.read_csv('podaci/questionnaire.csv')
podaciDemUpit = pd.merge(podaciDem, podaciUpit, on='SEQN')
podaciDemUpit.head(5)

Да бисмо анализирали учесталост конзумације алхолода међу младима узраста између 14 и 25 година употребићемо одговоре на три питања:
<ol>
<li>ALQ130 - <i>Колико сте алхолних пића дневно пили у последњих годину дана?</i></li>
<li>ALQ101 - <i>Да ли сте некада у току периода од годину дана попили више од 11 пића?</i> и</li>
<li>ALQ110 - <i>Да ли сте у животу укупно попили више од 11 пића?</i></li>
</ol>

Пре него што исцртате графикон који приказује расподелу одговора на прво питање, размислите о томе колико је важно добро формулисати питање којим се "мери" жељено својство. На пример, прво питање је много корисније од другог и трећег јер ипак говори о актуелним навикама појединца, док се на основу другог и трећег не могу донети употребљиви закључци о томе да ли особа спада у потенцијално ризичну групу конзумената алкохола.   

# Издвајамо испитанике старости од 14 до 25 година и уклањамо веома високе вредности уноса алкохола
graf = podaciDemUpit[(podaciDemUpit['RIDAGEYR'].isin(range(14,26))) & (podaciUpit['ALQ130'] < podaciUpit['ALQ130'].quantile(0.99))]['ALQ130'].plot(kind='hist', edgecolor='white', color='steelblue')

# Израчунаћемо проценат особа које попију барем једно пиће дневно (дугачак код смо преломили оператором \)
proPiju = podaciDemUpit[(podaciDemUpit['RIDAGEYR'].isin(range(14,26))) & (podaciUpit['ALQ130'] > 0)]['ALQ130'].count() \
    / podaciDemUpit[(podaciDemUpit['RIDAGEYR'].isin(range(14,26)))]['ALQ130'].count()

graf.set_title('Учесталост конзумирања алкохола у групи младих', fontsize=13)
graf.set_xlabel('Број попијених алкохолних пића дневно', fontsize=11)
graf.set_ylabel('Број особа', fontsize=11)

print ('Proporcija mladih koji popiju barem jedno piće dnevno je ' + str(proPiju.round(2)) + '.')

Иако изглед графикона може да упути на закључак да међу младима не постоји проблем са конзумирањем алкохола, треба узети у обзир искошеност дистрибуције. Категорија испитаника који не пију алкохол јесте најбројнија, али чак 61% младих дневно конзумира једно или више алкохолних пића што је забрињавајући податак. Погледајмо сада и податке који се тичу одговора на преостала два питања. Овога пута ћемо уз стубичасти dijagram употребити i тзв. *торта* или *пита дијаграм*. Сам назив указује на то да се графикон састоји од "парчади", тј. исечака који говоре о уделу сваке од категорија неке варијабле у укупном узорку. Уобичајено је да се ова врста графикона користи за приказивање учесталости вредности квалитативне и категоријалне варијабле.

import matplotlib.pyplot as plt

# Да ли су попили више од 11 пића у току године
alkGod = podaciDemUpit[(podaciDemUpit['RIDAGEYR'].isin(range(14,26))) & (podaciDemUpit['ALQ101'].isin([1, 2]))]['ALQ101'].value_counts().sort_index()
# Да ли су попили више од 11 алкохолних пића у току живота
alkZiv = podaciDemUpit[(podaciDemUpit['RIDAGEYR'].isin(range(14,26))) & (podaciDemUpit['ALQ110'].isin([1, 2]))]['ALQ110'].value_counts().sort_index()

fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(15,6))

# Ознаке категорија одговора смештамо у варијаблу oznake
oznake = 'ДА', 'НЕ'
# За колико ћемо изместити сваки одсечак из круга - први не, а други врло мало
isecak = (0, 0.05) 

# Параметром autopct подешавамо формат исписа процента на једну децималу и ознаку процента
ax1.pie(alkGod, explode=isecak, labels=oznake, autopct='%1.1f%%', startangle=90)
ax1.axis('equal')  
ax1.set_xlabel('> 11 пића у једној години')
ax1.set_facecolor('white')

# Параметром startangle подешавамо почетак "сецкања торте" на 90 степени, тј. врх круга
ax2.pie(alkZiv, explode=isecak, labels=oznake, autopct='%1.1f%%', startangle=90)
ax2.axis('equal')  
ax2.set_xlabel('> 11 пића у животу')

# Обједињујемо скупове да бисмо приказали наслагани стубичасти дијаграм
# При томе ротирамо (транспонујемо) табелу командом .T тако да редови постану колоне и обратно
alk = pd.concat([alkGod, alkZiv], axis = 1).T
alk.plot.bar(ax=ax3, edgecolor='white', width=0.8)
ax3.set_xticklabels(['> 11 пића у једној години', '> 11 пића у животу'], rotation=0)
ax3.legend(labels=['ДА','НЕ'], frameon=False)

fig.tight_layout()

Леви пита дијаграм потврђује претходну информацију да око 60% младих релативно редовно конзумира алкохол. Међутим, јасно је да нам то не значи пуно јер ова категорија може да обухвати особе које су пиле једно пиће месечно, као и оне које пију једно пиће дневно. Одговори на друго питање су још мање информативни. Додатно збуњује и чињеница да је однос потврдних и одричних одговора на другом питању потпуно супротан, што делује нелогично. С обзиром на то да торта дијаграм говори само о пропорцији сваке групе, а не и о њеној апсолутној величини, потребно је да ипак консултујемо и стубичасти дијаграм. Уочавамо да је број испитаника који су дали одговор на друго питање много мањи, те да је велики број недостајућих података највероватнији узрок поменуте нелогичности. На тај начин смо индиректно проверили поузданост варијабле *ALQ110* и можемо да закључимо да је она практично неупотребљива. Овај пример показује колико је битно добро осмислити истраживање и истраживачка питања, јер у супротном можемо да завршимо са подацима који не могу да нам понуде превише корисних инфромација.

Погледајмо сада каква је ситуација са учесталошћу конзумирања марихуане међу младима. Употребићемо *дијаграм паралелних координата* како бисмо на једном графикону представили релације између три варијабле: пола (RIAGENDR), конзумирања марихуане (DUQ200) и узраста на коме ју је особа први пут пробала (DUQ210).

import plotly.express as px

# Искључујемо испитанике који су одбиили да дају одговор ДА (1) или НЕ (2)
podaci = pd.merge(podaciDem[(podaciDem['RIDAGEYR'].isin(range(14,26)))], podaciUpit[(podaciUpit['DUQ200'].isin([1,2]))], on='SEQN') 

# Одмах мењамо нумеричке ознаке пола и одоговора у речи
podaci["RIAGENDR"].replace({1: 'М', 2: 'Ж'}, inplace=True)
podaci["DUQ200"].replace({1: 'ДА', 2: 'НЕ'}, inplace=True)

# Све вредности годинамање од 15 (осим 0) претварамо у 14
podaci.loc[podaci["DUQ210"].isin(range(1, 15)), 'DUQ210'] = 14
# Све вредности веће од 19 претварамо у 20
podaci.loc[podaci["DUQ210"] > 19, 'DUQ210'] = 20

# Сортирамо вредности по годинама
podaci.sort_values("DUQ210", inplace=True)

# Вредност 0 бришемо, 14 претварамо у ознаку "< 15", а 20 у "> 19"
podaci["DUQ210"].replace({0: '', 14: '< 15', 20: '> 19'}, inplace=True)

podaci['boja'] = podaci['RIAGENDR'].map({'М': 0, 'Ж': 1})

# Исцртавамо дијаграм паралелених категорија
fig = px.parallel_categories(podaci, dimensions=['RIAGENDR', 'DUQ200', 'DUQ210'], 
                             # Овде морамо мало да се довијамо да бисмо обојили траке
                             color='boja', range_color=[0, 1],
                             color_continuous_scale=[(0.00, "steelblue"), (0.5, "steelblue"), (0.50, "indianred"),  (1.00, "indianred")],
                             # Називи вертикалних трака
                             labels={'RIAGENDR':'Пол', 'DUQ200':'Марихуана', 'DUQ210':'Узраст 1. пут'}, width=800)

# Уклонићемо уобичајену легенду са бојама пошто је јасно шта која значи и смањићемо маргине
fig.update_layout(coloraxis_showscale=False, margin=dict(l=5, r=10, t=30, b=20))

fig.show()


Графикон нам нуди одговоре на бројна питања. Учесталости основних категорија испитаника приказане су вертикалним правоугаоницима (нпр. пол или употреба марихуане). Ширина трака указује на број особа у подкатегоријама које настају укрштањем основних категорија (нпр. мушкарци који конзумирају марихуану или девојке које су пробале марихуану пре петнаесте године). Крајња лева трака показује да је у узорку био подједнак број девојака и младића. Однос сегмената средње траке показује да је више младих који су барем једном користили марихуану од оних који нису. На крају, трећа трака показује да знатан број адолесцената, посебно младића, први пут проба марихуану пре своје петнаесте године.

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Колико младих је први пут пробало марихуану са 18 година? Колико младића је пробало марихуану пре своје петнаесте године?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
Пређите показивачем миша преко одговарајућих правоугаоника који представљају ове групе испитаника. Одговори на поставлјена питања су 78 и 75. 

На крају ћемо погледати и неколико питања који се тичу сексуалног понашанја младих. Приказаћемо описне показатеље за узраст када је особа први пут имала сексуалне односе (SXD031), број сексуалних партнера (SXD171) и учесталост сексуалних односа без коришћења кондома (SXQ251) изражену на скали од 1 (никада) до 5 (увек).

# Наредна два параметра користимо да ограничимо узорак испитаника
raGo = [18, 21]     # Распон година
goGr = 0.99         # Горња граница година у процентима

# Издвајамо податак о години ступања у сексуалне односе у засебан скуп
prvi = podaciDemUpit[(podaciDemUpit['SXD031'].between(10,podaciDemUpit['SXD031'].quantile(goGr))) & \
      (podaciDemUpit['RIDAGEYR'].between(raGo[0], raGo[1], inclusive='both'))].groupby('RIAGENDR')['SXD031']

# Исто радимо и са бројем партнера
part = podaciDemUpit[(podaciDemUpit['SXD171'].between(1,podaciDemUpit['SXD171'].quantile(goGr))) & \
      (podaciDemUpit['RIDAGEYR'].between(raGo[0], raGo[1], inclusive='both'))].groupby('RIAGENDR')['SXD171']

# Правимо скуп и од пдоатака о учесталости (не)коришћења кондома
kond = podaciDemUpit[(podaciDemUpit['SXQ251'].between(1, 5, inclusive='both')) & \
      (podaciDemUpit['RIDAGEYR'].between(raGo[0], raGo[1], inclusive='both'))].groupby('RIAGENDR')['SXQ251']

# Просеке и медијане свих претходних варијабли, тј. скупова од једне варијабле, спајамо у једну табелу функцијом concat()
tabela = pd.concat([prvi.mean().round(2), prvi.median(), part.mean().round(2), part.median(), kond.median()], axis=1).reset_index()

# Дајемо називе колонама новоформиране табеле
tabela.set_axis(['Пол', 'прСеx (M)', 'прСеx (Mdn)', 'брПарт (M)', 'брПарт (Mdn)', 'безКонд (Mdn)'], axis=1, inplace=True)

# Мењамо вредности варијабле пол у слова
tabela['Пол'].replace({1: 'М', 2: 'Ж'}, inplace=True)

# Приказујемо табелу
tabela

На основу података приказаних у горњој табели можемо закључити да момци ступају нешто раније у сексуалне односе од девојака, мада је у обе групе вредност медијане 16 година. Девојке имају нешто више сексуалних партнера што показују вредности артитметичких средина, али и одговарајућих средњих вредности (медијана). На крају, девојке чешће ступају у сексуалне односе у којима њихов партнер не користи кондом. 

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Поставите горњу границу распона вредности на 0.9 и поново израчунајте показатеље. Због чега су се просечне вредности броја сексуалних партнера значајно промениле, а медијане нису?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
Аутлајери и екстремне вредности више утичу на аритметичку средину него на медијану. Нпр. средња вредност низа бројева [1, 2, 3, 4, 5] остаће 3 чак и ако уместо 5 ставимо 50 или 500. Са друге стране, ове промене ће драстично повећати аритметичку средину. 
# Од чега зависи задовољство животом?
У наредном примеру ћемо ћемо демографским подацима из __[**NHANES**](https://www.cdc.gov/Nchs/Nhanes/about_nhanes.htm)__ скупа података придружити податке прикупљене различитим упитиницима. У питању су резултати који нису настали објективним мерењима као што су лабораторијска анализа или физички преглед, већ на основу одговора или субјективне процене самих испитаника. Ове варијабле тичу се њиховог задовољства животом, њихових осећања, учесталости коришћења дрога и алкохола, сексуалних навика и слично.  

import pandas as pd

podaciUpit = pd.read_csv('podaci/questionnaire.csv')
podaciUpit.head(5)

Упитнички подаци у оригиналном скупу смештени су у више од 40 табела. Овде смо издвојили само 32 варијабле из неколико табела. Детаљнији опис целог скупа можете да пронађете на страници пројекта __[NHANES](https://wwwn.cdc.gov/nchs/nhanes/search/datapage.aspx?Component=Questionnaire&Cycle=2013-2014)__. Ове колоне ћемо повезати са неколико демографских варијабли: пол (RIAGENDR), узраст (RIDAGEYR), степен образовања (DMDEDUC2), брачни статус (DMDMARTL) и просечним приходима (INDFMIN2).

podaciDem = pd.read_csv('podaci/demographic.csv')[['SEQN', 'RIAGENDR', 'RIDAGEYR', 'DMDEDUC2', 'DMDMARTL', 'INDFMIN2']]
podaciDemUpit = pd.merge(podaciDem, podaciUpit, on='SEQN') 

# Обрисаћемо привремене табеле да не заузимају меморијски простор
del podaciDem, podaciUpit

Између осталог, поменути упитник је садржао 9 питања којима се процењује заступљеност симптома депресије код испитаника, нпр. "Немам воље да било шта радим", "Осећам се потиштено и безнадежно", "Осећам се уморно" итд. Испитаници су означавали степен слагања са сваком ставком на четворостепеној скали од 0 ("Уопште не") до 3 ("Скоро свакога дана"). Код оваквих упитника уобичајено је да се вредности одговора на сва питања саберу и претворе у тзв. *сумациони скор*. На тај начин се добија мера изражености неког својства, у овом случају осећања депримираности. Испитаници који су на сва питања одговорили са 3 имаће највећи скор, односно највиши ниво показатеља депресивности. Пре сумирања ћемо искључити све испитанике који нису желели (7) или нису могли да дају одговор (9) на неко од питања, као и оне за које не постоји податак о брачном статусу (77 и 99). 

# Издвајамо само испитанике који су одговорили на сва питања на скали депресивности
upitDep = podaciDemUpit[(podaciDemUpit['DPQ010'].between(0,4)) & 
                        (podaciDemUpit['DPQ020'].between(0,4)) & 
                        (podaciDemUpit['DPQ030'].between(0,4)) & 
                        (podaciDemUpit['DPQ040'].between(0,4)) &
                        (podaciDemUpit['DPQ050'].between(0,4)) &
                        (podaciDemUpit['DPQ060'].between(0,4)) &
                        (podaciDemUpit['DPQ070'].between(0,4)) &
                        (podaciDemUpit['DPQ080'].between(0,4)) &
                        (podaciDemUpit['DPQ090'].between(0,4)) & 
                        # Уклањамо и испитанике код којих немамо податак о брачном статусу
                        (podaciDemUpit['DMDMARTL'] < 77) 
                       ].copy()

# Рачунамо збир одговора на сваку ставку упитника
upitDep['sumDep'] = upitDep['DPQ010'] + upitDep['DPQ020'] + upitDep['DPQ030'] + \
                    upitDep['DPQ040'] + upitDep['DPQ050'] + upitDep['DPQ060'] + \
                    upitDep['DPQ070'] + upitDep['DPQ080'] + upitDep['DPQ090'];

Након рачунања сумативног скора и смештања вредности у нову варијаблу `sumDep` исцртавамо просеке уз помоћ линијског дијаграма. Као категоријалне варијабле употребићемо пол испитаника и њихов брачни статус да бисмо видели да ли међу њима постоји нека разлика у нивоу депресивности. 

import seaborn as sbrn
import matplotlib.pyplot as plt

# Из скупа тема бирамо ону која ће графикон обојити у бело
sbrn.set_theme(style="whitegrid")

# На x-осу постављамо пол, а на y- сумациони скор
grafLin = sbrn.catplot(data=upitDep, x="RIAGENDR", y="sumDep", 
                      # Боја линије је дегфинисана на основу брачног статуса
                      hue="DMDMARTL", palette="Set1", 
                      # Величина "капица" на вертикалним линијама и додавање тачкица на крајевима
                      capsize=0.05,  kind="point", 
                      # Приказујемо легенду и дефинишемо однос димензија графикона
                      legend=True, aspect=1.4, height=7, 
                      # Мало ћемо "смакнути" линије по хорозонтали да се не би преклапале
                      dodge=True,
                      # Дефинишемо изглед линија (цртице, тачкице...)
                      linestyles=["-", "--", ":", "-", "-.", "-"])

# Дефинишемо распон вредности на y-оси. 
plt.ylim(1, 8) 

# Додељујемо називе категоријама брачног статуса варијабли brStatus
brStatus = ['ожењен/удата', 'удовац/удовица', 'разведен(а)', 'раздвојен(а)', 'никад у браку', 'живи са партнер(к)ом']

# За сваку категорију брачног статуса додељујемо један елемент легенде 
for rb, brSt in enumerate(brStatus):
    grafLin._legend.texts[rb].set_text(brSt)

# Легенда неће имати наслов
grafLin._legend.set_title('')

# Осе ће имати наслове
grafLin.set_xlabels('Пол', fontsize='13')
grafLin.set_ylabels('Просечан резултат на упитнику депресивности', fontsize='13')
grafLin.set_xticklabels(['М', 'Ж'], fontsize='13')

# Подешавамо величину текста у легедни
plt.setp(grafLin._legend.get_texts(), fontsize='13')

# Постављамо наслов графикона
plt.title('Разлике у просечном скору на скали депресивности између мушкараца и жена различитог брачног статуса', fontsize='13')

plt.show()

На горњем графикону тачкама су приказане просечне вредности, а вертикалним линијама процена варијабилности скорова на скали депресивности за 12 група испитаника. Групе су настале укрштањем варијабли *пол* и *брачни статус*. Хоризонталним косим линијама различите боје повезане су групе мушкараца и жена истог брачног статуса. Уочавамо да симптоме депресије најчешће испољавају особе које су разведене или раздвојене (енгл. *separated*). То су љубичасте и зелене тачке, односно линије на графикону. Најниже просечне вредности на скали депресивности имају особе које су у браку. Такође видимо да су жене генерално склоније да на упитницима испоље оваква осећањима него мушкарци. Варијабилност резултата је највећа у групи раздвојених особа, без обзира на пол. Хоризонталне линије, тачније њихов нагиб, додатно олакшавају закључивање о постојању разлика међу групама. На пример, уочавамо да је разлика између мушкараца и жена мање изражена у подгрупи особа које никада нису ступале у брак, док је највећа у групама особа којима је преминуо брачни партнер, које су разведене или живе одвојено од бившег партнера. 

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Теоријски распон сумационог скора на скали депресивности је од 0 (9 · 0) до 27 (9 · 3). Промените параметре функције <b>ylim</b> у горњеm коду и поново исцртајте графикон да бисте видели у којој мери ограничавање распона на осама утиче на интерпретацију резултата. Да ли испитаници у апсолутном смислу имају високе вредности на овој варијабли? Да ли су разлике међу категоријама (пол x брачни статус) сада толико очигледне? Да ли то значи да оне не постоје и да више нису битне?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
Разлике међу групама су мање очигледне када се прикаже цео теоријски распон варијабле. Тада се јасније види да заправо већина испитаника постиже ниске скорове на скали депресивности, а да су разлике деловале као велике јер смо посматрали само један део укупног распона. То и даље не значи да те разлике нису значајне што би требало проверити неким статистичким тестом као што је нпр. t-тест. 

У следећем кораку анализираћемо одговоре испитаника на једноставно питање (HSD010) како генерално процењују своје здравље на скали од 1 (одлично) до 5 (веома лоше). Ову процену ћемо довести у везу са степеном образовања особе (DMDEDUC2). Пре приказивања на графикону уклонићемо кодове за податке који нису доступни. Овога пута нећемо користити филтере као у претходним лекцијама, већ ћемо вредности 7 и 9 заменити вредношћу `pd.NA` (енгл. *Not Available*) као ознаком за недостајући податак у билиотеци `pandas`. Поред тога, рекодираћемо одговоре на питање како би ниже задовољство било означено мањим, а више већим бројем. 

# Недостајуће одговоре одмах мењамо вредношћу <NA>
podaciDemUpit["HSD010"].replace({0: pd.NA, 9: pd.NA, 1: 5, 2: 4, 4: 2, 5: 1}, inplace=True)

# Параметар inplace је постављен на True како би се директно изменио садржај варијабле у самом оквиру података
podaciDemUpit["DMDEDUC2"].replace({7: pd.NA, 9: pd.NA}, inplace=True)

Пре него што погледамо укрштене податке, приказаћемо дистрибуције обе варијабле. 

# Додељујемо имена категоријама образовања и субјективне процене здравлја
katObrazovanje = ['без ОШ', 'ОШ', 'СШ', 'ВШ', 'ФК']
katZdravlje = ['лоше', 'задовољавајуће', 'добро', 'веома добро', 'одлично']

# Дефинишемо објекат figure која ће садржати два графикона
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(13,5))

# Пребројавамо испитанике у свакој категорији и сортирамо по индексној колони (0-4)
podaciDemUpit['DMDEDUC2'].value_counts().sort_index().plot(kind='bar', width=1, edgecolor='white', ax=ax1) 
ax1.set_ylabel('Број испитаника', labelpad=10, fontsize=13)
ax1.set_xlabel('Дистрибуција испитаника по степену образовања', labelpad=10, fontsize=13)
# Називе подеока на x-оси узимамо из варијабле katObrazovanje
ax1.set_xticklabels(katObrazovanje, rotation=0, fontsize=12)

# Исто радимо и за одговор на питање о општем здравственом стању
podaciDemUpit['HSD010'].value_counts().sort_index().plot(kind='bar', width=1, edgecolor='white', ax=ax2) 
ax2.set_ylabel('Број испитаника', labelpad=10, fontsize=13)
ax2.set_xlabel('Лична процена задовољства здрављем', labelpad=10, fontsize=13)
ax2.set_xticklabels(katZdravlje, rotation=0, fontsize=12)

fig.tight_layout()

Видимо да је највише испитаника са високом школом и оних који своје опште здравствено стање процењују као добро. Сада ћемо ове податке објединити на истом графикону тако што ћемо унутар сваке групе формиране на основу нивоа образовања "наслагати" испитанике по томе како су процењивали своје здравствено стање. Отуда и назив за ову врсту стубичастог дијаграма познатог као *stacked bar chart*. Nа левом графикону приказаћемо апсолутне бројеве, а на десном релативне, тачније проценте испитаника различитог здравственог статуса унутар сваке категорије образовања. 

# Дефинишемо празан низ nivo
nivo = []
# Петљом од 1 до 5 умећемо вредности у низ
for stepOb in range(1, 6):
    # Вредности су у ствари листе пребројаних испитаника по степену образовања за сваку оцену здравственог стања (stepOb)
    nivo.append(podaciDemUpit[(podaciDemUpit['HSD010'] == stepOb) & (podaciDemUpit['RIDAGEYR'] > 18)]['DMDEDUC2'].value_counts().sort_index())

# Повезујемо (engl. concatenate) листе за сваку категорију образовања у јединствену листу svi
svi = pd.concat(nivo, axis=1)

# Додељујемо називе колонама на основу варијабле коју смо дефинисали у претходној ћелији
svi.set_axis(katZdravlje, axis=1, inplace=True)

# Правимо копију скупа svi у којој апсолутне бројеве (учесталости) претварамо у проценте
sviProc = svi.copy()
# За то нам је потребна сума учесталости свих категорја оцена здравља
sviProc['sum'] = sviProc.iloc[:,0:5].sum(axis=1)
# Учесталост сваке категорије делимо сумом свих категорија и множимо са 100
for stepOb in range(0, 5):
    sviProc.iloc[:,stepOb] = sviProc.iloc[:,stepOb] / sviProc['sum'] * 100
# Колона sum нам више није потребна
sviProc = sviProc.drop('sum', axis=1)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(18,6))

# Параметар stacked је подешен на True јер желимо "наслагане" категорије 
svi.plot.barh(edgecolor='white', width=0.8, stacked=True, ax=ax1)
ax1.set_yticklabels(katObrazovanje, rotation=0, fontsize=13)
ax1.set_xlabel('Процена личног задовољства здрављем с обзиром на степен образовања', labelpad=10, fontsize=13)
# Легенду од првог графикона ћемо центрирати и искористи за оба
ax1.legend(loc='upper center', ncol=5, bbox_to_anchor=(0.5, 0.96), bbox_transform=plt.gcf().transFigure, fontsize=13, frameon=False)

sviProc.plot.barh(edgecolor='white', width=0.8, stacked=True, ax=ax2)
ax2.set_yticklabels(katObrazovanje, rotation=0, fontsize=13)
ax2.set_xlabel('Пропорције процена личног задовољства здрављем с обзиром на степен образовања', labelpad=10, fontsize=13)

# Легенда за други графикон нам није потребна
ax2.legend_.remove()

plt.show()

Графикон са леве стране је заправо раније приказани стубичасти дијаграм за степен образовања, али инвертован и ротиран за 90 степени. Поред тога, сваки стубић издељен је по категоријама формираним на основу субјективне процене личног задовољства здрављем. На десном графикону је свака трака "развучена" тако да попуни целу ширину графикона. На тај начин смо изгубили податак о учесталостима категорија, али тек оваквим приказом пропрционалног односа категорија уочавамо тренд пораста задовљства са порастом степена образовања. То се првенствено види по ширини наранџастих и црвених трака. Наравно, то нам не даје за право да образовање посматрамо као узрок, а задовољство као последицу или обратно. Много је вероватније да се у позадини бољих могућности за образовање и позитивније перцепције здравственог стања налази неки други, можда и заједнички фактор. Уз мале модификације можемо да искористимо горњи код како бисмо проверили да ли је можда тај заједнички фактор износ укупних прихода по домаћинству. Почетних 12 категорија ћемо смањити на 6 њиховим обједињавањем. 

# Формираћемо 6 категорија висине прихода
katPrihodi = ['< 10.000', '10.000 - 19.999', '20.000 - 34.999', '35.000 - 54.999', '55.000 - 74.999', '> 75.000']
# Почетних 12 категорија ћемо смањити тако што ћемо изједначити 2 и 1, 4 и 3, 6 и 5 итд.
podaciDemUpit["INDFMIN2"].replace({2: 1, 4: 3, 6: 5, 8: 7, 10: 9, 12: 11}, inplace=True)

# Све остало радимо као и у горњем примеру
nivo = []
for stepOb in range(1, 6):
    nivo.append(podaciDemUpit[(podaciDemUpit['HSD010'] == stepOb) & (podaciDemUpit['RIDAGEYR'] > 18) & (podaciDemUpit['INDFMIN2'] < 77)]['INDFMIN2'].value_counts().sort_index())

svi = pd.concat(nivo, axis = 1)
svi.set_axis(katZdravlje, axis=1, inplace=True)

sviProc = svi.copy()
sviProc['sum'] = sviProc.iloc[:,0:5].sum(axis=1)
for stepOb in range(0, 5):
    sviProc.iloc[:,stepOb] = sviProc.iloc[:,stepOb] / sviProc['sum'] * 100
sviProc = sviProc.drop('sum', axis=1)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(19,6))

svi.plot.barh(edgecolor='white', width=0.8, stacked=True, ax=ax1)
ax1.set_yticklabels(katPrihodi, rotation=0, fontsize=11)
ax1.set_xlabel('Процена личног задовољства здрављем с обзиром на укупне приходе', labelpad=10, fontsize=13)
ax1.legend(loc='upper center', ncol=5, bbox_to_anchor=(0.5, 0.96), bbox_transform=plt.gcf().transFigure, fontsize=13, frameon=False)

sviProc.plot.barh(edgecolor='white', width=0.8, stacked=True, ax=ax2)
ax2.set_yticklabels(katPrihodi, rotation=0, fontsize=11)
ax2.set_xlabel('Пропорције процена личног задовољства здрављем с обзиром на укупне приходе', labelpad=10, fontsize=13)

ax2.legend_.remove()

plt.show()

<div class="alert alert-block alert-info"><img src="slike/zad.png" align="left"/>Да ли горњи графикон упућује на закључак да су особе које живе у домаћинству са већим укупним приходима уједно и задовољније својим здравственим стањем?</div> 

<details>    
<summary>
    Прикажи одговор
</summary>
Могло би се рећи. Удео одговора 1 и 2 већи је код особа које живе у домаћинствима са мањим укупним приходима. Најуочљивије разлике су оне у пропорцијама одговора 2 и 4 међу испитаницима различитог материјалног статуса. 
